<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_392) on Thu Dec 05 14:16:21 UTC 2024 -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Cv3d (OpenCV 5.0.0alpha Java documentation)</title>
<meta name="date" content="2024-12-05">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Cv3d (OpenCV 5.0.0alpha Java documentation)";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":9,"i1":9,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9,"i8":9,"i9":9,"i10":9,"i11":9,"i12":9,"i13":9,"i14":9,"i15":9,"i16":9,"i17":9,"i18":9,"i19":9,"i20":9,"i21":9,"i22":9,"i23":9,"i24":9,"i25":9,"i26":9,"i27":9,"i28":9,"i29":9,"i30":9,"i31":9,"i32":9,"i33":9,"i34":9,"i35":9,"i36":9,"i37":9,"i38":9,"i39":9,"i40":9,"i41":9,"i42":9,"i43":9,"i44":9,"i45":9,"i46":9,"i47":9,"i48":9,"i49":9,"i50":9,"i51":9,"i52":9,"i53":9,"i54":9,"i55":9,"i56":9,"i57":9,"i58":9,"i59":9,"i60":9,"i61":9,"i62":9,"i63":9,"i64":9,"i65":9,"i66":9,"i67":9,"i68":9,"i69":9,"i70":9,"i71":9,"i72":9,"i73":9,"i74":9,"i75":9,"i76":9,"i77":9,"i78":9,"i79":9,"i80":9,"i81":9,"i82":9,"i83":9,"i84":9,"i85":9,"i86":9,"i87":9,"i88":9,"i89":9,"i90":9,"i91":9,"i92":9,"i93":9,"i94":9,"i95":9,"i96":9,"i97":9,"i98":9,"i99":9,"i100":9,"i101":9,"i102":9,"i103":9,"i104":9,"i105":9,"i106":9,"i107":9,"i108":9,"i109":9,"i110":9,"i111":9,"i112":9,"i113":9,"i114":9,"i115":9,"i116":9,"i117":9,"i118":9,"i119":9,"i120":9,"i121":9,"i122":9,"i123":9,"i124":9,"i125":9,"i126":9,"i127":9,"i128":9,"i129":9,"i130":9,"i131":9,"i132":9,"i133":9,"i134":9,"i135":9,"i136":9,"i137":9,"i138":9,"i139":9,"i140":9,"i141":9,"i142":9,"i143":9,"i144":9,"i145":9,"i146":9,"i147":9,"i148":9,"i149":9,"i150":9,"i151":9,"i152":9,"i153":9,"i154":9,"i155":9,"i156":9,"i157":9,"i158":9,"i159":9,"i160":9,"i161":9,"i162":9,"i163":9,"i164":9,"i165":9,"i166":9,"i167":9,"i168":9,"i169":9,"i170":9,"i171":9,"i172":9,"i173":9,"i174":9,"i175":9,"i176":9,"i177":9,"i178":9,"i179":9,"i180":9,"i181":9,"i182":9,"i183":9,"i184":9,"i185":9,"i186":9,"i187":9,"i188":9,"i189":9,"i190":9,"i191":9,"i192":9,"i193":9,"i194":9,"i195":9,"i196":9,"i197":9,"i198":9,"i199":9,"i200":9,"i201":9,"i202":9,"i203":9,"i204":9,"i205":9,"i206":9,"i207":9,"i208":9,"i209":9,"i210":9,"i211":9,"i212":9,"i213":9,"i214":9,"i215":9,"i216":9,"i217":9,"i218":9,"i219":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage">
            <script>
              var url = window.location.href;
              var pos = url.lastIndexOf('/javadoc/');
              url = pos >= 0 ? (url.substring(0, pos) + '/javadoc/mymath.js') : (window.location.origin + '/mymath.js');
              var script = document.createElement('script');
              script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML,' + url;
              document.getElementsByTagName('head')[0].appendChild(script);
            </script>
</div>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev&nbsp;Class</li>
<li><a href="../../../org/opencv/cv3d/Octree.html" title="class in org.opencv.cv3d"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?org/opencv/cv3d/Cv3d.html" target="_top">Frames</a></li>
<li><a href="Cv3d.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">org.opencv.cv3d</div>
<h2 title="Class Cv3d" class="title">Class Cv3d</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>org.opencv.cv3d.Cv3d</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public class <span class="typeNameLabel">Cv3d</span>
extends java.lang.Object</pre>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#COV_POLISHER">COV_POLISHER</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#FM_7POINT">FM_7POINT</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#FM_8POINT">FM_8POINT</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#FM_LMEDS">FM_LMEDS</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#FM_RANSAC">FM_RANSAC</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#LMEDS">LMEDS</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#LOCAL_OPTIM_GC">LOCAL_OPTIM_GC</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#LOCAL_OPTIM_INNER_AND_ITER_LO">LOCAL_OPTIM_INNER_AND_ITER_LO</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#LOCAL_OPTIM_INNER_LO">LOCAL_OPTIM_INNER_LO</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#LOCAL_OPTIM_NULL">LOCAL_OPTIM_NULL</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#LOCAL_OPTIM_SIGMA">LOCAL_OPTIM_SIGMA</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#LSQ_POLISHER">LSQ_POLISHER</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#MAGSAC">MAGSAC</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#MatrixType_AUTO">MatrixType_AUTO</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#MatrixType_DENSE">MatrixType_DENSE</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#MatrixType_SPARSE">MatrixType_SPARSE</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#N_PYRAMIDS">N_PYRAMIDS</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#NEIGH_FLANN_KNN">NEIGH_FLANN_KNN</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#NEIGH_FLANN_RADIUS">NEIGH_FLANN_RADIUS</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#NEIGH_GRID">NEIGH_GRID</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#NONE_POLISHER">NONE_POLISHER</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#OdometryAlgoType_COMMON">OdometryAlgoType_COMMON</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#OdometryAlgoType_FAST">OdometryAlgoType_FAST</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#OdometryType_DEPTH">OdometryType_DEPTH</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#OdometryType_RGB">OdometryType_RGB</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#OdometryType_RGB_DEPTH">OdometryType_RGB_DEPTH</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#PROJ_SPHERICAL_EQRECT">PROJ_SPHERICAL_EQRECT</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#PROJ_SPHERICAL_ORTHO">PROJ_SPHERICAL_ORTHO</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#PYR_CLOUD">PYR_CLOUD</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#PYR_DEPTH">PYR_DEPTH</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#PYR_DIX">PYR_DIX</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#PYR_DIY">PYR_DIY</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#PYR_IMAGE">PYR_IMAGE</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#PYR_MASK">PYR_MASK</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#PYR_NORM">PYR_NORM</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#PYR_NORMMASK">PYR_NORMMASK</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#PYR_TEXMASK">PYR_TEXMASK</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#RANSAC">RANSAC</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#RASTERIZE_COMPAT_DISABLED">RASTERIZE_COMPAT_DISABLED</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#RASTERIZE_COMPAT_INVDEPTH">RASTERIZE_COMPAT_INVDEPTH</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#RASTERIZE_CULLING_CCW">RASTERIZE_CULLING_CCW</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#RASTERIZE_CULLING_CW">RASTERIZE_CULLING_CW</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#RASTERIZE_CULLING_NONE">RASTERIZE_CULLING_NONE</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#RASTERIZE_SHADING_FLAT">RASTERIZE_SHADING_FLAT</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#RASTERIZE_SHADING_SHADED">RASTERIZE_SHADING_SHADED</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#RASTERIZE_SHADING_WHITE">RASTERIZE_SHADING_WHITE</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#RGBD_PLANE_METHOD_DEFAULT">RGBD_PLANE_METHOD_DEFAULT</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#RHO">RHO</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#SAC_METHOD_RANSAC">SAC_METHOD_RANSAC</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#SAC_MODEL_PLANE">SAC_MODEL_PLANE</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#SAC_MODEL_SPHERE">SAC_MODEL_SPHERE</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#SAMPLING_NAPSAC">SAMPLING_NAPSAC</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#SAMPLING_PROGRESSIVE_NAPSAC">SAMPLING_PROGRESSIVE_NAPSAC</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#SAMPLING_PROSAC">SAMPLING_PROSAC</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#SAMPLING_UNIFORM">SAMPLING_UNIFORM</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#SCORE_METHOD_LMEDS">SCORE_METHOD_LMEDS</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#SCORE_METHOD_MAGSAC">SCORE_METHOD_MAGSAC</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#SCORE_METHOD_MSAC">SCORE_METHOD_MSAC</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#SCORE_METHOD_RANSAC">SCORE_METHOD_RANSAC</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#SOLVEPNP_AP3P">SOLVEPNP_AP3P</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#SOLVEPNP_DLS">SOLVEPNP_DLS</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#SOLVEPNP_EPNP">SOLVEPNP_EPNP</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#SOLVEPNP_IPPE">SOLVEPNP_IPPE</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#SOLVEPNP_IPPE_SQUARE">SOLVEPNP_IPPE_SQUARE</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#SOLVEPNP_ITERATIVE">SOLVEPNP_ITERATIVE</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#SOLVEPNP_MAX_COUNT">SOLVEPNP_MAX_COUNT</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#SOLVEPNP_P3P">SOLVEPNP_P3P</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#SOLVEPNP_SQPNP">SOLVEPNP_SQPNP</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#SOLVEPNP_UPNP">SOLVEPNP_UPNP</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#USAC_ACCURATE">USAC_ACCURATE</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#USAC_DEFAULT">USAC_DEFAULT</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#USAC_FAST">USAC_FAST</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#USAC_FM_8PTS">USAC_FM_8PTS</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#USAC_MAGSAC">USAC_MAGSAC</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#USAC_PARALLEL">USAC_PARALLEL</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#USAC_PROSAC">USAC_PROSAC</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#VariableType_LINEAR">VariableType_LINEAR</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#VariableType_SE3">VariableType_SE3</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#VariableType_SO3">VariableType_SO3</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#VolumeType_ColorTSDF">VolumeType_ColorTSDF</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#VolumeType_HashTSDF">VolumeType_HashTSDF</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#VolumeType_TSDF">VolumeType_TSDF</a></span></code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#Cv3d--">Cv3d</a></span>()</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#composeRT-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">composeRT</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec1,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec1,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec2,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec2,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec3,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec3)</code>
<div class="block">Combines two rotation-and-shift transformations.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#composeRT-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">composeRT</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec1,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec1,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec2,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec2,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec3,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec3,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dr1)</code>
<div class="block">Combines two rotation-and-shift transformations.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#composeRT-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">composeRT</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec1,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec1,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec2,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec2,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec3,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec3,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dr1,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dt1)</code>
<div class="block">Combines two rotation-and-shift transformations.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#composeRT-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">composeRT</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec1,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec1,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec2,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec2,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec3,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec3,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dr1,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dt1,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dr2)</code>
<div class="block">Combines two rotation-and-shift transformations.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#composeRT-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">composeRT</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec1,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec1,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec2,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec2,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec3,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec3,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dr1,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dt1,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dr2,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dt2)</code>
<div class="block">Combines two rotation-and-shift transformations.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#composeRT-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">composeRT</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec1,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec1,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec2,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec2,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec3,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec3,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dr1,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dt1,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dr2,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dt2,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dt3dr1)</code>
<div class="block">Combines two rotation-and-shift transformations.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#composeRT-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">composeRT</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec1,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec1,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec2,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec2,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec3,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec3,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dr1,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dt1,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dr2,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dt2,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dt3dr1,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dt3dt1)</code>
<div class="block">Combines two rotation-and-shift transformations.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#composeRT-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">composeRT</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec1,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec1,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec2,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec2,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec3,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec3,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dr1,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dt1,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dr2,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dt2,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dt3dr1,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dt3dt1,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dt3dr2)</code>
<div class="block">Combines two rotation-and-shift transformations.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#composeRT-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">composeRT</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec1,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec1,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec2,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec2,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec3,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec3,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dr1,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dt1,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dr2,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dt2,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dt3dr1,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dt3dt1,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dt3dr2,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dt3dt2)</code>
<div class="block">Combines two rotation-and-shift transformations.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#computeCorrespondEpilines-org.opencv.core.Mat-int-org.opencv.core.Mat-org.opencv.core.Mat-">computeCorrespondEpilines</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points,
                         int&nbsp;whichImage,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;F,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines)</code>
<div class="block">For points in an image of a stereo pair, computes the corresponding epilines in the other image.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#convertPointsFromHomogeneous-org.opencv.core.Mat-org.opencv.core.Mat-">convertPointsFromHomogeneous</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Converts points from homogeneous to Euclidean space.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#convertPointsFromHomogeneous-org.opencv.core.Mat-org.opencv.core.Mat-int-">convertPointsFromHomogeneous</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                            int&nbsp;dtype)</code>
<div class="block">Converts points from homogeneous to Euclidean space.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#convertPointsToHomogeneous-org.opencv.core.Mat-org.opencv.core.Mat-">convertPointsToHomogeneous</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Converts points from Euclidean to homogeneous space.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#convertPointsToHomogeneous-org.opencv.core.Mat-org.opencv.core.Mat-int-">convertPointsToHomogeneous</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                          int&nbsp;dtype)</code>
<div class="block">Converts points from Euclidean to homogeneous space.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#correctMatches-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">correctMatches</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;F,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;newPoints1,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;newPoints2)</code>
<div class="block">Refines coordinates of corresponding points.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#decomposeEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">decomposeEssentialMat</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;E,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R1,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R2,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;t)</code>
<div class="block">Decompose an essential matrix to possible rotations and translation.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#decomposeHomographyMat-org.opencv.core.Mat-org.opencv.core.Mat-java.util.List-java.util.List-java.util.List-">decomposeHomographyMat</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;H,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                      java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;rotations,
                      java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;translations,
                      java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;normals)</code>
<div class="block">Decompose a homography matrix to rotation(s), translation(s) and plane normal(s).</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#decomposeProjectionMatrix-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">decomposeProjectionMatrix</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;projMatrix,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rotMatrix,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;transVect)</code>
<div class="block">Decomposes a projection matrix into a rotation matrix and a camera intrinsic matrix.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#decomposeProjectionMatrix-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">decomposeProjectionMatrix</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;projMatrix,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rotMatrix,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;transVect,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rotMatrixX)</code>
<div class="block">Decomposes a projection matrix into a rotation matrix and a camera intrinsic matrix.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#decomposeProjectionMatrix-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">decomposeProjectionMatrix</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;projMatrix,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rotMatrix,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;transVect,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rotMatrixX,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rotMatrixY)</code>
<div class="block">Decomposes a projection matrix into a rotation matrix and a camera intrinsic matrix.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#decomposeProjectionMatrix-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">decomposeProjectionMatrix</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;projMatrix,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rotMatrix,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;transVect,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rotMatrixX,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rotMatrixY,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rotMatrixZ)</code>
<div class="block">Decomposes a projection matrix into a rotation matrix and a camera intrinsic matrix.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#decomposeProjectionMatrix-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">decomposeProjectionMatrix</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;projMatrix,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rotMatrix,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;transVect,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rotMatrixX,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rotMatrixY,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rotMatrixZ,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eulerAngles)</code>
<div class="block">Decomposes a projection matrix into a rotation matrix and a camera intrinsic matrix.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#depthTo3d-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">depthTo3d</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;depth,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points3d)</code>
<div class="block">Converts a depth image to 3d points.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#depthTo3d-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">depthTo3d</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;depth,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points3d,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>
<div class="block">Converts a depth image to 3d points.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#depthTo3dSparse-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">depthTo3dSparse</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;depth,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;in_K,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;in_points,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points3d)</code>&nbsp;</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#drawFrameAxes-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-float-">drawFrameAxes</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
             float&nbsp;length)</code>
<div class="block">Draw axes of the world/object coordinate system from pose estimation.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#drawFrameAxes-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-float-int-">drawFrameAxes</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
             float&nbsp;length,
             int&nbsp;thickness)</code>
<div class="block">Draw axes of the world/object coordinate system from pose estimation.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#estimateAffine2D-org.opencv.core.Mat-org.opencv.core.Mat-">estimateAffine2D</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;from,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;to)</code>
<div class="block">Computes an optimal affine transformation between two 2D point sets.</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#estimateAffine2D-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">estimateAffine2D</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;from,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;to,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers)</code>
<div class="block">Computes an optimal affine transformation between two 2D point sets.</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#estimateAffine2D-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">estimateAffine2D</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;from,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;to,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers,
                int&nbsp;method)</code>
<div class="block">Computes an optimal affine transformation between two 2D point sets.</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#estimateAffine2D-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-double-">estimateAffine2D</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;from,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;to,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers,
                int&nbsp;method,
                double&nbsp;ransacReprojThreshold)</code>
<div class="block">Computes an optimal affine transformation between two 2D point sets.</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#estimateAffine2D-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-double-long-">estimateAffine2D</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;from,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;to,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers,
                int&nbsp;method,
                double&nbsp;ransacReprojThreshold,
                long&nbsp;maxIters)</code>
<div class="block">Computes an optimal affine transformation between two 2D point sets.</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#estimateAffine2D-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-double-long-double-">estimateAffine2D</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;from,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;to,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers,
                int&nbsp;method,
                double&nbsp;ransacReprojThreshold,
                long&nbsp;maxIters,
                double&nbsp;confidence)</code>
<div class="block">Computes an optimal affine transformation between two 2D point sets.</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#estimateAffine2D-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-double-long-double-long-">estimateAffine2D</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;from,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;to,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers,
                int&nbsp;method,
                double&nbsp;ransacReprojThreshold,
                long&nbsp;maxIters,
                double&nbsp;confidence,
                long&nbsp;refineIters)</code>
<div class="block">Computes an optimal affine transformation between two 2D point sets.</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#estimateAffine2D-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.cv3d.UsacParams-">estimateAffine2D</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;pts1,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;pts2,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers,
                <a href="../../../org/opencv/cv3d/UsacParams.html" title="class in org.opencv.cv3d">UsacParams</a>&nbsp;params)</code>&nbsp;</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#estimateAffine3D-org.opencv.core.Mat-org.opencv.core.Mat-">estimateAffine3D</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Computes an optimal affine transformation between two 3D point sets.</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#estimateAffine3D-org.opencv.core.Mat-org.opencv.core.Mat-double:A-">estimateAffine3D</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                double[]&nbsp;scale)</code>
<div class="block">Computes an optimal affine transformation between two 3D point sets.</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#estimateAffine3D-org.opencv.core.Mat-org.opencv.core.Mat-double:A-boolean-">estimateAffine3D</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                double[]&nbsp;scale,
                boolean&nbsp;force_rotation)</code>
<div class="block">Computes an optimal affine transformation between two 3D point sets.</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#estimateAffine3D-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">estimateAffine3D</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;out,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers)</code>
<div class="block">Computes an optimal affine transformation between two 3D point sets.</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#estimateAffine3D-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-">estimateAffine3D</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;out,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers,
                double&nbsp;ransacThreshold)</code>
<div class="block">Computes an optimal affine transformation between two 3D point sets.</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#estimateAffine3D-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-double-">estimateAffine3D</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;out,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers,
                double&nbsp;ransacThreshold,
                double&nbsp;confidence)</code>
<div class="block">Computes an optimal affine transformation between two 3D point sets.</div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#estimateAffinePartial2D-org.opencv.core.Mat-org.opencv.core.Mat-">estimateAffinePartial2D</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;from,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;to)</code>
<div class="block">Computes an optimal limited affine transformation with 4 degrees of freedom between
 two 2D point sets.</div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#estimateAffinePartial2D-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">estimateAffinePartial2D</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;from,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;to,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers)</code>
<div class="block">Computes an optimal limited affine transformation with 4 degrees of freedom between
 two 2D point sets.</div>
</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#estimateAffinePartial2D-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">estimateAffinePartial2D</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;from,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;to,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers,
                       int&nbsp;method)</code>
<div class="block">Computes an optimal limited affine transformation with 4 degrees of freedom between
 two 2D point sets.</div>
</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#estimateAffinePartial2D-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-double-">estimateAffinePartial2D</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;from,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;to,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers,
                       int&nbsp;method,
                       double&nbsp;ransacReprojThreshold)</code>
<div class="block">Computes an optimal limited affine transformation with 4 degrees of freedom between
 two 2D point sets.</div>
</td>
</tr>
<tr id="i45" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#estimateAffinePartial2D-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-double-long-">estimateAffinePartial2D</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;from,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;to,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers,
                       int&nbsp;method,
                       double&nbsp;ransacReprojThreshold,
                       long&nbsp;maxIters)</code>
<div class="block">Computes an optimal limited affine transformation with 4 degrees of freedom between
 two 2D point sets.</div>
</td>
</tr>
<tr id="i46" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#estimateAffinePartial2D-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-double-long-double-">estimateAffinePartial2D</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;from,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;to,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers,
                       int&nbsp;method,
                       double&nbsp;ransacReprojThreshold,
                       long&nbsp;maxIters,
                       double&nbsp;confidence)</code>
<div class="block">Computes an optimal limited affine transformation with 4 degrees of freedom between
 two 2D point sets.</div>
</td>
</tr>
<tr id="i47" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#estimateAffinePartial2D-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-double-long-double-long-">estimateAffinePartial2D</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;from,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;to,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers,
                       int&nbsp;method,
                       double&nbsp;ransacReprojThreshold,
                       long&nbsp;maxIters,
                       double&nbsp;confidence,
                       long&nbsp;refineIters)</code>
<div class="block">Computes an optimal limited affine transformation with 4 degrees of freedom between
 two 2D point sets.</div>
</td>
</tr>
<tr id="i48" class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#estimateTranslation3D-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">estimateTranslation3D</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;out,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers)</code>
<div class="block">Computes an optimal translation between two 3D point sets.</div>
</td>
</tr>
<tr id="i49" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#estimateTranslation3D-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-">estimateTranslation3D</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;out,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers,
                     double&nbsp;ransacThreshold)</code>
<div class="block">Computes an optimal translation between two 3D point sets.</div>
</td>
</tr>
<tr id="i50" class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#estimateTranslation3D-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-double-">estimateTranslation3D</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;out,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers,
                     double&nbsp;ransacThreshold,
                     double&nbsp;confidence)</code>
<div class="block">Computes an optimal translation between two 3D point sets.</div>
</td>
</tr>
<tr id="i51" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#filterHomographyDecompByVisibleRefpoints-java.util.List-java.util.List-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">filterHomographyDecompByVisibleRefpoints</a></span>(java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;rotations,
                                        java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;normals,
                                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;beforePoints,
                                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;afterPoints,
                                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;possibleSolutions)</code>
<div class="block">Filters homography decompositions based on additional information.</div>
</td>
</tr>
<tr id="i52" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#filterHomographyDecompByVisibleRefpoints-java.util.List-java.util.List-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">filterHomographyDecompByVisibleRefpoints</a></span>(java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;rotations,
                                        java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;normals,
                                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;beforePoints,
                                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;afterPoints,
                                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;possibleSolutions,
                                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;pointsMask)</code>
<div class="block">Filters homography decompositions based on additional information.</div>
</td>
</tr>
<tr id="i53" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-">findEssentialMat</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2)</code>&nbsp;</td>
</tr>
<tr id="i54" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-double-">findEssentialMat</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                double&nbsp;focal)</code>&nbsp;</td>
</tr>
<tr id="i55" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-double-org.opencv.core.Point-">findEssentialMat</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                double&nbsp;focal,
                <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pp)</code>&nbsp;</td>
</tr>
<tr id="i56" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-double-org.opencv.core.Point-int-">findEssentialMat</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                double&nbsp;focal,
                <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pp,
                int&nbsp;method)</code>&nbsp;</td>
</tr>
<tr id="i57" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-double-org.opencv.core.Point-int-double-">findEssentialMat</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                double&nbsp;focal,
                <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pp,
                int&nbsp;method,
                double&nbsp;prob)</code>&nbsp;</td>
</tr>
<tr id="i58" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-double-org.opencv.core.Point-int-double-double-">findEssentialMat</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                double&nbsp;focal,
                <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pp,
                int&nbsp;method,
                double&nbsp;prob,
                double&nbsp;threshold)</code>&nbsp;</td>
</tr>
<tr id="i59" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-double-org.opencv.core.Point-int-double-double-int-">findEssentialMat</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                double&nbsp;focal,
                <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pp,
                int&nbsp;method,
                double&nbsp;prob,
                double&nbsp;threshold,
                int&nbsp;maxIters)</code>&nbsp;</td>
</tr>
<tr id="i60" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-double-org.opencv.core.Point-int-double-double-int-org.opencv.core.Mat-">findEssentialMat</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                double&nbsp;focal,
                <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pp,
                int&nbsp;method,
                double&nbsp;prob,
                double&nbsp;threshold,
                int&nbsp;maxIters,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>&nbsp;</td>
</tr>
<tr id="i61" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">findEssentialMat</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix)</code>
<div class="block">Calculates an essential matrix from the corresponding points in two images.</div>
</td>
</tr>
<tr id="i62" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">findEssentialMat</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                int&nbsp;method)</code>
<div class="block">Calculates an essential matrix from the corresponding points in two images.</div>
</td>
</tr>
<tr id="i63" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-double-">findEssentialMat</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                int&nbsp;method,
                double&nbsp;prob)</code>
<div class="block">Calculates an essential matrix from the corresponding points in two images.</div>
</td>
</tr>
<tr id="i64" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-">findEssentialMat</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                int&nbsp;method,
                double&nbsp;prob,
                double&nbsp;threshold)</code>
<div class="block">Calculates an essential matrix from the corresponding points in two images.</div>
</td>
</tr>
<tr id="i65" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-int-">findEssentialMat</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                int&nbsp;method,
                double&nbsp;prob,
                double&nbsp;threshold,
                int&nbsp;maxIters)</code>
<div class="block">Calculates an essential matrix from the corresponding points in two images.</div>
</td>
</tr>
<tr id="i66" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-int-org.opencv.core.Mat-">findEssentialMat</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                int&nbsp;method,
                double&nbsp;prob,
                double&nbsp;threshold,
                int&nbsp;maxIters,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>
<div class="block">Calculates an essential matrix from the corresponding points in two images.</div>
</td>
</tr>
<tr id="i67" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">findEssentialMat</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix1,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs1,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix2,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs2)</code>
<div class="block">Calculates an essential matrix from the corresponding points in two images from potentially two different cameras.</div>
</td>
</tr>
<tr id="i68" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">findEssentialMat</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix1,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs1,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix2,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs2,
                int&nbsp;method)</code>
<div class="block">Calculates an essential matrix from the corresponding points in two images from potentially two different cameras.</div>
</td>
</tr>
<tr id="i69" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-double-">findEssentialMat</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix1,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs1,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix2,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs2,
                int&nbsp;method,
                double&nbsp;prob)</code>
<div class="block">Calculates an essential matrix from the corresponding points in two images from potentially two different cameras.</div>
</td>
</tr>
<tr id="i70" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-">findEssentialMat</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix1,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs1,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix2,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs2,
                int&nbsp;method,
                double&nbsp;prob,
                double&nbsp;threshold)</code>
<div class="block">Calculates an essential matrix from the corresponding points in two images from potentially two different cameras.</div>
</td>
</tr>
<tr id="i71" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-org.opencv.core.Mat-">findEssentialMat</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix1,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs1,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix2,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs2,
                int&nbsp;method,
                double&nbsp;prob,
                double&nbsp;threshold,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>
<div class="block">Calculates an essential matrix from the corresponding points in two images from potentially two different cameras.</div>
</td>
</tr>
<tr id="i72" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.cv3d.UsacParams-">findEssentialMat</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix1,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix2,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dist_coeff1,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dist_coeff2,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                <a href="../../../org/opencv/cv3d/UsacParams.html" title="class in org.opencv.cv3d">UsacParams</a>&nbsp;params)</code>&nbsp;</td>
</tr>
<tr id="i73" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findFundamentalMat-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-">findFundamentalMat</a></span>(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points1,
                  <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points2)</code>&nbsp;</td>
</tr>
<tr id="i74" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findFundamentalMat-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-int-">findFundamentalMat</a></span>(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points1,
                  <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points2,
                  int&nbsp;method)</code>&nbsp;</td>
</tr>
<tr id="i75" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findFundamentalMat-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-int-double-">findFundamentalMat</a></span>(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points1,
                  <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points2,
                  int&nbsp;method,
                  double&nbsp;ransacReprojThreshold)</code>&nbsp;</td>
</tr>
<tr id="i76" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findFundamentalMat-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-int-double-double-">findFundamentalMat</a></span>(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points1,
                  <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points2,
                  int&nbsp;method,
                  double&nbsp;ransacReprojThreshold,
                  double&nbsp;confidence)</code>&nbsp;</td>
</tr>
<tr id="i77" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findFundamentalMat-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-int-double-double-int-">findFundamentalMat</a></span>(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points1,
                  <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points2,
                  int&nbsp;method,
                  double&nbsp;ransacReprojThreshold,
                  double&nbsp;confidence,
                  int&nbsp;maxIters)</code>
<div class="block">Calculates a fundamental matrix from the corresponding points in two images.</div>
</td>
</tr>
<tr id="i78" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findFundamentalMat-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-int-double-double-int-org.opencv.core.Mat-">findFundamentalMat</a></span>(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points1,
                  <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points2,
                  int&nbsp;method,
                  double&nbsp;ransacReprojThreshold,
                  double&nbsp;confidence,
                  int&nbsp;maxIters,
                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>
<div class="block">Calculates a fundamental matrix from the corresponding points in two images.</div>
</td>
</tr>
<tr id="i79" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findFundamentalMat-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-int-double-double-org.opencv.core.Mat-">findFundamentalMat</a></span>(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points1,
                  <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points2,
                  int&nbsp;method,
                  double&nbsp;ransacReprojThreshold,
                  double&nbsp;confidence,
                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>&nbsp;</td>
</tr>
<tr id="i80" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findFundamentalMat-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-org.opencv.cv3d.UsacParams-">findFundamentalMat</a></span>(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points1,
                  <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points2,
                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                  <a href="../../../org/opencv/cv3d/UsacParams.html" title="class in org.opencv.cv3d">UsacParams</a>&nbsp;params)</code>&nbsp;</td>
</tr>
<tr id="i81" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findHomography-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-">findHomography</a></span>(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;srcPoints,
              <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;dstPoints)</code>
<div class="block">Finds a perspective transformation between two planes.</div>
</td>
</tr>
<tr id="i82" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findHomography-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-int-">findHomography</a></span>(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;srcPoints,
              <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;dstPoints,
              int&nbsp;method)</code>
<div class="block">Finds a perspective transformation between two planes.</div>
</td>
</tr>
<tr id="i83" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findHomography-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-int-double-">findHomography</a></span>(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;srcPoints,
              <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;dstPoints,
              int&nbsp;method,
              double&nbsp;ransacReprojThreshold)</code>
<div class="block">Finds a perspective transformation between two planes.</div>
</td>
</tr>
<tr id="i84" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findHomography-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-int-double-org.opencv.core.Mat-">findHomography</a></span>(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;srcPoints,
              <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;dstPoints,
              int&nbsp;method,
              double&nbsp;ransacReprojThreshold,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>
<div class="block">Finds a perspective transformation between two planes.</div>
</td>
</tr>
<tr id="i85" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findHomography-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-int-double-org.opencv.core.Mat-int-">findHomography</a></span>(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;srcPoints,
              <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;dstPoints,
              int&nbsp;method,
              double&nbsp;ransacReprojThreshold,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
              int&nbsp;maxIters)</code>
<div class="block">Finds a perspective transformation between two planes.</div>
</td>
</tr>
<tr id="i86" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findHomography-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-int-double-org.opencv.core.Mat-int-double-">findHomography</a></span>(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;srcPoints,
              <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;dstPoints,
              int&nbsp;method,
              double&nbsp;ransacReprojThreshold,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
              int&nbsp;maxIters,
              double&nbsp;confidence)</code>
<div class="block">Finds a perspective transformation between two planes.</div>
</td>
</tr>
<tr id="i87" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findHomography-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-org.opencv.cv3d.UsacParams-">findHomography</a></span>(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;srcPoints,
              <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;dstPoints,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
              <a href="../../../org/opencv/cv3d/UsacParams.html" title="class in org.opencv.cv3d">UsacParams</a>&nbsp;params)</code>&nbsp;</td>
</tr>
<tr id="i88" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findPlanes-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">findPlanes</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points3d,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;normals,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;plane_coefficients)</code>
<div class="block">Find the planes in a depth image</div>
</td>
</tr>
<tr id="i89" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findPlanes-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">findPlanes</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points3d,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;normals,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;plane_coefficients,
          int&nbsp;block_size)</code>
<div class="block">Find the planes in a depth image</div>
</td>
</tr>
<tr id="i90" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findPlanes-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">findPlanes</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points3d,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;normals,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;plane_coefficients,
          int&nbsp;block_size,
          int&nbsp;min_size)</code>
<div class="block">Find the planes in a depth image</div>
</td>
</tr>
<tr id="i91" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findPlanes-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-int-double-">findPlanes</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points3d,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;normals,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;plane_coefficients,
          int&nbsp;block_size,
          int&nbsp;min_size,
          double&nbsp;threshold)</code>
<div class="block">Find the planes in a depth image</div>
</td>
</tr>
<tr id="i92" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findPlanes-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-int-double-double-">findPlanes</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points3d,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;normals,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;plane_coefficients,
          int&nbsp;block_size,
          int&nbsp;min_size,
          double&nbsp;threshold,
          double&nbsp;sensor_error_a)</code>
<div class="block">Find the planes in a depth image</div>
</td>
</tr>
<tr id="i93" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findPlanes-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-int-double-double-double-">findPlanes</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points3d,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;normals,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;plane_coefficients,
          int&nbsp;block_size,
          int&nbsp;min_size,
          double&nbsp;threshold,
          double&nbsp;sensor_error_a,
          double&nbsp;sensor_error_b)</code>
<div class="block">Find the planes in a depth image</div>
</td>
</tr>
<tr id="i94" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findPlanes-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-int-double-double-double-double-">findPlanes</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points3d,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;normals,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;plane_coefficients,
          int&nbsp;block_size,
          int&nbsp;min_size,
          double&nbsp;threshold,
          double&nbsp;sensor_error_a,
          double&nbsp;sensor_error_b,
          double&nbsp;sensor_error_c)</code>
<div class="block">Find the planes in a depth image</div>
</td>
</tr>
<tr id="i95" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#findPlanes-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-int-double-double-double-double-int-">findPlanes</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points3d,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;normals,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;plane_coefficients,
          int&nbsp;block_size,
          int&nbsp;min_size,
          double&nbsp;threshold,
          double&nbsp;sensor_error_a,
          double&nbsp;sensor_error_b,
          double&nbsp;sensor_error_c,
          int&nbsp;method)</code>
<div class="block">Find the planes in a depth image</div>
</td>
</tr>
<tr id="i96" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#fisheye_distortPoints-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">fisheye_distortPoints</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;undistorted,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distorted,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;D)</code>
<div class="block">Distorts 2D points using fisheye model.</div>
</td>
</tr>
<tr id="i97" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#fisheye_distortPoints-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-">fisheye_distortPoints</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;undistorted,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distorted,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;D,
                     double&nbsp;alpha)</code>
<div class="block">Distorts 2D points using fisheye model.</div>
</td>
</tr>
<tr id="i98" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#fisheye_distortPoints-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">fisheye_distortPoints</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;undistorted,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distorted,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Kundistorted,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;D)</code>
<div class="block">Overload of distortPoints function to handle cases when undistorted points are got with non-identity
 camera matrix, e.g.</div>
</td>
</tr>
<tr id="i99" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#fisheye_distortPoints-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-">fisheye_distortPoints</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;undistorted,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distorted,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Kundistorted,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;D,
                     double&nbsp;alpha)</code>
<div class="block">Overload of distortPoints function to handle cases when undistorted points are got with non-identity
 camera matrix, e.g.</div>
</td>
</tr>
<tr id="i100" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#fisheye_estimateNewCameraMatrixForUndistortRectify-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-org.opencv.core.Mat-org.opencv.core.Mat-">fisheye_estimateNewCameraMatrixForUndistortRectify</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;D,
                                                  <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;image_size,
                                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
                                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;P)</code>
<div class="block">Estimates new camera intrinsic matrix for undistortion or rectification.</div>
</td>
</tr>
<tr id="i101" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#fisheye_estimateNewCameraMatrixForUndistortRectify-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-org.opencv.core.Mat-org.opencv.core.Mat-double-">fisheye_estimateNewCameraMatrixForUndistortRectify</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;D,
                                                  <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;image_size,
                                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
                                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;P,
                                                  double&nbsp;balance)</code>
<div class="block">Estimates new camera intrinsic matrix for undistortion or rectification.</div>
</td>
</tr>
<tr id="i102" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#fisheye_estimateNewCameraMatrixForUndistortRectify-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-org.opencv.core.Mat-org.opencv.core.Mat-double-org.opencv.core.Size-">fisheye_estimateNewCameraMatrixForUndistortRectify</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;D,
                                                  <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;image_size,
                                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
                                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;P,
                                                  double&nbsp;balance,
                                                  <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;new_size)</code>
<div class="block">Estimates new camera intrinsic matrix for undistortion or rectification.</div>
</td>
</tr>
<tr id="i103" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#fisheye_estimateNewCameraMatrixForUndistortRectify-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-org.opencv.core.Mat-org.opencv.core.Mat-double-org.opencv.core.Size-double-">fisheye_estimateNewCameraMatrixForUndistortRectify</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;D,
                                                  <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;image_size,
                                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
                                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;P,
                                                  double&nbsp;balance,
                                                  <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;new_size,
                                                  double&nbsp;fov_scale)</code>
<div class="block">Estimates new camera intrinsic matrix for undistortion or rectification.</div>
</td>
</tr>
<tr id="i104" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#fisheye_initUndistortRectifyMap-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-int-org.opencv.core.Mat-org.opencv.core.Mat-">fisheye_initUndistortRectifyMap</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;D,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;P,
                               <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;size,
                               int&nbsp;m1type,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map1,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map2)</code>
<div class="block">Computes undistortion and rectification maps for image transform by cv::remap().</div>
</td>
</tr>
<tr id="i105" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#fisheye_projectPoints-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">fisheye_projectPoints</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;D)</code>&nbsp;</td>
</tr>
<tr id="i106" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#fisheye_projectPoints-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-">fisheye_projectPoints</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;D,
                     double&nbsp;alpha)</code>&nbsp;</td>
</tr>
<tr id="i107" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#fisheye_projectPoints-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-org.opencv.core.Mat-">fisheye_projectPoints</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;D,
                     double&nbsp;alpha,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;jacobian)</code>&nbsp;</td>
</tr>
<tr id="i108" class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#fisheye_solvePnP-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">fisheye_solvePnP</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec)</code>
<div class="block">Finds an object pose from 3D-2D point correspondences for fisheye camera moodel.</div>
</td>
</tr>
<tr id="i109" class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#fisheye_solvePnP-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-boolean-">fisheye_solvePnP</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                boolean&nbsp;useExtrinsicGuess)</code>
<div class="block">Finds an object pose from 3D-2D point correspondences for fisheye camera moodel.</div>
</td>
</tr>
<tr id="i110" class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#fisheye_solvePnP-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-boolean-int-">fisheye_solvePnP</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                boolean&nbsp;useExtrinsicGuess,
                int&nbsp;flags)</code>
<div class="block">Finds an object pose from 3D-2D point correspondences for fisheye camera moodel.</div>
</td>
</tr>
<tr id="i111" class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#fisheye_solvePnP-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-boolean-int-org.opencv.core.TermCriteria-">fisheye_solvePnP</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                boolean&nbsp;useExtrinsicGuess,
                int&nbsp;flags,
                <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria)</code>
<div class="block">Finds an object pose from 3D-2D point correspondences for fisheye camera moodel.</div>
</td>
</tr>
<tr id="i112" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#fisheye_undistortImage-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">fisheye_undistortImage</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distorted,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;undistorted,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;D)</code>
<div class="block">Transforms an image to compensate for fisheye lens distortion.</div>
</td>
</tr>
<tr id="i113" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#fisheye_undistortImage-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">fisheye_undistortImage</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distorted,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;undistorted,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;D,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Knew)</code>
<div class="block">Transforms an image to compensate for fisheye lens distortion.</div>
</td>
</tr>
<tr id="i114" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#fisheye_undistortImage-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-">fisheye_undistortImage</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distorted,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;undistorted,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;D,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Knew,
                      <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;new_size)</code>
<div class="block">Transforms an image to compensate for fisheye lens distortion.</div>
</td>
</tr>
<tr id="i115" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#fisheye_undistortPoints-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">fisheye_undistortPoints</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distorted,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;undistorted,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;D)</code>
<div class="block">Undistorts 2D points using fisheye model</div>
</td>
</tr>
<tr id="i116" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#fisheye_undistortPoints-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">fisheye_undistortPoints</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distorted,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;undistorted,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;D,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R)</code>
<div class="block">Undistorts 2D points using fisheye model</div>
</td>
</tr>
<tr id="i117" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#fisheye_undistortPoints-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">fisheye_undistortPoints</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distorted,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;undistorted,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;D,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;P)</code>
<div class="block">Undistorts 2D points using fisheye model</div>
</td>
</tr>
<tr id="i118" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#fisheye_undistortPoints-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.TermCriteria-">fisheye_undistortPoints</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distorted,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;undistorted,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;D,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;P,
                       <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria)</code>
<div class="block">Undistorts 2D points using fisheye model</div>
</td>
</tr>
<tr id="i119" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#getDefaultNewCameraMatrix-org.opencv.core.Mat-">getDefaultNewCameraMatrix</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix)</code>
<div class="block">Returns the default new camera matrix.</div>
</td>
</tr>
<tr id="i120" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#getDefaultNewCameraMatrix-org.opencv.core.Mat-org.opencv.core.Size-">getDefaultNewCameraMatrix</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                         <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;imgsize)</code>
<div class="block">Returns the default new camera matrix.</div>
</td>
</tr>
<tr id="i121" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#getDefaultNewCameraMatrix-org.opencv.core.Mat-org.opencv.core.Size-boolean-">getDefaultNewCameraMatrix</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                         <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;imgsize,
                         boolean&nbsp;centerPrincipalPoint)</code>
<div class="block">Returns the default new camera matrix.</div>
</td>
</tr>
<tr id="i122" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#getOptimalNewCameraMatrix-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-double-">getOptimalNewCameraMatrix</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                         <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;imageSize,
                         double&nbsp;alpha)</code>
<div class="block">Returns the new camera intrinsic matrix based on the free scaling parameter.</div>
</td>
</tr>
<tr id="i123" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#getOptimalNewCameraMatrix-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-double-org.opencv.core.Size-">getOptimalNewCameraMatrix</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                         <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;imageSize,
                         double&nbsp;alpha,
                         <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;newImgSize)</code>
<div class="block">Returns the new camera intrinsic matrix based on the free scaling parameter.</div>
</td>
</tr>
<tr id="i124" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#getOptimalNewCameraMatrix-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-double-org.opencv.core.Size-org.opencv.core.Rect-">getOptimalNewCameraMatrix</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                         <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;imageSize,
                         double&nbsp;alpha,
                         <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;newImgSize,
                         <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;validPixROI)</code>
<div class="block">Returns the new camera intrinsic matrix based on the free scaling parameter.</div>
</td>
</tr>
<tr id="i125" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#getOptimalNewCameraMatrix-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-double-org.opencv.core.Size-org.opencv.core.Rect-boolean-">getOptimalNewCameraMatrix</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                         <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;imageSize,
                         double&nbsp;alpha,
                         <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;newImgSize,
                         <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;validPixROI,
                         boolean&nbsp;centerPrincipalPoint)</code>
<div class="block">Returns the new camera intrinsic matrix based on the free scaling parameter.</div>
</td>
</tr>
<tr id="i126" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#initInverseRectificationMap-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-int-org.opencv.core.Mat-org.opencv.core.Mat-">initInverseRectificationMap</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;newCameraMatrix,
                           <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;size,
                           int&nbsp;m1type,
                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map1,
                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map2)</code>
<div class="block">Computes the projection and inverse-rectification transformation map.</div>
</td>
</tr>
<tr id="i127" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#initUndistortRectifyMap-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-int-org.opencv.core.Mat-org.opencv.core.Mat-">initUndistortRectifyMap</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;newCameraMatrix,
                       <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;size,
                       int&nbsp;m1type,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map1,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map2)</code>
<div class="block">Computes the undistortion and rectification transformation map.</div>
</td>
</tr>
<tr id="i128" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#loadMesh-java.lang.String-org.opencv.core.Mat-java.util.List-">loadMesh</a></span>(java.lang.String&nbsp;filename,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices,
        java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;indices)</code>
<div class="block">Loads a mesh from a file.</div>
</td>
</tr>
<tr id="i129" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#loadMesh-java.lang.String-org.opencv.core.Mat-java.util.List-org.opencv.core.Mat-">loadMesh</a></span>(java.lang.String&nbsp;filename,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices,
        java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;indices,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;normals)</code>
<div class="block">Loads a mesh from a file.</div>
</td>
</tr>
<tr id="i130" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#loadMesh-java.lang.String-org.opencv.core.Mat-java.util.List-org.opencv.core.Mat-org.opencv.core.Mat-">loadMesh</a></span>(java.lang.String&nbsp;filename,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices,
        java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;indices,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;normals,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;colors)</code>
<div class="block">Loads a mesh from a file.</div>
</td>
</tr>
<tr id="i131" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#loadMesh-java.lang.String-org.opencv.core.Mat-java.util.List-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">loadMesh</a></span>(java.lang.String&nbsp;filename,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices,
        java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;indices,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;normals,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;colors,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;texCoords)</code>
<div class="block">Loads a mesh from a file.</div>
</td>
</tr>
<tr id="i132" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#loadPointCloud-java.lang.String-org.opencv.core.Mat-">loadPointCloud</a></span>(java.lang.String&nbsp;filename,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices)</code>
<div class="block">Loads a point cloud from a file.</div>
</td>
</tr>
<tr id="i133" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#loadPointCloud-java.lang.String-org.opencv.core.Mat-org.opencv.core.Mat-">loadPointCloud</a></span>(java.lang.String&nbsp;filename,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;normals)</code>
<div class="block">Loads a point cloud from a file.</div>
</td>
</tr>
<tr id="i134" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#loadPointCloud-java.lang.String-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">loadPointCloud</a></span>(java.lang.String&nbsp;filename,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;normals,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rgb)</code>
<div class="block">Loads a point cloud from a file.</div>
</td>
</tr>
<tr id="i135" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#matMulDeriv-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">matMulDeriv</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;A,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;B,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dABdA,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dABdB)</code>
<div class="block">Computes partial derivatives of the matrix product for each multiplied matrix.</div>
</td>
</tr>
<tr id="i136" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#projectPoints-org.opencv.core.MatOfPoint3f-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.MatOfDouble-org.opencv.core.MatOfPoint2f-">projectPoints</a></span>(<a href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
             <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
             <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints)</code>
<div class="block">Projects 3D points to an image plane.</div>
</td>
</tr>
<tr id="i137" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#projectPoints-org.opencv.core.MatOfPoint3f-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.MatOfDouble-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-">projectPoints</a></span>(<a href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
             <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
             <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;jacobian)</code>
<div class="block">Projects 3D points to an image plane.</div>
</td>
</tr>
<tr id="i138" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#projectPoints-org.opencv.core.MatOfPoint3f-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.MatOfDouble-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-double-">projectPoints</a></span>(<a href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
             <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
             <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;jacobian,
             double&nbsp;aspectRatio)</code>
<div class="block">Projects 3D points to an image plane.</div>
</td>
</tr>
<tr id="i139" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#projectPointsSepJ-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">projectPointsSepJ</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdr,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdt)</code>&nbsp;</td>
</tr>
<tr id="i140" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#projectPointsSepJ-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">projectPointsSepJ</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdr,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdt,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdf)</code>&nbsp;</td>
</tr>
<tr id="i141" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#projectPointsSepJ-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">projectPointsSepJ</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdr,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdt,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdf,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdc)</code>&nbsp;</td>
</tr>
<tr id="i142" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#projectPointsSepJ-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">projectPointsSepJ</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdr,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdt,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdf,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdc,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdk)</code>&nbsp;</td>
</tr>
<tr id="i143" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#projectPointsSepJ-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">projectPointsSepJ</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdr,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdt,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdf,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdc,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdk,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdo)</code>&nbsp;</td>
</tr>
<tr id="i144" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#projectPointsSepJ-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-">projectPointsSepJ</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdr,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdt,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdf,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdc,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdk,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdo,
                 double&nbsp;aspectRatio)</code>&nbsp;</td>
</tr>
<tr id="i145" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#recoverPose-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">recoverPose</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;E,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;t)</code>&nbsp;</td>
</tr>
<tr id="i146" class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#recoverPose-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-">recoverPose</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;E,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;t,
           double&nbsp;focal)</code>&nbsp;</td>
</tr>
<tr id="i147" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#recoverPose-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-org.opencv.core.Point-">recoverPose</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;E,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;t,
           double&nbsp;focal,
           <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pp)</code>&nbsp;</td>
</tr>
<tr id="i148" class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#recoverPose-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-org.opencv.core.Point-org.opencv.core.Mat-">recoverPose</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;E,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;t,
           double&nbsp;focal,
           <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pp,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>&nbsp;</td>
</tr>
<tr id="i149" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#recoverPose-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">recoverPose</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;E,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;t)</code>
<div class="block">Recovers the relative camera rotation and the translation from an estimated essential
 matrix and the corresponding points in two images, using chirality check.</div>
</td>
</tr>
<tr id="i150" class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#recoverPose-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-">recoverPose</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;E,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;t,
           double&nbsp;distanceThresh)</code>&nbsp;</td>
</tr>
<tr id="i151" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#recoverPose-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-org.opencv.core.Mat-">recoverPose</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;E,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;t,
           double&nbsp;distanceThresh,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>&nbsp;</td>
</tr>
<tr id="i152" class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#recoverPose-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-org.opencv.core.Mat-org.opencv.core.Mat-">recoverPose</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;E,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;t,
           double&nbsp;distanceThresh,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;triangulatedPoints)</code>&nbsp;</td>
</tr>
<tr id="i153" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#recoverPose-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">recoverPose</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;E,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;t,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>
<div class="block">Recovers the relative camera rotation and the translation from an estimated essential
 matrix and the corresponding points in two images, using chirality check.</div>
</td>
</tr>
<tr id="i154" class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#recoverPose-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">recoverPose</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix2,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs2,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;E,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;t)</code>
<div class="block">Recovers the relative camera rotation and the translation from corresponding points in two images from two different cameras, using chirality check.</div>
</td>
</tr>
<tr id="i155" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#recoverPose-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">recoverPose</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix2,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs2,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;E,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;t,
           int&nbsp;method)</code>
<div class="block">Recovers the relative camera rotation and the translation from corresponding points in two images from two different cameras, using chirality check.</div>
</td>
</tr>
<tr id="i156" class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#recoverPose-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-double-">recoverPose</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix2,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs2,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;E,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;t,
           int&nbsp;method,
           double&nbsp;prob)</code>
<div class="block">Recovers the relative camera rotation and the translation from corresponding points in two images from two different cameras, using chirality check.</div>
</td>
</tr>
<tr id="i157" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#recoverPose-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-">recoverPose</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix2,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs2,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;E,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;t,
           int&nbsp;method,
           double&nbsp;prob,
           double&nbsp;threshold)</code>
<div class="block">Recovers the relative camera rotation and the translation from corresponding points in two images from two different cameras, using chirality check.</div>
</td>
</tr>
<tr id="i158" class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#recoverPose-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-org.opencv.core.Mat-">recoverPose</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix2,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs2,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;E,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;t,
           int&nbsp;method,
           double&nbsp;prob,
           double&nbsp;threshold,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>
<div class="block">Recovers the relative camera rotation and the translation from corresponding points in two images from two different cameras, using chirality check.</div>
</td>
</tr>
<tr id="i159" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#registerDepth-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-org.opencv.core.Mat-">registerDepth</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;unregisteredCameraMatrix,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;registeredCameraMatrix,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;registeredDistCoeffs,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Rt,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;unregisteredDepth,
             <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;outputImagePlaneSize,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;registeredDepth)</code>
<div class="block">Registers depth data to an external camera
 Registration is performed by creating a depth cloud, transforming the cloud by
 the rigid body transformation between the cameras, and then projecting the
 transformed points into the RGB camera.</div>
</td>
</tr>
<tr id="i160" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#registerDepth-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-org.opencv.core.Mat-boolean-">registerDepth</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;unregisteredCameraMatrix,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;registeredCameraMatrix,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;registeredDistCoeffs,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Rt,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;unregisteredDepth,
             <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;outputImagePlaneSize,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;registeredDepth,
             boolean&nbsp;depthDilation)</code>
<div class="block">Registers depth data to an external camera
 Registration is performed by creating a depth cloud, transforming the cloud by
 the rigid body transformation between the cameras, and then projecting the
 transformed points into the RGB camera.</div>
</td>
</tr>
<tr id="i161" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#rescaleDepth-org.opencv.core.Mat-int-org.opencv.core.Mat-">rescaleDepth</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;in,
            int&nbsp;type,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;out)</code>
<div class="block">If the input image is of type CV_16UC1 (like the Kinect one), the image is converted to floats, divided
 by depth_factor to get a depth in meters, and the values 0 are converted to std::numeric_limits&lt;float&gt;::quiet_NaN()
 Otherwise, the image is simply converted to floats</div>
</td>
</tr>
<tr id="i162" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#rescaleDepth-org.opencv.core.Mat-int-org.opencv.core.Mat-double-">rescaleDepth</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;in,
            int&nbsp;type,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;out,
            double&nbsp;depth_factor)</code>
<div class="block">If the input image is of type CV_16UC1 (like the Kinect one), the image is converted to floats, divided
 by depth_factor to get a depth in meters, and the values 0 are converted to std::numeric_limits&lt;float&gt;::quiet_NaN()
 Otherwise, the image is simply converted to floats</div>
</td>
</tr>
<tr id="i163" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#Rodrigues-org.opencv.core.Mat-org.opencv.core.Mat-">Rodrigues</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Converts a rotation matrix to a rotation vector or vice versa.</div>
</td>
</tr>
<tr id="i164" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#Rodrigues-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">Rodrigues</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;jacobian)</code>
<div class="block">Converts a rotation matrix to a rotation vector or vice versa.</div>
</td>
</tr>
<tr id="i165" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#RQDecomp3x3-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">RQDecomp3x3</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mtxR,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mtxQ)</code>
<div class="block">Computes an RQ decomposition of 3x3 matrices.</div>
</td>
</tr>
<tr id="i166" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#RQDecomp3x3-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">RQDecomp3x3</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mtxR,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mtxQ,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Qx)</code>
<div class="block">Computes an RQ decomposition of 3x3 matrices.</div>
</td>
</tr>
<tr id="i167" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#RQDecomp3x3-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">RQDecomp3x3</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mtxR,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mtxQ,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Qx,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Qy)</code>
<div class="block">Computes an RQ decomposition of 3x3 matrices.</div>
</td>
</tr>
<tr id="i168" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#RQDecomp3x3-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">RQDecomp3x3</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mtxR,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mtxQ,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Qx,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Qy,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Qz)</code>
<div class="block">Computes an RQ decomposition of 3x3 matrices.</div>
</td>
</tr>
<tr id="i169" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#sampsonDistance-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">sampsonDistance</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;pt1,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;pt2,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;F)</code>
<div class="block">Calculates the Sampson Distance between two points.</div>
</td>
</tr>
<tr id="i170" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#saveMesh-java.lang.String-org.opencv.core.Mat-java.util.List-">saveMesh</a></span>(java.lang.String&nbsp;filename,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices,
        java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;indices)</code>
<div class="block">Saves a mesh to a specified file.</div>
</td>
</tr>
<tr id="i171" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#saveMesh-java.lang.String-org.opencv.core.Mat-java.util.List-org.opencv.core.Mat-">saveMesh</a></span>(java.lang.String&nbsp;filename,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices,
        java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;indices,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;normals)</code>
<div class="block">Saves a mesh to a specified file.</div>
</td>
</tr>
<tr id="i172" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#saveMesh-java.lang.String-org.opencv.core.Mat-java.util.List-org.opencv.core.Mat-org.opencv.core.Mat-">saveMesh</a></span>(java.lang.String&nbsp;filename,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices,
        java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;indices,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;normals,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;colors)</code>
<div class="block">Saves a mesh to a specified file.</div>
</td>
</tr>
<tr id="i173" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#saveMesh-java.lang.String-org.opencv.core.Mat-java.util.List-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">saveMesh</a></span>(java.lang.String&nbsp;filename,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices,
        java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;indices,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;normals,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;colors,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;texCoords)</code>
<div class="block">Saves a mesh to a specified file.</div>
</td>
</tr>
<tr id="i174" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#savePointCloud-java.lang.String-org.opencv.core.Mat-">savePointCloud</a></span>(java.lang.String&nbsp;filename,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices)</code>
<div class="block">Saves a point cloud to a specified file.</div>
</td>
</tr>
<tr id="i175" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#savePointCloud-java.lang.String-org.opencv.core.Mat-org.opencv.core.Mat-">savePointCloud</a></span>(java.lang.String&nbsp;filename,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;normals)</code>
<div class="block">Saves a point cloud to a specified file.</div>
</td>
</tr>
<tr id="i176" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#savePointCloud-java.lang.String-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">savePointCloud</a></span>(java.lang.String&nbsp;filename,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;normals,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rgb)</code>
<div class="block">Saves a point cloud to a specified file.</div>
</td>
</tr>
<tr id="i177" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#solveP3P-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-java.util.List-java.util.List-int-">solveP3P</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
        java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;rvecs,
        java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;tvecs,
        int&nbsp;flags)</code>
<div class="block">Finds an object pose from 3 3D-2D point correspondences.</div>
</td>
</tr>
<tr id="i178" class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#solvePnP-org.opencv.core.MatOfPoint3f-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-org.opencv.core.MatOfDouble-org.opencv.core.Mat-org.opencv.core.Mat-">solvePnP</a></span>(<a href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
        <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
        <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec)</code>
<div class="block">Finds an object pose from 3D-2D point correspondences.</div>
</td>
</tr>
<tr id="i179" class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#solvePnP-org.opencv.core.MatOfPoint3f-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-org.opencv.core.MatOfDouble-org.opencv.core.Mat-org.opencv.core.Mat-boolean-">solvePnP</a></span>(<a href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
        <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
        <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
        boolean&nbsp;useExtrinsicGuess)</code>
<div class="block">Finds an object pose from 3D-2D point correspondences.</div>
</td>
</tr>
<tr id="i180" class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#solvePnP-org.opencv.core.MatOfPoint3f-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-org.opencv.core.MatOfDouble-org.opencv.core.Mat-org.opencv.core.Mat-boolean-int-">solvePnP</a></span>(<a href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
        <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
        <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
        boolean&nbsp;useExtrinsicGuess,
        int&nbsp;flags)</code>
<div class="block">Finds an object pose from 3D-2D point correspondences.</div>
</td>
</tr>
<tr id="i181" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#solvePnPGeneric-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-java.util.List-java.util.List-">solvePnPGeneric</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
               java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;rvecs,
               java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;tvecs)</code>
<div class="block">Finds an object pose from 3D-2D point correspondences.</div>
</td>
</tr>
<tr id="i182" class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#solvePnPGeneric-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-java.util.List-java.util.List-boolean-">solvePnPGeneric</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
               java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;rvecs,
               java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;tvecs,
               boolean&nbsp;useExtrinsicGuess)</code>
<div class="block">Finds an object pose from 3D-2D point correspondences.</div>
</td>
</tr>
<tr id="i183" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#solvePnPGeneric-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-java.util.List-java.util.List-boolean-int-">solvePnPGeneric</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
               java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;rvecs,
               java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;tvecs,
               boolean&nbsp;useExtrinsicGuess,
               int&nbsp;flags)</code>
<div class="block">Finds an object pose from 3D-2D point correspondences.</div>
</td>
</tr>
<tr id="i184" class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#solvePnPGeneric-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-java.util.List-java.util.List-boolean-int-org.opencv.core.Mat-">solvePnPGeneric</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
               java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;rvecs,
               java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;tvecs,
               boolean&nbsp;useExtrinsicGuess,
               int&nbsp;flags,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec)</code>
<div class="block">Finds an object pose from 3D-2D point correspondences.</div>
</td>
</tr>
<tr id="i185" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#solvePnPGeneric-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-java.util.List-java.util.List-boolean-int-org.opencv.core.Mat-org.opencv.core.Mat-">solvePnPGeneric</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
               java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;rvecs,
               java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;tvecs,
               boolean&nbsp;useExtrinsicGuess,
               int&nbsp;flags,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec)</code>
<div class="block">Finds an object pose from 3D-2D point correspondences.</div>
</td>
</tr>
<tr id="i186" class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#solvePnPGeneric-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-java.util.List-java.util.List-boolean-int-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">solvePnPGeneric</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
               java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;rvecs,
               java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;tvecs,
               boolean&nbsp;useExtrinsicGuess,
               int&nbsp;flags,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;reprojectionError)</code>
<div class="block">Finds an object pose from 3D-2D point correspondences.</div>
</td>
</tr>
<tr id="i187" class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#solvePnPRansac-org.opencv.core.MatOfPoint3f-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-org.opencv.core.MatOfDouble-org.opencv.core.Mat-org.opencv.core.Mat-">solvePnPRansac</a></span>(<a href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
              <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
              <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec)</code>
<div class="block">Finds an object pose from 3D-2D point correspondences using the RANSAC scheme.</div>
</td>
</tr>
<tr id="i188" class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#solvePnPRansac-org.opencv.core.MatOfPoint3f-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-org.opencv.core.MatOfDouble-org.opencv.core.Mat-org.opencv.core.Mat-boolean-">solvePnPRansac</a></span>(<a href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
              <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
              <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
              boolean&nbsp;useExtrinsicGuess)</code>
<div class="block">Finds an object pose from 3D-2D point correspondences using the RANSAC scheme.</div>
</td>
</tr>
<tr id="i189" class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#solvePnPRansac-org.opencv.core.MatOfPoint3f-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-org.opencv.core.MatOfDouble-org.opencv.core.Mat-org.opencv.core.Mat-boolean-int-">solvePnPRansac</a></span>(<a href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
              <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
              <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
              boolean&nbsp;useExtrinsicGuess,
              int&nbsp;iterationsCount)</code>
<div class="block">Finds an object pose from 3D-2D point correspondences using the RANSAC scheme.</div>
</td>
</tr>
<tr id="i190" class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#solvePnPRansac-org.opencv.core.MatOfPoint3f-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-org.opencv.core.MatOfDouble-org.opencv.core.Mat-org.opencv.core.Mat-boolean-int-float-">solvePnPRansac</a></span>(<a href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
              <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
              <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
              boolean&nbsp;useExtrinsicGuess,
              int&nbsp;iterationsCount,
              float&nbsp;reprojectionError)</code>
<div class="block">Finds an object pose from 3D-2D point correspondences using the RANSAC scheme.</div>
</td>
</tr>
<tr id="i191" class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#solvePnPRansac-org.opencv.core.MatOfPoint3f-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-org.opencv.core.MatOfDouble-org.opencv.core.Mat-org.opencv.core.Mat-boolean-int-float-double-">solvePnPRansac</a></span>(<a href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
              <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
              <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
              boolean&nbsp;useExtrinsicGuess,
              int&nbsp;iterationsCount,
              float&nbsp;reprojectionError,
              double&nbsp;confidence)</code>
<div class="block">Finds an object pose from 3D-2D point correspondences using the RANSAC scheme.</div>
</td>
</tr>
<tr id="i192" class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#solvePnPRansac-org.opencv.core.MatOfPoint3f-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-org.opencv.core.MatOfDouble-org.opencv.core.Mat-org.opencv.core.Mat-boolean-int-float-double-org.opencv.core.Mat-">solvePnPRansac</a></span>(<a href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
              <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
              <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
              boolean&nbsp;useExtrinsicGuess,
              int&nbsp;iterationsCount,
              float&nbsp;reprojectionError,
              double&nbsp;confidence,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers)</code>
<div class="block">Finds an object pose from 3D-2D point correspondences using the RANSAC scheme.</div>
</td>
</tr>
<tr id="i193" class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#solvePnPRansac-org.opencv.core.MatOfPoint3f-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-org.opencv.core.MatOfDouble-org.opencv.core.Mat-org.opencv.core.Mat-boolean-int-float-double-org.opencv.core.Mat-int-">solvePnPRansac</a></span>(<a href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
              <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
              <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
              boolean&nbsp;useExtrinsicGuess,
              int&nbsp;iterationsCount,
              float&nbsp;reprojectionError,
              double&nbsp;confidence,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers,
              int&nbsp;flags)</code>
<div class="block">Finds an object pose from 3D-2D point correspondences using the RANSAC scheme.</div>
</td>
</tr>
<tr id="i194" class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#solvePnPRansac-org.opencv.core.MatOfPoint3f-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-org.opencv.core.MatOfDouble-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">solvePnPRansac</a></span>(<a href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
              <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
              <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers)</code>&nbsp;</td>
</tr>
<tr id="i195" class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#solvePnPRansac-org.opencv.core.MatOfPoint3f-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-org.opencv.core.MatOfDouble-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.cv3d.UsacParams-">solvePnPRansac</a></span>(<a href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
              <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
              <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers,
              <a href="../../../org/opencv/cv3d/UsacParams.html" title="class in org.opencv.cv3d">UsacParams</a>&nbsp;params)</code>&nbsp;</td>
</tr>
<tr id="i196" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#solvePnPRefineLM-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">solvePnPRefineLM</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec)</code>
<div class="block">Refine a pose (the translation and the rotation that transform a 3D point expressed in the object coordinate frame
 to the camera coordinate frame) from a 3D-2D point correspondences and starting from an initial solution.</div>
</td>
</tr>
<tr id="i197" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#solvePnPRefineLM-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.TermCriteria-">solvePnPRefineLM</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria)</code>
<div class="block">Refine a pose (the translation and the rotation that transform a 3D point expressed in the object coordinate frame
 to the camera coordinate frame) from a 3D-2D point correspondences and starting from an initial solution.</div>
</td>
</tr>
<tr id="i198" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#solvePnPRefineVVS-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">solvePnPRefineVVS</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec)</code>
<div class="block">Refine a pose (the translation and the rotation that transform a 3D point expressed in the object coordinate frame
 to the camera coordinate frame) from a 3D-2D point correspondences and starting from an initial solution.</div>
</td>
</tr>
<tr id="i199" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#solvePnPRefineVVS-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.TermCriteria-">solvePnPRefineVVS</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                 <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria)</code>
<div class="block">Refine a pose (the translation and the rotation that transform a 3D point expressed in the object coordinate frame
 to the camera coordinate frame) from a 3D-2D point correspondences and starting from an initial solution.</div>
</td>
</tr>
<tr id="i200" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#solvePnPRefineVVS-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.TermCriteria-double-">solvePnPRefineVVS</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                 <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria,
                 double&nbsp;VVSlambda)</code>
<div class="block">Refine a pose (the translation and the rotation that transform a 3D point expressed in the object coordinate frame
 to the camera coordinate frame) from a 3D-2D point correspondences and starting from an initial solution.</div>
</td>
</tr>
<tr id="i201" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#triangleRasterize-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-double-double-">triangleRasterize</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;indices,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;colors,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;colorBuf,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;depthBuf,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;world2cam,
                 double&nbsp;fovY,
                 double&nbsp;zNear,
                 double&nbsp;zFar)</code>
<div class="block">Renders a set of triangles on a depth and color image

 Triangles can be drawn white (1.0, 1.0, 1.0), flat-shaded or with a color interpolation between vertices.</div>
</td>
</tr>
<tr id="i202" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#triangleRasterize-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-double-double-org.opencv.cv3d.TriangleRasterizeSettings-">triangleRasterize</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;indices,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;colors,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;colorBuf,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;depthBuf,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;world2cam,
                 double&nbsp;fovY,
                 double&nbsp;zNear,
                 double&nbsp;zFar,
                 <a href="../../../org/opencv/cv3d/TriangleRasterizeSettings.html" title="class in org.opencv.cv3d">TriangleRasterizeSettings</a>&nbsp;settings)</code>
<div class="block">Renders a set of triangles on a depth and color image

 Triangles can be drawn white (1.0, 1.0, 1.0), flat-shaded or with a color interpolation between vertices.</div>
</td>
</tr>
<tr id="i203" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#triangleRasterizeColor-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-double-double-">triangleRasterizeColor</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;indices,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;colors,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;colorBuf,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;world2cam,
                      double&nbsp;fovY,
                      double&nbsp;zNear,
                      double&nbsp;zFar)</code>
<div class="block">Overloaded version of triangleRasterize() with color-only rendering</div>
</td>
</tr>
<tr id="i204" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#triangleRasterizeColor-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-double-double-org.opencv.cv3d.TriangleRasterizeSettings-">triangleRasterizeColor</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;indices,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;colors,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;colorBuf,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;world2cam,
                      double&nbsp;fovY,
                      double&nbsp;zNear,
                      double&nbsp;zFar,
                      <a href="../../../org/opencv/cv3d/TriangleRasterizeSettings.html" title="class in org.opencv.cv3d">TriangleRasterizeSettings</a>&nbsp;settings)</code>
<div class="block">Overloaded version of triangleRasterize() with color-only rendering</div>
</td>
</tr>
<tr id="i205" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#triangleRasterizeDepth-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-double-double-">triangleRasterizeDepth</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;indices,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;depthBuf,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;world2cam,
                      double&nbsp;fovY,
                      double&nbsp;zNear,
                      double&nbsp;zFar)</code>
<div class="block">Overloaded version of triangleRasterize() with depth-only rendering</div>
</td>
</tr>
<tr id="i206" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#triangleRasterizeDepth-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-double-double-org.opencv.cv3d.TriangleRasterizeSettings-">triangleRasterizeDepth</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;indices,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;depthBuf,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;world2cam,
                      double&nbsp;fovY,
                      double&nbsp;zNear,
                      double&nbsp;zFar,
                      <a href="../../../org/opencv/cv3d/TriangleRasterizeSettings.html" title="class in org.opencv.cv3d">TriangleRasterizeSettings</a>&nbsp;settings)</code>
<div class="block">Overloaded version of triangleRasterize() with depth-only rendering</div>
</td>
</tr>
<tr id="i207" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#triangulatePoints-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">triangulatePoints</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;projMatr1,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;projMatr2,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;projPoints1,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;projPoints2,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points4D)</code>
<div class="block">This function reconstructs 3-dimensional points (in homogeneous coordinates) by using
 their observations with a stereo camera.</div>
</td>
</tr>
<tr id="i208" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#undistort-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">undistort</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs)</code>
<div class="block">Transforms an image to compensate for lens distortion.</div>
</td>
</tr>
<tr id="i209" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#undistort-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">undistort</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;newCameraMatrix)</code>
<div class="block">Transforms an image to compensate for lens distortion.</div>
</td>
</tr>
<tr id="i210" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#undistortImagePoints-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">undistortImagePoints</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs)</code>
<div class="block">Compute undistorted image points position</div>
</td>
</tr>
<tr id="i211" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#undistortImagePoints-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.TermCriteria-">undistortImagePoints</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                    <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;arg1)</code>
<div class="block">Compute undistorted image points position</div>
</td>
</tr>
<tr id="i212" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#undistortPoints-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-org.opencv.core.Mat-">undistortPoints</a></span>(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;src,
               <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;dst,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs)</code>
<div class="block">Computes the ideal point coordinates from the observed point coordinates.</div>
</td>
</tr>
<tr id="i213" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#undistortPoints-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">undistortPoints</a></span>(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;src,
               <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;dst,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R)</code>
<div class="block">Computes the ideal point coordinates from the observed point coordinates.</div>
</td>
</tr>
<tr id="i214" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#undistortPoints-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">undistortPoints</a></span>(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;src,
               <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;dst,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;P)</code>
<div class="block">Computes the ideal point coordinates from the observed point coordinates.</div>
</td>
</tr>
<tr id="i215" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#undistortPoints-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.TermCriteria-">undistortPoints</a></span>(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;src,
               <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;dst,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;P,
               <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria)</code>
<div class="block">Computes the ideal point coordinates from the observed point coordinates.</div>
</td>
</tr>
<tr id="i216" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#warpFrame-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">warpFrame</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;depth,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Rt,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix)</code>
<div class="block">Warps depth or RGB-D image by reprojecting it in 3d, applying Rt transformation
 and then projecting it back onto the image plane.</div>
</td>
</tr>
<tr id="i217" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#warpFrame-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">warpFrame</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;depth,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Rt,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;warpedDepth)</code>
<div class="block">Warps depth or RGB-D image by reprojecting it in 3d, applying Rt transformation
 and then projecting it back onto the image plane.</div>
</td>
</tr>
<tr id="i218" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#warpFrame-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">warpFrame</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;depth,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Rt,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;warpedDepth,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;warpedImage)</code>
<div class="block">Warps depth or RGB-D image by reprojecting it in 3d, applying Rt transformation
 and then projecting it back onto the image plane.</div>
</td>
</tr>
<tr id="i219" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/cv3d/Cv3d.html#warpFrame-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">warpFrame</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;depth,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Rt,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;warpedDepth,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;warpedImage,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;warpedMask)</code>
<div class="block">Warps depth or RGB-D image by reprojecting it in 3d, applying Rt transformation
 and then projecting it back onto the image plane.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="COV_POLISHER">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COV_POLISHER</h4>
<pre>public static final&nbsp;int COV_POLISHER</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.COV_POLISHER">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="FM_7POINT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FM_7POINT</h4>
<pre>public static final&nbsp;int FM_7POINT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.FM_7POINT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="FM_8POINT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FM_8POINT</h4>
<pre>public static final&nbsp;int FM_8POINT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.FM_8POINT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="FM_LMEDS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FM_LMEDS</h4>
<pre>public static final&nbsp;int FM_LMEDS</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.FM_LMEDS">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="FM_RANSAC">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FM_RANSAC</h4>
<pre>public static final&nbsp;int FM_RANSAC</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.FM_RANSAC">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="LMEDS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>LMEDS</h4>
<pre>public static final&nbsp;int LMEDS</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.LMEDS">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="LOCAL_OPTIM_GC">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>LOCAL_OPTIM_GC</h4>
<pre>public static final&nbsp;int LOCAL_OPTIM_GC</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.LOCAL_OPTIM_GC">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="LOCAL_OPTIM_INNER_AND_ITER_LO">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>LOCAL_OPTIM_INNER_AND_ITER_LO</h4>
<pre>public static final&nbsp;int LOCAL_OPTIM_INNER_AND_ITER_LO</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.LOCAL_OPTIM_INNER_AND_ITER_LO">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="LOCAL_OPTIM_INNER_LO">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>LOCAL_OPTIM_INNER_LO</h4>
<pre>public static final&nbsp;int LOCAL_OPTIM_INNER_LO</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.LOCAL_OPTIM_INNER_LO">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="LOCAL_OPTIM_NULL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>LOCAL_OPTIM_NULL</h4>
<pre>public static final&nbsp;int LOCAL_OPTIM_NULL</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.LOCAL_OPTIM_NULL">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="LOCAL_OPTIM_SIGMA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>LOCAL_OPTIM_SIGMA</h4>
<pre>public static final&nbsp;int LOCAL_OPTIM_SIGMA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.LOCAL_OPTIM_SIGMA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="LSQ_POLISHER">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>LSQ_POLISHER</h4>
<pre>public static final&nbsp;int LSQ_POLISHER</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.LSQ_POLISHER">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="MAGSAC">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MAGSAC</h4>
<pre>public static final&nbsp;int MAGSAC</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.MAGSAC">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="MatrixType_AUTO">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MatrixType_AUTO</h4>
<pre>public static final&nbsp;int MatrixType_AUTO</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.MatrixType_AUTO">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="MatrixType_DENSE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MatrixType_DENSE</h4>
<pre>public static final&nbsp;int MatrixType_DENSE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.MatrixType_DENSE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="MatrixType_SPARSE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MatrixType_SPARSE</h4>
<pre>public static final&nbsp;int MatrixType_SPARSE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.MatrixType_SPARSE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="N_PYRAMIDS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>N_PYRAMIDS</h4>
<pre>public static final&nbsp;int N_PYRAMIDS</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.N_PYRAMIDS">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="NEIGH_FLANN_KNN">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>NEIGH_FLANN_KNN</h4>
<pre>public static final&nbsp;int NEIGH_FLANN_KNN</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.NEIGH_FLANN_KNN">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="NEIGH_FLANN_RADIUS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>NEIGH_FLANN_RADIUS</h4>
<pre>public static final&nbsp;int NEIGH_FLANN_RADIUS</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.NEIGH_FLANN_RADIUS">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="NEIGH_GRID">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>NEIGH_GRID</h4>
<pre>public static final&nbsp;int NEIGH_GRID</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.NEIGH_GRID">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="NONE_POLISHER">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>NONE_POLISHER</h4>
<pre>public static final&nbsp;int NONE_POLISHER</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.NONE_POLISHER">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="OdometryAlgoType_COMMON">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>OdometryAlgoType_COMMON</h4>
<pre>public static final&nbsp;int OdometryAlgoType_COMMON</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.OdometryAlgoType_COMMON">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="OdometryAlgoType_FAST">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>OdometryAlgoType_FAST</h4>
<pre>public static final&nbsp;int OdometryAlgoType_FAST</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.OdometryAlgoType_FAST">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="OdometryType_DEPTH">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>OdometryType_DEPTH</h4>
<pre>public static final&nbsp;int OdometryType_DEPTH</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.OdometryType_DEPTH">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="OdometryType_RGB">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>OdometryType_RGB</h4>
<pre>public static final&nbsp;int OdometryType_RGB</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.OdometryType_RGB">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="OdometryType_RGB_DEPTH">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>OdometryType_RGB_DEPTH</h4>
<pre>public static final&nbsp;int OdometryType_RGB_DEPTH</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.OdometryType_RGB_DEPTH">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="PROJ_SPHERICAL_EQRECT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>PROJ_SPHERICAL_EQRECT</h4>
<pre>public static final&nbsp;int PROJ_SPHERICAL_EQRECT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.PROJ_SPHERICAL_EQRECT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="PROJ_SPHERICAL_ORTHO">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>PROJ_SPHERICAL_ORTHO</h4>
<pre>public static final&nbsp;int PROJ_SPHERICAL_ORTHO</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.PROJ_SPHERICAL_ORTHO">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="PYR_CLOUD">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>PYR_CLOUD</h4>
<pre>public static final&nbsp;int PYR_CLOUD</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.PYR_CLOUD">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="PYR_DEPTH">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>PYR_DEPTH</h4>
<pre>public static final&nbsp;int PYR_DEPTH</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.PYR_DEPTH">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="PYR_DIX">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>PYR_DIX</h4>
<pre>public static final&nbsp;int PYR_DIX</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.PYR_DIX">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="PYR_DIY">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>PYR_DIY</h4>
<pre>public static final&nbsp;int PYR_DIY</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.PYR_DIY">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="PYR_IMAGE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>PYR_IMAGE</h4>
<pre>public static final&nbsp;int PYR_IMAGE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.PYR_IMAGE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="PYR_MASK">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>PYR_MASK</h4>
<pre>public static final&nbsp;int PYR_MASK</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.PYR_MASK">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="PYR_NORM">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>PYR_NORM</h4>
<pre>public static final&nbsp;int PYR_NORM</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.PYR_NORM">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="PYR_NORMMASK">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>PYR_NORMMASK</h4>
<pre>public static final&nbsp;int PYR_NORMMASK</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.PYR_NORMMASK">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="PYR_TEXMASK">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>PYR_TEXMASK</h4>
<pre>public static final&nbsp;int PYR_TEXMASK</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.PYR_TEXMASK">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="RANSAC">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RANSAC</h4>
<pre>public static final&nbsp;int RANSAC</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.RANSAC">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="RASTERIZE_COMPAT_DISABLED">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RASTERIZE_COMPAT_DISABLED</h4>
<pre>public static final&nbsp;int RASTERIZE_COMPAT_DISABLED</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.RASTERIZE_COMPAT_DISABLED">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="RASTERIZE_COMPAT_INVDEPTH">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RASTERIZE_COMPAT_INVDEPTH</h4>
<pre>public static final&nbsp;int RASTERIZE_COMPAT_INVDEPTH</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.RASTERIZE_COMPAT_INVDEPTH">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="RASTERIZE_CULLING_CCW">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RASTERIZE_CULLING_CCW</h4>
<pre>public static final&nbsp;int RASTERIZE_CULLING_CCW</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.RASTERIZE_CULLING_CCW">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="RASTERIZE_CULLING_CW">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RASTERIZE_CULLING_CW</h4>
<pre>public static final&nbsp;int RASTERIZE_CULLING_CW</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.RASTERIZE_CULLING_CW">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="RASTERIZE_CULLING_NONE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RASTERIZE_CULLING_NONE</h4>
<pre>public static final&nbsp;int RASTERIZE_CULLING_NONE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.RASTERIZE_CULLING_NONE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="RASTERIZE_SHADING_FLAT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RASTERIZE_SHADING_FLAT</h4>
<pre>public static final&nbsp;int RASTERIZE_SHADING_FLAT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.RASTERIZE_SHADING_FLAT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="RASTERIZE_SHADING_SHADED">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RASTERIZE_SHADING_SHADED</h4>
<pre>public static final&nbsp;int RASTERIZE_SHADING_SHADED</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.RASTERIZE_SHADING_SHADED">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="RASTERIZE_SHADING_WHITE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RASTERIZE_SHADING_WHITE</h4>
<pre>public static final&nbsp;int RASTERIZE_SHADING_WHITE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.RASTERIZE_SHADING_WHITE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="RGBD_PLANE_METHOD_DEFAULT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RGBD_PLANE_METHOD_DEFAULT</h4>
<pre>public static final&nbsp;int RGBD_PLANE_METHOD_DEFAULT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.RGBD_PLANE_METHOD_DEFAULT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="RHO">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RHO</h4>
<pre>public static final&nbsp;int RHO</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.RHO">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="SAC_METHOD_RANSAC">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SAC_METHOD_RANSAC</h4>
<pre>public static final&nbsp;int SAC_METHOD_RANSAC</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.SAC_METHOD_RANSAC">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="SAC_MODEL_PLANE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SAC_MODEL_PLANE</h4>
<pre>public static final&nbsp;int SAC_MODEL_PLANE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.SAC_MODEL_PLANE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="SAC_MODEL_SPHERE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SAC_MODEL_SPHERE</h4>
<pre>public static final&nbsp;int SAC_MODEL_SPHERE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.SAC_MODEL_SPHERE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="SAMPLING_NAPSAC">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SAMPLING_NAPSAC</h4>
<pre>public static final&nbsp;int SAMPLING_NAPSAC</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.SAMPLING_NAPSAC">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="SAMPLING_PROGRESSIVE_NAPSAC">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SAMPLING_PROGRESSIVE_NAPSAC</h4>
<pre>public static final&nbsp;int SAMPLING_PROGRESSIVE_NAPSAC</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.SAMPLING_PROGRESSIVE_NAPSAC">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="SAMPLING_PROSAC">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SAMPLING_PROSAC</h4>
<pre>public static final&nbsp;int SAMPLING_PROSAC</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.SAMPLING_PROSAC">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="SAMPLING_UNIFORM">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SAMPLING_UNIFORM</h4>
<pre>public static final&nbsp;int SAMPLING_UNIFORM</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.SAMPLING_UNIFORM">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="SCORE_METHOD_LMEDS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SCORE_METHOD_LMEDS</h4>
<pre>public static final&nbsp;int SCORE_METHOD_LMEDS</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.SCORE_METHOD_LMEDS">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="SCORE_METHOD_MAGSAC">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SCORE_METHOD_MAGSAC</h4>
<pre>public static final&nbsp;int SCORE_METHOD_MAGSAC</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.SCORE_METHOD_MAGSAC">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="SCORE_METHOD_MSAC">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SCORE_METHOD_MSAC</h4>
<pre>public static final&nbsp;int SCORE_METHOD_MSAC</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.SCORE_METHOD_MSAC">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="SCORE_METHOD_RANSAC">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SCORE_METHOD_RANSAC</h4>
<pre>public static final&nbsp;int SCORE_METHOD_RANSAC</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.SCORE_METHOD_RANSAC">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="SOLVEPNP_AP3P">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SOLVEPNP_AP3P</h4>
<pre>public static final&nbsp;int SOLVEPNP_AP3P</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.SOLVEPNP_AP3P">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="SOLVEPNP_DLS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SOLVEPNP_DLS</h4>
<pre>public static final&nbsp;int SOLVEPNP_DLS</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.SOLVEPNP_DLS">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="SOLVEPNP_EPNP">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SOLVEPNP_EPNP</h4>
<pre>public static final&nbsp;int SOLVEPNP_EPNP</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.SOLVEPNP_EPNP">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="SOLVEPNP_IPPE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SOLVEPNP_IPPE</h4>
<pre>public static final&nbsp;int SOLVEPNP_IPPE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.SOLVEPNP_IPPE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="SOLVEPNP_IPPE_SQUARE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SOLVEPNP_IPPE_SQUARE</h4>
<pre>public static final&nbsp;int SOLVEPNP_IPPE_SQUARE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.SOLVEPNP_IPPE_SQUARE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="SOLVEPNP_ITERATIVE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SOLVEPNP_ITERATIVE</h4>
<pre>public static final&nbsp;int SOLVEPNP_ITERATIVE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.SOLVEPNP_ITERATIVE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="SOLVEPNP_MAX_COUNT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SOLVEPNP_MAX_COUNT</h4>
<pre>public static final&nbsp;int SOLVEPNP_MAX_COUNT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.SOLVEPNP_MAX_COUNT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="SOLVEPNP_P3P">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SOLVEPNP_P3P</h4>
<pre>public static final&nbsp;int SOLVEPNP_P3P</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.SOLVEPNP_P3P">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="SOLVEPNP_SQPNP">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SOLVEPNP_SQPNP</h4>
<pre>public static final&nbsp;int SOLVEPNP_SQPNP</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.SOLVEPNP_SQPNP">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="SOLVEPNP_UPNP">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SOLVEPNP_UPNP</h4>
<pre>public static final&nbsp;int SOLVEPNP_UPNP</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.SOLVEPNP_UPNP">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="USAC_ACCURATE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>USAC_ACCURATE</h4>
<pre>public static final&nbsp;int USAC_ACCURATE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.USAC_ACCURATE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="USAC_DEFAULT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>USAC_DEFAULT</h4>
<pre>public static final&nbsp;int USAC_DEFAULT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.USAC_DEFAULT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="USAC_FAST">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>USAC_FAST</h4>
<pre>public static final&nbsp;int USAC_FAST</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.USAC_FAST">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="USAC_FM_8PTS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>USAC_FM_8PTS</h4>
<pre>public static final&nbsp;int USAC_FM_8PTS</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.USAC_FM_8PTS">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="USAC_MAGSAC">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>USAC_MAGSAC</h4>
<pre>public static final&nbsp;int USAC_MAGSAC</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.USAC_MAGSAC">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="USAC_PARALLEL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>USAC_PARALLEL</h4>
<pre>public static final&nbsp;int USAC_PARALLEL</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.USAC_PARALLEL">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="USAC_PROSAC">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>USAC_PROSAC</h4>
<pre>public static final&nbsp;int USAC_PROSAC</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.USAC_PROSAC">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="VariableType_LINEAR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>VariableType_LINEAR</h4>
<pre>public static final&nbsp;int VariableType_LINEAR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.VariableType_LINEAR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="VariableType_SE3">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>VariableType_SE3</h4>
<pre>public static final&nbsp;int VariableType_SE3</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.VariableType_SE3">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="VariableType_SO3">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>VariableType_SO3</h4>
<pre>public static final&nbsp;int VariableType_SO3</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.VariableType_SO3">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="VolumeType_ColorTSDF">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>VolumeType_ColorTSDF</h4>
<pre>public static final&nbsp;int VolumeType_ColorTSDF</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.VolumeType_ColorTSDF">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="VolumeType_HashTSDF">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>VolumeType_HashTSDF</h4>
<pre>public static final&nbsp;int VolumeType_HashTSDF</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.VolumeType_HashTSDF">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="VolumeType_TSDF">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>VolumeType_TSDF</h4>
<pre>public static final&nbsp;int VolumeType_TSDF</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.cv3d.Cv3d.VolumeType_TSDF">Constant Field Values</a></dd>
</dl>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="Cv3d--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Cv3d</h4>
<pre>public&nbsp;Cv3d()</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="composeRT-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>composeRT</h4>
<pre>public static&nbsp;void&nbsp;composeRT(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec1,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec1,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec2,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec2,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec3,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec3)</pre>
<div class="block">Combines two rotation-and-shift transformations.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>rvec1</code> - First rotation vector.</dd>
<dd><code>tvec1</code> - First translation vector.</dd>
<dd><code>rvec2</code> - Second rotation vector.</dd>
<dd><code>tvec2</code> - Second translation vector.</dd>
<dd><code>rvec3</code> - Output rotation vector of the superposition.</dd>
<dd><code>tvec3</code> - Output translation vector of the superposition.

 The functions compute:

 \(\begin{array}{l} \texttt{rvec3} =  \mathrm{rodrigues} ^{-1} \left ( \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \mathrm{rodrigues} ( \texttt{rvec1} ) \right )  \\ \texttt{tvec3} =  \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \texttt{tvec1} +  \texttt{tvec2} \end{array} ,\)

 where \(\mathrm{rodrigues}\) denotes a rotation vector to a rotation matrix transformation, and
 \(\mathrm{rodrigues}^{-1}\) denotes the inverse transformation. See #Rodrigues for details.

 Also, the functions can compute the derivatives of the output vectors with regards to the input
 vectors (see #matMulDeriv ). The functions are used inside #stereoCalibrate but can also be used in
 your own code where Levenberg-Marquardt or another gradient-based solver is used to optimize a
 function that contains a matrix multiplication.</dd>
</dl>
</li>
</ul>
<a name="composeRT-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>composeRT</h4>
<pre>public static&nbsp;void&nbsp;composeRT(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec1,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec1,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec2,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec2,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec3,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec3,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dr1)</pre>
<div class="block">Combines two rotation-and-shift transformations.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>rvec1</code> - First rotation vector.</dd>
<dd><code>tvec1</code> - First translation vector.</dd>
<dd><code>rvec2</code> - Second rotation vector.</dd>
<dd><code>tvec2</code> - Second translation vector.</dd>
<dd><code>rvec3</code> - Output rotation vector of the superposition.</dd>
<dd><code>tvec3</code> - Output translation vector of the superposition.</dd>
<dd><code>dr3dr1</code> - Optional output derivative of rvec3 with regard to rvec1

 The functions compute:

 \(\begin{array}{l} \texttt{rvec3} =  \mathrm{rodrigues} ^{-1} \left ( \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \mathrm{rodrigues} ( \texttt{rvec1} ) \right )  \\ \texttt{tvec3} =  \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \texttt{tvec1} +  \texttt{tvec2} \end{array} ,\)

 where \(\mathrm{rodrigues}\) denotes a rotation vector to a rotation matrix transformation, and
 \(\mathrm{rodrigues}^{-1}\) denotes the inverse transformation. See #Rodrigues for details.

 Also, the functions can compute the derivatives of the output vectors with regards to the input
 vectors (see #matMulDeriv ). The functions are used inside #stereoCalibrate but can also be used in
 your own code where Levenberg-Marquardt or another gradient-based solver is used to optimize a
 function that contains a matrix multiplication.</dd>
</dl>
</li>
</ul>
<a name="composeRT-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>composeRT</h4>
<pre>public static&nbsp;void&nbsp;composeRT(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec1,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec1,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec2,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec2,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec3,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec3,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dr1,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dt1)</pre>
<div class="block">Combines two rotation-and-shift transformations.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>rvec1</code> - First rotation vector.</dd>
<dd><code>tvec1</code> - First translation vector.</dd>
<dd><code>rvec2</code> - Second rotation vector.</dd>
<dd><code>tvec2</code> - Second translation vector.</dd>
<dd><code>rvec3</code> - Output rotation vector of the superposition.</dd>
<dd><code>tvec3</code> - Output translation vector of the superposition.</dd>
<dd><code>dr3dr1</code> - Optional output derivative of rvec3 with regard to rvec1</dd>
<dd><code>dr3dt1</code> - Optional output derivative of rvec3 with regard to tvec1

 The functions compute:

 \(\begin{array}{l} \texttt{rvec3} =  \mathrm{rodrigues} ^{-1} \left ( \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \mathrm{rodrigues} ( \texttt{rvec1} ) \right )  \\ \texttt{tvec3} =  \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \texttt{tvec1} +  \texttt{tvec2} \end{array} ,\)

 where \(\mathrm{rodrigues}\) denotes a rotation vector to a rotation matrix transformation, and
 \(\mathrm{rodrigues}^{-1}\) denotes the inverse transformation. See #Rodrigues for details.

 Also, the functions can compute the derivatives of the output vectors with regards to the input
 vectors (see #matMulDeriv ). The functions are used inside #stereoCalibrate but can also be used in
 your own code where Levenberg-Marquardt or another gradient-based solver is used to optimize a
 function that contains a matrix multiplication.</dd>
</dl>
</li>
</ul>
<a name="composeRT-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>composeRT</h4>
<pre>public static&nbsp;void&nbsp;composeRT(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec1,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec1,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec2,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec2,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec3,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec3,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dr1,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dt1,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dr2)</pre>
<div class="block">Combines two rotation-and-shift transformations.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>rvec1</code> - First rotation vector.</dd>
<dd><code>tvec1</code> - First translation vector.</dd>
<dd><code>rvec2</code> - Second rotation vector.</dd>
<dd><code>tvec2</code> - Second translation vector.</dd>
<dd><code>rvec3</code> - Output rotation vector of the superposition.</dd>
<dd><code>tvec3</code> - Output translation vector of the superposition.</dd>
<dd><code>dr3dr1</code> - Optional output derivative of rvec3 with regard to rvec1</dd>
<dd><code>dr3dt1</code> - Optional output derivative of rvec3 with regard to tvec1</dd>
<dd><code>dr3dr2</code> - Optional output derivative of rvec3 with regard to rvec2

 The functions compute:

 \(\begin{array}{l} \texttt{rvec3} =  \mathrm{rodrigues} ^{-1} \left ( \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \mathrm{rodrigues} ( \texttt{rvec1} ) \right )  \\ \texttt{tvec3} =  \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \texttt{tvec1} +  \texttt{tvec2} \end{array} ,\)

 where \(\mathrm{rodrigues}\) denotes a rotation vector to a rotation matrix transformation, and
 \(\mathrm{rodrigues}^{-1}\) denotes the inverse transformation. See #Rodrigues for details.

 Also, the functions can compute the derivatives of the output vectors with regards to the input
 vectors (see #matMulDeriv ). The functions are used inside #stereoCalibrate but can also be used in
 your own code where Levenberg-Marquardt or another gradient-based solver is used to optimize a
 function that contains a matrix multiplication.</dd>
</dl>
</li>
</ul>
<a name="composeRT-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>composeRT</h4>
<pre>public static&nbsp;void&nbsp;composeRT(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec1,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec1,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec2,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec2,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec3,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec3,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dr1,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dt1,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dr2,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dt2)</pre>
<div class="block">Combines two rotation-and-shift transformations.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>rvec1</code> - First rotation vector.</dd>
<dd><code>tvec1</code> - First translation vector.</dd>
<dd><code>rvec2</code> - Second rotation vector.</dd>
<dd><code>tvec2</code> - Second translation vector.</dd>
<dd><code>rvec3</code> - Output rotation vector of the superposition.</dd>
<dd><code>tvec3</code> - Output translation vector of the superposition.</dd>
<dd><code>dr3dr1</code> - Optional output derivative of rvec3 with regard to rvec1</dd>
<dd><code>dr3dt1</code> - Optional output derivative of rvec3 with regard to tvec1</dd>
<dd><code>dr3dr2</code> - Optional output derivative of rvec3 with regard to rvec2</dd>
<dd><code>dr3dt2</code> - Optional output derivative of rvec3 with regard to tvec2

 The functions compute:

 \(\begin{array}{l} \texttt{rvec3} =  \mathrm{rodrigues} ^{-1} \left ( \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \mathrm{rodrigues} ( \texttt{rvec1} ) \right )  \\ \texttt{tvec3} =  \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \texttt{tvec1} +  \texttt{tvec2} \end{array} ,\)

 where \(\mathrm{rodrigues}\) denotes a rotation vector to a rotation matrix transformation, and
 \(\mathrm{rodrigues}^{-1}\) denotes the inverse transformation. See #Rodrigues for details.

 Also, the functions can compute the derivatives of the output vectors with regards to the input
 vectors (see #matMulDeriv ). The functions are used inside #stereoCalibrate but can also be used in
 your own code where Levenberg-Marquardt or another gradient-based solver is used to optimize a
 function that contains a matrix multiplication.</dd>
</dl>
</li>
</ul>
<a name="composeRT-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>composeRT</h4>
<pre>public static&nbsp;void&nbsp;composeRT(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec1,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec1,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec2,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec2,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec3,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec3,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dr1,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dt1,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dr2,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dt2,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dt3dr1)</pre>
<div class="block">Combines two rotation-and-shift transformations.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>rvec1</code> - First rotation vector.</dd>
<dd><code>tvec1</code> - First translation vector.</dd>
<dd><code>rvec2</code> - Second rotation vector.</dd>
<dd><code>tvec2</code> - Second translation vector.</dd>
<dd><code>rvec3</code> - Output rotation vector of the superposition.</dd>
<dd><code>tvec3</code> - Output translation vector of the superposition.</dd>
<dd><code>dr3dr1</code> - Optional output derivative of rvec3 with regard to rvec1</dd>
<dd><code>dr3dt1</code> - Optional output derivative of rvec3 with regard to tvec1</dd>
<dd><code>dr3dr2</code> - Optional output derivative of rvec3 with regard to rvec2</dd>
<dd><code>dr3dt2</code> - Optional output derivative of rvec3 with regard to tvec2</dd>
<dd><code>dt3dr1</code> - Optional output derivative of tvec3 with regard to rvec1

 The functions compute:

 \(\begin{array}{l} \texttt{rvec3} =  \mathrm{rodrigues} ^{-1} \left ( \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \mathrm{rodrigues} ( \texttt{rvec1} ) \right )  \\ \texttt{tvec3} =  \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \texttt{tvec1} +  \texttt{tvec2} \end{array} ,\)

 where \(\mathrm{rodrigues}\) denotes a rotation vector to a rotation matrix transformation, and
 \(\mathrm{rodrigues}^{-1}\) denotes the inverse transformation. See #Rodrigues for details.

 Also, the functions can compute the derivatives of the output vectors with regards to the input
 vectors (see #matMulDeriv ). The functions are used inside #stereoCalibrate but can also be used in
 your own code where Levenberg-Marquardt or another gradient-based solver is used to optimize a
 function that contains a matrix multiplication.</dd>
</dl>
</li>
</ul>
<a name="composeRT-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>composeRT</h4>
<pre>public static&nbsp;void&nbsp;composeRT(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec1,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec1,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec2,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec2,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec3,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec3,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dr1,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dt1,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dr2,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dt2,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dt3dr1,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dt3dt1)</pre>
<div class="block">Combines two rotation-and-shift transformations.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>rvec1</code> - First rotation vector.</dd>
<dd><code>tvec1</code> - First translation vector.</dd>
<dd><code>rvec2</code> - Second rotation vector.</dd>
<dd><code>tvec2</code> - Second translation vector.</dd>
<dd><code>rvec3</code> - Output rotation vector of the superposition.</dd>
<dd><code>tvec3</code> - Output translation vector of the superposition.</dd>
<dd><code>dr3dr1</code> - Optional output derivative of rvec3 with regard to rvec1</dd>
<dd><code>dr3dt1</code> - Optional output derivative of rvec3 with regard to tvec1</dd>
<dd><code>dr3dr2</code> - Optional output derivative of rvec3 with regard to rvec2</dd>
<dd><code>dr3dt2</code> - Optional output derivative of rvec3 with regard to tvec2</dd>
<dd><code>dt3dr1</code> - Optional output derivative of tvec3 with regard to rvec1</dd>
<dd><code>dt3dt1</code> - Optional output derivative of tvec3 with regard to tvec1

 The functions compute:

 \(\begin{array}{l} \texttt{rvec3} =  \mathrm{rodrigues} ^{-1} \left ( \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \mathrm{rodrigues} ( \texttt{rvec1} ) \right )  \\ \texttt{tvec3} =  \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \texttt{tvec1} +  \texttt{tvec2} \end{array} ,\)

 where \(\mathrm{rodrigues}\) denotes a rotation vector to a rotation matrix transformation, and
 \(\mathrm{rodrigues}^{-1}\) denotes the inverse transformation. See #Rodrigues for details.

 Also, the functions can compute the derivatives of the output vectors with regards to the input
 vectors (see #matMulDeriv ). The functions are used inside #stereoCalibrate but can also be used in
 your own code where Levenberg-Marquardt or another gradient-based solver is used to optimize a
 function that contains a matrix multiplication.</dd>
</dl>
</li>
</ul>
<a name="composeRT-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>composeRT</h4>
<pre>public static&nbsp;void&nbsp;composeRT(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec1,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec1,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec2,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec2,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec3,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec3,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dr1,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dt1,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dr2,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dt2,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dt3dr1,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dt3dt1,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dt3dr2)</pre>
<div class="block">Combines two rotation-and-shift transformations.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>rvec1</code> - First rotation vector.</dd>
<dd><code>tvec1</code> - First translation vector.</dd>
<dd><code>rvec2</code> - Second rotation vector.</dd>
<dd><code>tvec2</code> - Second translation vector.</dd>
<dd><code>rvec3</code> - Output rotation vector of the superposition.</dd>
<dd><code>tvec3</code> - Output translation vector of the superposition.</dd>
<dd><code>dr3dr1</code> - Optional output derivative of rvec3 with regard to rvec1</dd>
<dd><code>dr3dt1</code> - Optional output derivative of rvec3 with regard to tvec1</dd>
<dd><code>dr3dr2</code> - Optional output derivative of rvec3 with regard to rvec2</dd>
<dd><code>dr3dt2</code> - Optional output derivative of rvec3 with regard to tvec2</dd>
<dd><code>dt3dr1</code> - Optional output derivative of tvec3 with regard to rvec1</dd>
<dd><code>dt3dt1</code> - Optional output derivative of tvec3 with regard to tvec1</dd>
<dd><code>dt3dr2</code> - Optional output derivative of tvec3 with regard to rvec2

 The functions compute:

 \(\begin{array}{l} \texttt{rvec3} =  \mathrm{rodrigues} ^{-1} \left ( \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \mathrm{rodrigues} ( \texttt{rvec1} ) \right )  \\ \texttt{tvec3} =  \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \texttt{tvec1} +  \texttt{tvec2} \end{array} ,\)

 where \(\mathrm{rodrigues}\) denotes a rotation vector to a rotation matrix transformation, and
 \(\mathrm{rodrigues}^{-1}\) denotes the inverse transformation. See #Rodrigues for details.

 Also, the functions can compute the derivatives of the output vectors with regards to the input
 vectors (see #matMulDeriv ). The functions are used inside #stereoCalibrate but can also be used in
 your own code where Levenberg-Marquardt or another gradient-based solver is used to optimize a
 function that contains a matrix multiplication.</dd>
</dl>
</li>
</ul>
<a name="composeRT-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>composeRT</h4>
<pre>public static&nbsp;void&nbsp;composeRT(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec1,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec1,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec2,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec2,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec3,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec3,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dr1,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dt1,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dr2,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dt2,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dt3dr1,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dt3dt1,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dt3dr2,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dt3dt2)</pre>
<div class="block">Combines two rotation-and-shift transformations.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>rvec1</code> - First rotation vector.</dd>
<dd><code>tvec1</code> - First translation vector.</dd>
<dd><code>rvec2</code> - Second rotation vector.</dd>
<dd><code>tvec2</code> - Second translation vector.</dd>
<dd><code>rvec3</code> - Output rotation vector of the superposition.</dd>
<dd><code>tvec3</code> - Output translation vector of the superposition.</dd>
<dd><code>dr3dr1</code> - Optional output derivative of rvec3 with regard to rvec1</dd>
<dd><code>dr3dt1</code> - Optional output derivative of rvec3 with regard to tvec1</dd>
<dd><code>dr3dr2</code> - Optional output derivative of rvec3 with regard to rvec2</dd>
<dd><code>dr3dt2</code> - Optional output derivative of rvec3 with regard to tvec2</dd>
<dd><code>dt3dr1</code> - Optional output derivative of tvec3 with regard to rvec1</dd>
<dd><code>dt3dt1</code> - Optional output derivative of tvec3 with regard to tvec1</dd>
<dd><code>dt3dr2</code> - Optional output derivative of tvec3 with regard to rvec2</dd>
<dd><code>dt3dt2</code> - Optional output derivative of tvec3 with regard to tvec2

 The functions compute:

 \(\begin{array}{l} \texttt{rvec3} =  \mathrm{rodrigues} ^{-1} \left ( \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \mathrm{rodrigues} ( \texttt{rvec1} ) \right )  \\ \texttt{tvec3} =  \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \texttt{tvec1} +  \texttt{tvec2} \end{array} ,\)

 where \(\mathrm{rodrigues}\) denotes a rotation vector to a rotation matrix transformation, and
 \(\mathrm{rodrigues}^{-1}\) denotes the inverse transformation. See #Rodrigues for details.

 Also, the functions can compute the derivatives of the output vectors with regards to the input
 vectors (see #matMulDeriv ). The functions are used inside #stereoCalibrate but can also be used in
 your own code where Levenberg-Marquardt or another gradient-based solver is used to optimize a
 function that contains a matrix multiplication.</dd>
</dl>
</li>
</ul>
<a name="computeCorrespondEpilines-org.opencv.core.Mat-int-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeCorrespondEpilines</h4>
<pre>public static&nbsp;void&nbsp;computeCorrespondEpilines(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points,
                                             int&nbsp;whichImage,
                                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;F,
                                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines)</pre>
<div class="block">For points in an image of a stereo pair, computes the corresponding epilines in the other image.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points</code> - Input points. \(N \times 1\) or \(1 \times N\) matrix of type CV_32FC2 or
 vector&lt;Point2f&gt; .</dd>
<dd><code>whichImage</code> - Index of the image (1 or 2) that contains the points .</dd>
<dd><code>F</code> - Fundamental matrix that can be estimated using #findFundamentalMat or #stereoRectify .</dd>
<dd><code>lines</code> - Output vector of the epipolar lines corresponding to the points in the other image.
 Each line \(ax + by + c=0\) is encoded by 3 numbers \((a, b, c)\) .

 For every point in one of the two images of a stereo pair, the function finds the equation of the
 corresponding epipolar line in the other image.

 From the fundamental matrix definition (see #findFundamentalMat ), line \(l^{(2)}_i\) in the second
 image for the point \(p^{(1)}_i\) in the first image (when whichImage=1 ) is computed as:

 \(l^{(2)}_i = F p^{(1)}_i\)

 And vice versa, when whichImage=2, \(l^{(1)}_i\) is computed from \(p^{(2)}_i\) as:

 \(l^{(1)}_i = F^T p^{(2)}_i\)

 Line coefficients are defined up to a scale. They are normalized so that \(a_i^2+b_i^2=1\) .</dd>
</dl>
</li>
</ul>
<a name="convertPointsFromHomogeneous-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>convertPointsFromHomogeneous</h4>
<pre>public static&nbsp;void&nbsp;convertPointsFromHomogeneous(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Converts points from homogeneous to Euclidean space.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Input vector of N-dimensional points.</dd>
<dd><code>dst</code> - Output vector of N-1-dimensional points.
     If it's -1, then it's set automatically to CV_32F or CV_64F, depending on the input depth.

 The function converts points homogeneous to Euclidean space using perspective projection. That is,
 each point (x1, x2, ... x(n-1), xn) is converted to (x1/xn, x2/xn, ..., x(n-1)/xn). When xn=0, the
 output point coordinates will be (0,0,0,...).</dd>
</dl>
</li>
</ul>
<a name="convertPointsFromHomogeneous-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>convertPointsFromHomogeneous</h4>
<pre>public static&nbsp;void&nbsp;convertPointsFromHomogeneous(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                                int&nbsp;dtype)</pre>
<div class="block">Converts points from homogeneous to Euclidean space.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Input vector of N-dimensional points.</dd>
<dd><code>dst</code> - Output vector of N-1-dimensional points.</dd>
<dd><code>dtype</code> - The desired output array depth (either CV_32F or CV_64F are currently supported).
     If it's -1, then it's set automatically to CV_32F or CV_64F, depending on the input depth.

 The function converts points homogeneous to Euclidean space using perspective projection. That is,
 each point (x1, x2, ... x(n-1), xn) is converted to (x1/xn, x2/xn, ..., x(n-1)/xn). When xn=0, the
 output point coordinates will be (0,0,0,...).</dd>
</dl>
</li>
</ul>
<a name="convertPointsToHomogeneous-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>convertPointsToHomogeneous</h4>
<pre>public static&nbsp;void&nbsp;convertPointsToHomogeneous(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Converts points from Euclidean to homogeneous space.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Input vector of N-dimensional points.</dd>
<dd><code>dst</code> - Output vector of N+1-dimensional points.
     If it's -1, then it's set automatically to CV_32F or CV_64F, depending on the input depth.

 The function converts points from Euclidean to homogeneous space by appending 1's to the tuple of
 point coordinates. That is, each point (x1, x2, ..., xn) is converted to (x1, x2, ..., xn, 1).</dd>
</dl>
</li>
</ul>
<a name="convertPointsToHomogeneous-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>convertPointsToHomogeneous</h4>
<pre>public static&nbsp;void&nbsp;convertPointsToHomogeneous(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                              int&nbsp;dtype)</pre>
<div class="block">Converts points from Euclidean to homogeneous space.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Input vector of N-dimensional points.</dd>
<dd><code>dst</code> - Output vector of N+1-dimensional points.</dd>
<dd><code>dtype</code> - The desired output array depth (either CV_32F or CV_64F are currently supported).
     If it's -1, then it's set automatically to CV_32F or CV_64F, depending on the input depth.

 The function converts points from Euclidean to homogeneous space by appending 1's to the tuple of
 point coordinates. That is, each point (x1, x2, ..., xn) is converted to (x1, x2, ..., xn, 1).</dd>
</dl>
</li>
</ul>
<a name="correctMatches-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>correctMatches</h4>
<pre>public static&nbsp;void&nbsp;correctMatches(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;F,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;newPoints1,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;newPoints2)</pre>
<div class="block">Refines coordinates of corresponding points.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>F</code> - 3x3 fundamental matrix.</dd>
<dd><code>points1</code> - 1xN array containing the first set of points.</dd>
<dd><code>points2</code> - 1xN array containing the second set of points.</dd>
<dd><code>newPoints1</code> - The optimized points1.</dd>
<dd><code>newPoints2</code> - The optimized points2.

 The function implements the Optimal Triangulation Method (see Multiple View Geometry CITE: HartleyZ00 for details).
 For each given point correspondence points1[i] &lt;-&gt; points2[i], and a fundamental matrix F, it
 computes the corrected correspondences newPoints1[i] &lt;-&gt; newPoints2[i] that minimize the geometric
 error \(d(points1[i], newPoints1[i])^2 + d(points2[i],newPoints2[i])^2\) (where \(d(a,b)\) is the
 geometric distance between points \(a\) and \(b\) ) subject to the epipolar constraint
 \(newPoints2^T \cdot F \cdot newPoints1 = 0\) .</dd>
</dl>
</li>
</ul>
<a name="decomposeEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>decomposeEssentialMat</h4>
<pre>public static&nbsp;void&nbsp;decomposeEssentialMat(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;E,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R1,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R2,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;t)</pre>
<div class="block">Decompose an essential matrix to possible rotations and translation.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>E</code> - The input essential matrix.</dd>
<dd><code>R1</code> - One possible rotation matrix.</dd>
<dd><code>R2</code> - Another possible rotation matrix.</dd>
<dd><code>t</code> - One possible translation.

 This function decomposes the essential matrix E using svd decomposition CITE: HartleyZ00. In
 general, four possible poses exist for the decomposition of E. They are \([R_1, t]\),
 \([R_1, -t]\), \([R_2, t]\), \([R_2, -t]\).

 If E gives the epipolar constraint \([p_2; 1]^T A^{-T} E A^{-1} [p_1; 1] = 0\) between the image
 points \(p_1\) in the first image and \(p_2\) in second image, then any of the tuples
 \([R_1, t]\), \([R_1, -t]\), \([R_2, t]\), \([R_2, -t]\) is a change of basis from the first
 camera's coordinate system to the second camera's coordinate system. However, by decomposing E, one
 can only get the direction of the translation. For this reason, the translation t is returned with
 unit length.</dd>
</dl>
</li>
</ul>
<a name="decomposeHomographyMat-org.opencv.core.Mat-org.opencv.core.Mat-java.util.List-java.util.List-java.util.List-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>decomposeHomographyMat</h4>
<pre>public static&nbsp;int&nbsp;decomposeHomographyMat(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;H,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                                         java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;rotations,
                                         java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;translations,
                                         java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;normals)</pre>
<div class="block">Decompose a homography matrix to rotation(s), translation(s) and plane normal(s).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>H</code> - The input homography matrix between two images.</dd>
<dd><code>K</code> - The input camera intrinsic matrix.</dd>
<dd><code>rotations</code> - Array of rotation matrices.</dd>
<dd><code>translations</code> - Array of translation matrices.</dd>
<dd><code>normals</code> - Array of plane normal matrices.

 This function extracts relative camera motion between two views of a planar object and returns up to
 four mathematical solution tuples of rotation, translation, and plane normal. The decomposition of
 the homography matrix H is described in detail in CITE: Malis2007.

 If the homography H, induced by the plane, gives the constraint
 \(s_i \vecthree{x'_i}{y'_i}{1} \sim H \vecthree{x_i}{y_i}{1}\) on the source image points
 \(p_i\) and the destination image points \(p'_i\), then the tuple of rotations[k] and
 translations[k] is a change of basis from the source camera's coordinate system to the destination
 camera's coordinate system. However, by decomposing H, one can only get the translation normalized
 by the (typically unknown) depth of the scene, i.e. its direction but with normalized length.

 If point correspondences are available, at least two solutions may further be invalidated, by
 applying positive depth constraint, i.e. all points must be in front of the camera.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="decomposeProjectionMatrix-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>decomposeProjectionMatrix</h4>
<pre>public static&nbsp;void&nbsp;decomposeProjectionMatrix(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;projMatrix,
                                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rotMatrix,
                                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;transVect)</pre>
<div class="block">Decomposes a projection matrix into a rotation matrix and a camera intrinsic matrix.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>projMatrix</code> - 3x4 input projection matrix P.</dd>
<dd><code>cameraMatrix</code> - Output 3x3 camera intrinsic matrix \(\cameramatrix{A}\).</dd>
<dd><code>rotMatrix</code> - Output 3x3 external rotation matrix R.</dd>
<dd><code>transVect</code> - Output 4x1 translation vector T.
 degrees.

 The function computes a decomposition of a projection matrix into a calibration and a rotation
 matrix and the position of a camera.

 It optionally returns three rotation matrices, one for each axis, and three Euler angles that could
 be used in OpenGL. Note, there is always more than one sequence of rotations about the three
 principal axes that results in the same orientation of an object, e.g. see CITE: Slabaugh . Returned
 three rotation matrices and corresponding three Euler angles are only one of the possible solutions.

 The function is based on #RQDecomp3x3 .</dd>
</dl>
</li>
</ul>
<a name="decomposeProjectionMatrix-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>decomposeProjectionMatrix</h4>
<pre>public static&nbsp;void&nbsp;decomposeProjectionMatrix(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;projMatrix,
                                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rotMatrix,
                                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;transVect,
                                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rotMatrixX)</pre>
<div class="block">Decomposes a projection matrix into a rotation matrix and a camera intrinsic matrix.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>projMatrix</code> - 3x4 input projection matrix P.</dd>
<dd><code>cameraMatrix</code> - Output 3x3 camera intrinsic matrix \(\cameramatrix{A}\).</dd>
<dd><code>rotMatrix</code> - Output 3x3 external rotation matrix R.</dd>
<dd><code>transVect</code> - Output 4x1 translation vector T.</dd>
<dd><code>rotMatrixX</code> - Optional 3x3 rotation matrix around x-axis.
 degrees.

 The function computes a decomposition of a projection matrix into a calibration and a rotation
 matrix and the position of a camera.

 It optionally returns three rotation matrices, one for each axis, and three Euler angles that could
 be used in OpenGL. Note, there is always more than one sequence of rotations about the three
 principal axes that results in the same orientation of an object, e.g. see CITE: Slabaugh . Returned
 three rotation matrices and corresponding three Euler angles are only one of the possible solutions.

 The function is based on #RQDecomp3x3 .</dd>
</dl>
</li>
</ul>
<a name="decomposeProjectionMatrix-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>decomposeProjectionMatrix</h4>
<pre>public static&nbsp;void&nbsp;decomposeProjectionMatrix(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;projMatrix,
                                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rotMatrix,
                                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;transVect,
                                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rotMatrixX,
                                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rotMatrixY)</pre>
<div class="block">Decomposes a projection matrix into a rotation matrix and a camera intrinsic matrix.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>projMatrix</code> - 3x4 input projection matrix P.</dd>
<dd><code>cameraMatrix</code> - Output 3x3 camera intrinsic matrix \(\cameramatrix{A}\).</dd>
<dd><code>rotMatrix</code> - Output 3x3 external rotation matrix R.</dd>
<dd><code>transVect</code> - Output 4x1 translation vector T.</dd>
<dd><code>rotMatrixX</code> - Optional 3x3 rotation matrix around x-axis.</dd>
<dd><code>rotMatrixY</code> - Optional 3x3 rotation matrix around y-axis.
 degrees.

 The function computes a decomposition of a projection matrix into a calibration and a rotation
 matrix and the position of a camera.

 It optionally returns three rotation matrices, one for each axis, and three Euler angles that could
 be used in OpenGL. Note, there is always more than one sequence of rotations about the three
 principal axes that results in the same orientation of an object, e.g. see CITE: Slabaugh . Returned
 three rotation matrices and corresponding three Euler angles are only one of the possible solutions.

 The function is based on #RQDecomp3x3 .</dd>
</dl>
</li>
</ul>
<a name="decomposeProjectionMatrix-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>decomposeProjectionMatrix</h4>
<pre>public static&nbsp;void&nbsp;decomposeProjectionMatrix(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;projMatrix,
                                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rotMatrix,
                                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;transVect,
                                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rotMatrixX,
                                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rotMatrixY,
                                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rotMatrixZ)</pre>
<div class="block">Decomposes a projection matrix into a rotation matrix and a camera intrinsic matrix.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>projMatrix</code> - 3x4 input projection matrix P.</dd>
<dd><code>cameraMatrix</code> - Output 3x3 camera intrinsic matrix \(\cameramatrix{A}\).</dd>
<dd><code>rotMatrix</code> - Output 3x3 external rotation matrix R.</dd>
<dd><code>transVect</code> - Output 4x1 translation vector T.</dd>
<dd><code>rotMatrixX</code> - Optional 3x3 rotation matrix around x-axis.</dd>
<dd><code>rotMatrixY</code> - Optional 3x3 rotation matrix around y-axis.</dd>
<dd><code>rotMatrixZ</code> - Optional 3x3 rotation matrix around z-axis.
 degrees.

 The function computes a decomposition of a projection matrix into a calibration and a rotation
 matrix and the position of a camera.

 It optionally returns three rotation matrices, one for each axis, and three Euler angles that could
 be used in OpenGL. Note, there is always more than one sequence of rotations about the three
 principal axes that results in the same orientation of an object, e.g. see CITE: Slabaugh . Returned
 three rotation matrices and corresponding three Euler angles are only one of the possible solutions.

 The function is based on #RQDecomp3x3 .</dd>
</dl>
</li>
</ul>
<a name="decomposeProjectionMatrix-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>decomposeProjectionMatrix</h4>
<pre>public static&nbsp;void&nbsp;decomposeProjectionMatrix(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;projMatrix,
                                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rotMatrix,
                                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;transVect,
                                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rotMatrixX,
                                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rotMatrixY,
                                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rotMatrixZ,
                                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eulerAngles)</pre>
<div class="block">Decomposes a projection matrix into a rotation matrix and a camera intrinsic matrix.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>projMatrix</code> - 3x4 input projection matrix P.</dd>
<dd><code>cameraMatrix</code> - Output 3x3 camera intrinsic matrix \(\cameramatrix{A}\).</dd>
<dd><code>rotMatrix</code> - Output 3x3 external rotation matrix R.</dd>
<dd><code>transVect</code> - Output 4x1 translation vector T.</dd>
<dd><code>rotMatrixX</code> - Optional 3x3 rotation matrix around x-axis.</dd>
<dd><code>rotMatrixY</code> - Optional 3x3 rotation matrix around y-axis.</dd>
<dd><code>rotMatrixZ</code> - Optional 3x3 rotation matrix around z-axis.</dd>
<dd><code>eulerAngles</code> - Optional three-element vector containing three Euler angles of rotation in
 degrees.

 The function computes a decomposition of a projection matrix into a calibration and a rotation
 matrix and the position of a camera.

 It optionally returns three rotation matrices, one for each axis, and three Euler angles that could
 be used in OpenGL. Note, there is always more than one sequence of rotations about the three
 principal axes that results in the same orientation of an object, e.g. see CITE: Slabaugh . Returned
 three rotation matrices and corresponding three Euler angles are only one of the possible solutions.

 The function is based on #RQDecomp3x3 .</dd>
</dl>
</li>
</ul>
<a name="depthTo3d-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>depthTo3d</h4>
<pre>public static&nbsp;void&nbsp;depthTo3d(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;depth,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points3d)</pre>
<div class="block">Converts a depth image to 3d points. If the mask is empty then the resulting array has the same dimensions as <code>depth</code>,
 otherwise it is 1d vector containing mask-enabled values only.
 The coordinate system is x pointing left, y down and z away from the camera</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>depth</code> - the depth image (if given as short int CV_U, it is assumed to be the depth in millimeters
 (as done with the Microsoft Kinect), otherwise, if given as CV_32F or CV_64F, it is assumed in meters)</dd>
<dd><code>K</code> - The calibration matrix</dd>
<dd><code>points3d</code> - the resulting 3d points (point is represented by 4 channels value [x, y, z, 0]). They are of the same depth as <code>depth</code> if it is CV_32F or CV_64F, and the
 depth of <code>K</code> if <code>depth</code> is of depth CV_16U or CV_16S</dd>
</dl>
</li>
</ul>
<a name="depthTo3d-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>depthTo3d</h4>
<pre>public static&nbsp;void&nbsp;depthTo3d(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;depth,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points3d,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
<div class="block">Converts a depth image to 3d points. If the mask is empty then the resulting array has the same dimensions as <code>depth</code>,
 otherwise it is 1d vector containing mask-enabled values only.
 The coordinate system is x pointing left, y down and z away from the camera</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>depth</code> - the depth image (if given as short int CV_U, it is assumed to be the depth in millimeters
 (as done with the Microsoft Kinect), otherwise, if given as CV_32F or CV_64F, it is assumed in meters)</dd>
<dd><code>K</code> - The calibration matrix</dd>
<dd><code>points3d</code> - the resulting 3d points (point is represented by 4 channels value [x, y, z, 0]). They are of the same depth as <code>depth</code> if it is CV_32F or CV_64F, and the
 depth of <code>K</code> if <code>depth</code> is of depth CV_16U or CV_16S</dd>
<dd><code>mask</code> - the mask of the points to consider (can be empty)</dd>
</dl>
</li>
</ul>
<a name="depthTo3dSparse-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>depthTo3dSparse</h4>
<pre>public static&nbsp;void&nbsp;depthTo3dSparse(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;depth,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;in_K,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;in_points,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points3d)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>depth</code> - the depth image</dd>
<dd><code>in_K</code> - </dd>
<dd><code>in_points</code> - the list of xy coordinates</dd>
<dd><code>points3d</code> - the resulting 3d points (point is represented by 4 chanels value [x, y, z, 0])</dd>
</dl>
</li>
</ul>
<a name="drawFrameAxes-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-float-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>drawFrameAxes</h4>
<pre>public static&nbsp;void&nbsp;drawFrameAxes(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                                 float&nbsp;length)</pre>
<div class="block">Draw axes of the world/object coordinate system from pose estimation. SEE: solvePnP</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - Input/output image. It must have 1 or 3 channels. The number of channels is not altered.</dd>
<dd><code>cameraMatrix</code> - Input 3x3 floating-point matrix of camera intrinsic parameters.
 \(\cameramatrix{A}\)</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \(\distcoeffs\). If the vector is empty, the zero distortion coefficients are assumed.</dd>
<dd><code>rvec</code> - Rotation vector (see REF: Rodrigues ) that, together with tvec, brings points from
 the model coordinate system to the camera coordinate system.</dd>
<dd><code>tvec</code> - Translation vector.</dd>
<dd><code>length</code> - Length of the painted axes in the same unit than tvec (usually in meters).

 This function draws the axes of the world/object coordinate system w.r.t. to the camera frame.
 OX is drawn in red, OY in green and OZ in blue.</dd>
</dl>
</li>
</ul>
<a name="drawFrameAxes-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-float-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>drawFrameAxes</h4>
<pre>public static&nbsp;void&nbsp;drawFrameAxes(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                                 float&nbsp;length,
                                 int&nbsp;thickness)</pre>
<div class="block">Draw axes of the world/object coordinate system from pose estimation. SEE: solvePnP</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - Input/output image. It must have 1 or 3 channels. The number of channels is not altered.</dd>
<dd><code>cameraMatrix</code> - Input 3x3 floating-point matrix of camera intrinsic parameters.
 \(\cameramatrix{A}\)</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \(\distcoeffs\). If the vector is empty, the zero distortion coefficients are assumed.</dd>
<dd><code>rvec</code> - Rotation vector (see REF: Rodrigues ) that, together with tvec, brings points from
 the model coordinate system to the camera coordinate system.</dd>
<dd><code>tvec</code> - Translation vector.</dd>
<dd><code>length</code> - Length of the painted axes in the same unit than tvec (usually in meters).</dd>
<dd><code>thickness</code> - Line thickness of the painted axes.

 This function draws the axes of the world/object coordinate system w.r.t. to the camera frame.
 OX is drawn in red, OY in green and OZ in blue.</dd>
</dl>
</li>
</ul>
<a name="estimateAffine2D-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>estimateAffine2D</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;estimateAffine2D(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;from,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;to)</pre>
<div class="block">Computes an optimal affine transformation between two 2D point sets.

 It computes
 \(
 \begin{bmatrix}
 x\\
 y\\
 \end{bmatrix}
 =
 \begin{bmatrix}
 a_{11} &amp; a_{12}\\
 a_{21} &amp; a_{22}\\
 \end{bmatrix}
 \begin{bmatrix}
 X\\
 Y\\
 \end{bmatrix}
 +
 \begin{bmatrix}
 b_1\\
 b_2\\
 \end{bmatrix}
 \)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>from</code> - First input 2D point set containing \((X,Y)\).</dd>
<dd><code>to</code> - Second input 2D point set containing \((x,y)\).
 <ul>
   <li>
    REF: RANSAC - RANSAC-based robust method
   </li>
   <li>
    REF: LMEDS - Least-Median robust method
 RANSAC is the default method.
   </li>
 </ul>
 a point as an inlier. Applies only to RANSAC.
 between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation
 significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.
 Passing 0 will disable refining, so the output matrix will be output of robust method.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Output 2D affine transformation matrix \(2 \times 3\) or empty matrix if transformation
 could not be estimated. The returned matrix has the following form:
 \(
 \begin{bmatrix}
 a_{11} &amp; a_{12} &amp; b_1\\
 a_{21} &amp; a_{22} &amp; b_2\\
 \end{bmatrix}
 \)

 The function estimates an optimal 2D affine transformation between two 2D point sets using the
 selected robust algorithm.

 The computed transformation is then refined further (using only inliers) with the
 Levenberg-Marquardt method to reduce the re-projection error even more.

 <b>Note:</b>
 The RANSAC method can handle practically any ratio of outliers but needs a threshold to
 distinguish inliers from outliers. The method LMeDS does not need any threshold but it works
 correctly only when there are more than 50% of inliers.

 SEE: estimateAffinePartial2D, getAffineTransform</dd>
</dl>
</li>
</ul>
<a name="estimateAffine2D-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>estimateAffine2D</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;estimateAffine2D(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;from,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;to,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers)</pre>
<div class="block">Computes an optimal affine transformation between two 2D point sets.

 It computes
 \(
 \begin{bmatrix}
 x\\
 y\\
 \end{bmatrix}
 =
 \begin{bmatrix}
 a_{11} &amp; a_{12}\\
 a_{21} &amp; a_{22}\\
 \end{bmatrix}
 \begin{bmatrix}
 X\\
 Y\\
 \end{bmatrix}
 +
 \begin{bmatrix}
 b_1\\
 b_2\\
 \end{bmatrix}
 \)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>from</code> - First input 2D point set containing \((X,Y)\).</dd>
<dd><code>to</code> - Second input 2D point set containing \((x,y)\).</dd>
<dd><code>inliers</code> - Output vector indicating which points are inliers (1-inlier, 0-outlier).
 <ul>
   <li>
    REF: RANSAC - RANSAC-based robust method
   </li>
   <li>
    REF: LMEDS - Least-Median robust method
 RANSAC is the default method.
   </li>
 </ul>
 a point as an inlier. Applies only to RANSAC.
 between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation
 significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.
 Passing 0 will disable refining, so the output matrix will be output of robust method.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Output 2D affine transformation matrix \(2 \times 3\) or empty matrix if transformation
 could not be estimated. The returned matrix has the following form:
 \(
 \begin{bmatrix}
 a_{11} &amp; a_{12} &amp; b_1\\
 a_{21} &amp; a_{22} &amp; b_2\\
 \end{bmatrix}
 \)

 The function estimates an optimal 2D affine transformation between two 2D point sets using the
 selected robust algorithm.

 The computed transformation is then refined further (using only inliers) with the
 Levenberg-Marquardt method to reduce the re-projection error even more.

 <b>Note:</b>
 The RANSAC method can handle practically any ratio of outliers but needs a threshold to
 distinguish inliers from outliers. The method LMeDS does not need any threshold but it works
 correctly only when there are more than 50% of inliers.

 SEE: estimateAffinePartial2D, getAffineTransform</dd>
</dl>
</li>
</ul>
<a name="estimateAffine2D-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>estimateAffine2D</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;estimateAffine2D(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;from,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;to,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers,
                                   int&nbsp;method)</pre>
<div class="block">Computes an optimal affine transformation between two 2D point sets.

 It computes
 \(
 \begin{bmatrix}
 x\\
 y\\
 \end{bmatrix}
 =
 \begin{bmatrix}
 a_{11} &amp; a_{12}\\
 a_{21} &amp; a_{22}\\
 \end{bmatrix}
 \begin{bmatrix}
 X\\
 Y\\
 \end{bmatrix}
 +
 \begin{bmatrix}
 b_1\\
 b_2\\
 \end{bmatrix}
 \)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>from</code> - First input 2D point set containing \((X,Y)\).</dd>
<dd><code>to</code> - Second input 2D point set containing \((x,y)\).</dd>
<dd><code>inliers</code> - Output vector indicating which points are inliers (1-inlier, 0-outlier).</dd>
<dd><code>method</code> - Robust method used to compute transformation. The following methods are possible:
 <ul>
   <li>
    REF: RANSAC - RANSAC-based robust method
   </li>
   <li>
    REF: LMEDS - Least-Median robust method
 RANSAC is the default method.
   </li>
 </ul>
 a point as an inlier. Applies only to RANSAC.
 between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation
 significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.
 Passing 0 will disable refining, so the output matrix will be output of robust method.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Output 2D affine transformation matrix \(2 \times 3\) or empty matrix if transformation
 could not be estimated. The returned matrix has the following form:
 \(
 \begin{bmatrix}
 a_{11} &amp; a_{12} &amp; b_1\\
 a_{21} &amp; a_{22} &amp; b_2\\
 \end{bmatrix}
 \)

 The function estimates an optimal 2D affine transformation between two 2D point sets using the
 selected robust algorithm.

 The computed transformation is then refined further (using only inliers) with the
 Levenberg-Marquardt method to reduce the re-projection error even more.

 <b>Note:</b>
 The RANSAC method can handle practically any ratio of outliers but needs a threshold to
 distinguish inliers from outliers. The method LMeDS does not need any threshold but it works
 correctly only when there are more than 50% of inliers.

 SEE: estimateAffinePartial2D, getAffineTransform</dd>
</dl>
</li>
</ul>
<a name="estimateAffine2D-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>estimateAffine2D</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;estimateAffine2D(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;from,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;to,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers,
                                   int&nbsp;method,
                                   double&nbsp;ransacReprojThreshold)</pre>
<div class="block">Computes an optimal affine transformation between two 2D point sets.

 It computes
 \(
 \begin{bmatrix}
 x\\
 y\\
 \end{bmatrix}
 =
 \begin{bmatrix}
 a_{11} &amp; a_{12}\\
 a_{21} &amp; a_{22}\\
 \end{bmatrix}
 \begin{bmatrix}
 X\\
 Y\\
 \end{bmatrix}
 +
 \begin{bmatrix}
 b_1\\
 b_2\\
 \end{bmatrix}
 \)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>from</code> - First input 2D point set containing \((X,Y)\).</dd>
<dd><code>to</code> - Second input 2D point set containing \((x,y)\).</dd>
<dd><code>inliers</code> - Output vector indicating which points are inliers (1-inlier, 0-outlier).</dd>
<dd><code>method</code> - Robust method used to compute transformation. The following methods are possible:
 <ul>
   <li>
    REF: RANSAC - RANSAC-based robust method
   </li>
   <li>
    REF: LMEDS - Least-Median robust method
 RANSAC is the default method.
   </li>
 </ul></dd>
<dd><code>ransacReprojThreshold</code> - Maximum reprojection error in the RANSAC algorithm to consider
 a point as an inlier. Applies only to RANSAC.
 between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation
 significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.
 Passing 0 will disable refining, so the output matrix will be output of robust method.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Output 2D affine transformation matrix \(2 \times 3\) or empty matrix if transformation
 could not be estimated. The returned matrix has the following form:
 \(
 \begin{bmatrix}
 a_{11} &amp; a_{12} &amp; b_1\\
 a_{21} &amp; a_{22} &amp; b_2\\
 \end{bmatrix}
 \)

 The function estimates an optimal 2D affine transformation between two 2D point sets using the
 selected robust algorithm.

 The computed transformation is then refined further (using only inliers) with the
 Levenberg-Marquardt method to reduce the re-projection error even more.

 <b>Note:</b>
 The RANSAC method can handle practically any ratio of outliers but needs a threshold to
 distinguish inliers from outliers. The method LMeDS does not need any threshold but it works
 correctly only when there are more than 50% of inliers.

 SEE: estimateAffinePartial2D, getAffineTransform</dd>
</dl>
</li>
</ul>
<a name="estimateAffine2D-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-double-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>estimateAffine2D</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;estimateAffine2D(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;from,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;to,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers,
                                   int&nbsp;method,
                                   double&nbsp;ransacReprojThreshold,
                                   long&nbsp;maxIters)</pre>
<div class="block">Computes an optimal affine transformation between two 2D point sets.

 It computes
 \(
 \begin{bmatrix}
 x\\
 y\\
 \end{bmatrix}
 =
 \begin{bmatrix}
 a_{11} &amp; a_{12}\\
 a_{21} &amp; a_{22}\\
 \end{bmatrix}
 \begin{bmatrix}
 X\\
 Y\\
 \end{bmatrix}
 +
 \begin{bmatrix}
 b_1\\
 b_2\\
 \end{bmatrix}
 \)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>from</code> - First input 2D point set containing \((X,Y)\).</dd>
<dd><code>to</code> - Second input 2D point set containing \((x,y)\).</dd>
<dd><code>inliers</code> - Output vector indicating which points are inliers (1-inlier, 0-outlier).</dd>
<dd><code>method</code> - Robust method used to compute transformation. The following methods are possible:
 <ul>
   <li>
    REF: RANSAC - RANSAC-based robust method
   </li>
   <li>
    REF: LMEDS - Least-Median robust method
 RANSAC is the default method.
   </li>
 </ul></dd>
<dd><code>ransacReprojThreshold</code> - Maximum reprojection error in the RANSAC algorithm to consider
 a point as an inlier. Applies only to RANSAC.</dd>
<dd><code>maxIters</code> - The maximum number of robust method iterations.
 between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation
 significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.
 Passing 0 will disable refining, so the output matrix will be output of robust method.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Output 2D affine transformation matrix \(2 \times 3\) or empty matrix if transformation
 could not be estimated. The returned matrix has the following form:
 \(
 \begin{bmatrix}
 a_{11} &amp; a_{12} &amp; b_1\\
 a_{21} &amp; a_{22} &amp; b_2\\
 \end{bmatrix}
 \)

 The function estimates an optimal 2D affine transformation between two 2D point sets using the
 selected robust algorithm.

 The computed transformation is then refined further (using only inliers) with the
 Levenberg-Marquardt method to reduce the re-projection error even more.

 <b>Note:</b>
 The RANSAC method can handle practically any ratio of outliers but needs a threshold to
 distinguish inliers from outliers. The method LMeDS does not need any threshold but it works
 correctly only when there are more than 50% of inliers.

 SEE: estimateAffinePartial2D, getAffineTransform</dd>
</dl>
</li>
</ul>
<a name="estimateAffine2D-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-double-long-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>estimateAffine2D</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;estimateAffine2D(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;from,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;to,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers,
                                   int&nbsp;method,
                                   double&nbsp;ransacReprojThreshold,
                                   long&nbsp;maxIters,
                                   double&nbsp;confidence)</pre>
<div class="block">Computes an optimal affine transformation between two 2D point sets.

 It computes
 \(
 \begin{bmatrix}
 x\\
 y\\
 \end{bmatrix}
 =
 \begin{bmatrix}
 a_{11} &amp; a_{12}\\
 a_{21} &amp; a_{22}\\
 \end{bmatrix}
 \begin{bmatrix}
 X\\
 Y\\
 \end{bmatrix}
 +
 \begin{bmatrix}
 b_1\\
 b_2\\
 \end{bmatrix}
 \)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>from</code> - First input 2D point set containing \((X,Y)\).</dd>
<dd><code>to</code> - Second input 2D point set containing \((x,y)\).</dd>
<dd><code>inliers</code> - Output vector indicating which points are inliers (1-inlier, 0-outlier).</dd>
<dd><code>method</code> - Robust method used to compute transformation. The following methods are possible:
 <ul>
   <li>
    REF: RANSAC - RANSAC-based robust method
   </li>
   <li>
    REF: LMEDS - Least-Median robust method
 RANSAC is the default method.
   </li>
 </ul></dd>
<dd><code>ransacReprojThreshold</code> - Maximum reprojection error in the RANSAC algorithm to consider
 a point as an inlier. Applies only to RANSAC.</dd>
<dd><code>maxIters</code> - The maximum number of robust method iterations.</dd>
<dd><code>confidence</code> - Confidence level, between 0 and 1, for the estimated transformation. Anything
 between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation
 significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.
 Passing 0 will disable refining, so the output matrix will be output of robust method.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Output 2D affine transformation matrix \(2 \times 3\) or empty matrix if transformation
 could not be estimated. The returned matrix has the following form:
 \(
 \begin{bmatrix}
 a_{11} &amp; a_{12} &amp; b_1\\
 a_{21} &amp; a_{22} &amp; b_2\\
 \end{bmatrix}
 \)

 The function estimates an optimal 2D affine transformation between two 2D point sets using the
 selected robust algorithm.

 The computed transformation is then refined further (using only inliers) with the
 Levenberg-Marquardt method to reduce the re-projection error even more.

 <b>Note:</b>
 The RANSAC method can handle practically any ratio of outliers but needs a threshold to
 distinguish inliers from outliers. The method LMeDS does not need any threshold but it works
 correctly only when there are more than 50% of inliers.

 SEE: estimateAffinePartial2D, getAffineTransform</dd>
</dl>
</li>
</ul>
<a name="estimateAffine2D-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-double-long-double-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>estimateAffine2D</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;estimateAffine2D(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;from,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;to,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers,
                                   int&nbsp;method,
                                   double&nbsp;ransacReprojThreshold,
                                   long&nbsp;maxIters,
                                   double&nbsp;confidence,
                                   long&nbsp;refineIters)</pre>
<div class="block">Computes an optimal affine transformation between two 2D point sets.

 It computes
 \(
 \begin{bmatrix}
 x\\
 y\\
 \end{bmatrix}
 =
 \begin{bmatrix}
 a_{11} &amp; a_{12}\\
 a_{21} &amp; a_{22}\\
 \end{bmatrix}
 \begin{bmatrix}
 X\\
 Y\\
 \end{bmatrix}
 +
 \begin{bmatrix}
 b_1\\
 b_2\\
 \end{bmatrix}
 \)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>from</code> - First input 2D point set containing \((X,Y)\).</dd>
<dd><code>to</code> - Second input 2D point set containing \((x,y)\).</dd>
<dd><code>inliers</code> - Output vector indicating which points are inliers (1-inlier, 0-outlier).</dd>
<dd><code>method</code> - Robust method used to compute transformation. The following methods are possible:
 <ul>
   <li>
    REF: RANSAC - RANSAC-based robust method
   </li>
   <li>
    REF: LMEDS - Least-Median robust method
 RANSAC is the default method.
   </li>
 </ul></dd>
<dd><code>ransacReprojThreshold</code> - Maximum reprojection error in the RANSAC algorithm to consider
 a point as an inlier. Applies only to RANSAC.</dd>
<dd><code>maxIters</code> - The maximum number of robust method iterations.</dd>
<dd><code>confidence</code> - Confidence level, between 0 and 1, for the estimated transformation. Anything
 between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation
 significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.</dd>
<dd><code>refineIters</code> - Maximum number of iterations of refining algorithm (Levenberg-Marquardt).
 Passing 0 will disable refining, so the output matrix will be output of robust method.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Output 2D affine transformation matrix \(2 \times 3\) or empty matrix if transformation
 could not be estimated. The returned matrix has the following form:
 \(
 \begin{bmatrix}
 a_{11} &amp; a_{12} &amp; b_1\\
 a_{21} &amp; a_{22} &amp; b_2\\
 \end{bmatrix}
 \)

 The function estimates an optimal 2D affine transformation between two 2D point sets using the
 selected robust algorithm.

 The computed transformation is then refined further (using only inliers) with the
 Levenberg-Marquardt method to reduce the re-projection error even more.

 <b>Note:</b>
 The RANSAC method can handle practically any ratio of outliers but needs a threshold to
 distinguish inliers from outliers. The method LMeDS does not need any threshold but it works
 correctly only when there are more than 50% of inliers.

 SEE: estimateAffinePartial2D, getAffineTransform</dd>
</dl>
</li>
</ul>
<a name="estimateAffine2D-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.cv3d.UsacParams-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>estimateAffine2D</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;estimateAffine2D(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;pts1,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;pts2,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers,
                                   <a href="../../../org/opencv/cv3d/UsacParams.html" title="class in org.opencv.cv3d">UsacParams</a>&nbsp;params)</pre>
</li>
</ul>
<a name="estimateAffine3D-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>estimateAffine3D</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;estimateAffine3D(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Computes an optimal affine transformation between two 3D point sets.

 It computes \(R,s,t\) minimizing \(\sum{i} dst_i - c \cdot R \cdot src_i \)
 where \(R\) is a 3x3 rotation matrix, \(t\) is a 3x1 translation vector and \(s\) is a
 scalar size value. This is an implementation of the algorithm by Umeyama \cite umeyama1991least .
 The estimated affine transform has a homogeneous scale which is a subclass of affine
 transformations with 7 degrees of freedom. The paired point sets need to comprise at least 3
 points each.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - First input 3D point set.</dd>
<dd><code>dst</code> - Second input 3D point set.
 Else the pointed-to variable will be set to the optimal scale.
 This might be unwanted, e.g. when optimizing a transform between a right- and a
 left-handed coordinate system.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>3D affine transformation matrix \(3 \times 4\) of the form
 \(T =
 \begin{bmatrix}
 R &amp; t\\
 \end{bmatrix}
 \)</dd>
</dl>
</li>
</ul>
<a name="estimateAffine3D-org.opencv.core.Mat-org.opencv.core.Mat-double:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>estimateAffine3D</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;estimateAffine3D(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                   double[]&nbsp;scale)</pre>
<div class="block">Computes an optimal affine transformation between two 3D point sets.

 It computes \(R,s,t\) minimizing \(\sum{i} dst_i - c \cdot R \cdot src_i \)
 where \(R\) is a 3x3 rotation matrix, \(t\) is a 3x1 translation vector and \(s\) is a
 scalar size value. This is an implementation of the algorithm by Umeyama \cite umeyama1991least .
 The estimated affine transform has a homogeneous scale which is a subclass of affine
 transformations with 7 degrees of freedom. The paired point sets need to comprise at least 3
 points each.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - First input 3D point set.</dd>
<dd><code>dst</code> - Second input 3D point set.</dd>
<dd><code>scale</code> - If null is passed, the scale parameter c will be assumed to be 1.0.
 Else the pointed-to variable will be set to the optimal scale.
 This might be unwanted, e.g. when optimizing a transform between a right- and a
 left-handed coordinate system.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>3D affine transformation matrix \(3 \times 4\) of the form
 \(T =
 \begin{bmatrix}
 R &amp; t\\
 \end{bmatrix}
 \)</dd>
</dl>
</li>
</ul>
<a name="estimateAffine3D-org.opencv.core.Mat-org.opencv.core.Mat-double:A-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>estimateAffine3D</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;estimateAffine3D(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                   double[]&nbsp;scale,
                                   boolean&nbsp;force_rotation)</pre>
<div class="block">Computes an optimal affine transformation between two 3D point sets.

 It computes \(R,s,t\) minimizing \(\sum{i} dst_i - c \cdot R \cdot src_i \)
 where \(R\) is a 3x3 rotation matrix, \(t\) is a 3x1 translation vector and \(s\) is a
 scalar size value. This is an implementation of the algorithm by Umeyama \cite umeyama1991least .
 The estimated affine transform has a homogeneous scale which is a subclass of affine
 transformations with 7 degrees of freedom. The paired point sets need to comprise at least 3
 points each.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - First input 3D point set.</dd>
<dd><code>dst</code> - Second input 3D point set.</dd>
<dd><code>scale</code> - If null is passed, the scale parameter c will be assumed to be 1.0.
 Else the pointed-to variable will be set to the optimal scale.</dd>
<dd><code>force_rotation</code> - If true, the returned rotation will never be a reflection.
 This might be unwanted, e.g. when optimizing a transform between a right- and a
 left-handed coordinate system.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>3D affine transformation matrix \(3 \times 4\) of the form
 \(T =
 \begin{bmatrix}
 R &amp; t\\
 \end{bmatrix}
 \)</dd>
</dl>
</li>
</ul>
<a name="estimateAffine3D-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>estimateAffine3D</h4>
<pre>public static&nbsp;int&nbsp;estimateAffine3D(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;out,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers)</pre>
<div class="block">Computes an optimal affine transformation between two 3D point sets.

 It computes
 \(
 \begin{bmatrix}
 x\\
 y\\
 z\\
 \end{bmatrix}
 =
 \begin{bmatrix}
 a_{11} &amp; a_{12} &amp; a_{13}\\
 a_{21} &amp; a_{22} &amp; a_{23}\\
 a_{31} &amp; a_{32} &amp; a_{33}\\
 \end{bmatrix}
 \begin{bmatrix}
 X\\
 Y\\
 Z\\
 \end{bmatrix}
 +
 \begin{bmatrix}
 b_1\\
 b_2\\
 b_3\\
 \end{bmatrix}
 \)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - First input 3D point set containing \((X,Y,Z)\).</dd>
<dd><code>dst</code> - Second input 3D point set containing \((x,y,z)\).</dd>
<dd><code>out</code> - Output 3D affine transformation matrix \(3 \times 4\) of the form
 \(
 \begin{bmatrix}
 a_{11} &amp; a_{12} &amp; a_{13} &amp; b_1\\
 a_{21} &amp; a_{22} &amp; a_{23} &amp; b_2\\
 a_{31} &amp; a_{32} &amp; a_{33} &amp; b_3\\
 \end{bmatrix}
 \)</dd>
<dd><code>inliers</code> - Output vector indicating which points are inliers (1-inlier, 0-outlier).
 an inlier.
 between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation
 significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.

 The function estimates an optimal 3D affine transformation between two 3D point sets using the
 RANSAC algorithm.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="estimateAffine3D-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>estimateAffine3D</h4>
<pre>public static&nbsp;int&nbsp;estimateAffine3D(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;out,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers,
                                   double&nbsp;ransacThreshold)</pre>
<div class="block">Computes an optimal affine transformation between two 3D point sets.

 It computes
 \(
 \begin{bmatrix}
 x\\
 y\\
 z\\
 \end{bmatrix}
 =
 \begin{bmatrix}
 a_{11} &amp; a_{12} &amp; a_{13}\\
 a_{21} &amp; a_{22} &amp; a_{23}\\
 a_{31} &amp; a_{32} &amp; a_{33}\\
 \end{bmatrix}
 \begin{bmatrix}
 X\\
 Y\\
 Z\\
 \end{bmatrix}
 +
 \begin{bmatrix}
 b_1\\
 b_2\\
 b_3\\
 \end{bmatrix}
 \)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - First input 3D point set containing \((X,Y,Z)\).</dd>
<dd><code>dst</code> - Second input 3D point set containing \((x,y,z)\).</dd>
<dd><code>out</code> - Output 3D affine transformation matrix \(3 \times 4\) of the form
 \(
 \begin{bmatrix}
 a_{11} &amp; a_{12} &amp; a_{13} &amp; b_1\\
 a_{21} &amp; a_{22} &amp; a_{23} &amp; b_2\\
 a_{31} &amp; a_{32} &amp; a_{33} &amp; b_3\\
 \end{bmatrix}
 \)</dd>
<dd><code>inliers</code> - Output vector indicating which points are inliers (1-inlier, 0-outlier).</dd>
<dd><code>ransacThreshold</code> - Maximum reprojection error in the RANSAC algorithm to consider a point as
 an inlier.
 between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation
 significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.

 The function estimates an optimal 3D affine transformation between two 3D point sets using the
 RANSAC algorithm.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="estimateAffine3D-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>estimateAffine3D</h4>
<pre>public static&nbsp;int&nbsp;estimateAffine3D(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;out,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers,
                                   double&nbsp;ransacThreshold,
                                   double&nbsp;confidence)</pre>
<div class="block">Computes an optimal affine transformation between two 3D point sets.

 It computes
 \(
 \begin{bmatrix}
 x\\
 y\\
 z\\
 \end{bmatrix}
 =
 \begin{bmatrix}
 a_{11} &amp; a_{12} &amp; a_{13}\\
 a_{21} &amp; a_{22} &amp; a_{23}\\
 a_{31} &amp; a_{32} &amp; a_{33}\\
 \end{bmatrix}
 \begin{bmatrix}
 X\\
 Y\\
 Z\\
 \end{bmatrix}
 +
 \begin{bmatrix}
 b_1\\
 b_2\\
 b_3\\
 \end{bmatrix}
 \)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - First input 3D point set containing \((X,Y,Z)\).</dd>
<dd><code>dst</code> - Second input 3D point set containing \((x,y,z)\).</dd>
<dd><code>out</code> - Output 3D affine transformation matrix \(3 \times 4\) of the form
 \(
 \begin{bmatrix}
 a_{11} &amp; a_{12} &amp; a_{13} &amp; b_1\\
 a_{21} &amp; a_{22} &amp; a_{23} &amp; b_2\\
 a_{31} &amp; a_{32} &amp; a_{33} &amp; b_3\\
 \end{bmatrix}
 \)</dd>
<dd><code>inliers</code> - Output vector indicating which points are inliers (1-inlier, 0-outlier).</dd>
<dd><code>ransacThreshold</code> - Maximum reprojection error in the RANSAC algorithm to consider a point as
 an inlier.</dd>
<dd><code>confidence</code> - Confidence level, between 0 and 1, for the estimated transformation. Anything
 between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation
 significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.

 The function estimates an optimal 3D affine transformation between two 3D point sets using the
 RANSAC algorithm.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="estimateAffinePartial2D-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>estimateAffinePartial2D</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;estimateAffinePartial2D(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;from,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;to)</pre>
<div class="block">Computes an optimal limited affine transformation with 4 degrees of freedom between
 two 2D point sets.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>from</code> - First input 2D point set.</dd>
<dd><code>to</code> - Second input 2D point set.
 <ul>
   <li>
    REF: RANSAC - RANSAC-based robust method
   </li>
   <li>
    REF: LMEDS - Least-Median robust method
 RANSAC is the default method.
   </li>
 </ul>
 a point as an inlier. Applies only to RANSAC.
 between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation
 significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.
 Passing 0 will disable refining, so the output matrix will be output of robust method.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Output 2D affine transformation (4 degrees of freedom) matrix \(2 \times 3\) or
 empty matrix if transformation could not be estimated.

 The function estimates an optimal 2D affine transformation with 4 degrees of freedom limited to
 combinations of translation, rotation, and uniform scaling. Uses the selected algorithm for robust
 estimation.

 The computed transformation is then refined further (using only inliers) with the
 Levenberg-Marquardt method to reduce the re-projection error even more.

 Estimated transformation matrix is:
 \( \begin{bmatrix} \cos(\theta) \cdot s &amp; -\sin(\theta) \cdot s &amp; t_x \\
                 \sin(\theta) \cdot s &amp; \cos(\theta) \cdot s &amp; t_y
 \end{bmatrix} \)
 Where \( \theta \) is the rotation angle, \( s \) the scaling factor and \( t_x, t_y \) are
 translations in \( x, y \) axes respectively.

 <b>Note:</b>
 The RANSAC method can handle practically any ratio of outliers but need a threshold to
 distinguish inliers from outliers. The method LMeDS does not need any threshold but it works
 correctly only when there are more than 50% of inliers.

 SEE: estimateAffine2D, getAffineTransform</dd>
</dl>
</li>
</ul>
<a name="estimateAffinePartial2D-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>estimateAffinePartial2D</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;estimateAffinePartial2D(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;from,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;to,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers)</pre>
<div class="block">Computes an optimal limited affine transformation with 4 degrees of freedom between
 two 2D point sets.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>from</code> - First input 2D point set.</dd>
<dd><code>to</code> - Second input 2D point set.</dd>
<dd><code>inliers</code> - Output vector indicating which points are inliers.
 <ul>
   <li>
    REF: RANSAC - RANSAC-based robust method
   </li>
   <li>
    REF: LMEDS - Least-Median robust method
 RANSAC is the default method.
   </li>
 </ul>
 a point as an inlier. Applies only to RANSAC.
 between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation
 significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.
 Passing 0 will disable refining, so the output matrix will be output of robust method.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Output 2D affine transformation (4 degrees of freedom) matrix \(2 \times 3\) or
 empty matrix if transformation could not be estimated.

 The function estimates an optimal 2D affine transformation with 4 degrees of freedom limited to
 combinations of translation, rotation, and uniform scaling. Uses the selected algorithm for robust
 estimation.

 The computed transformation is then refined further (using only inliers) with the
 Levenberg-Marquardt method to reduce the re-projection error even more.

 Estimated transformation matrix is:
 \( \begin{bmatrix} \cos(\theta) \cdot s &amp; -\sin(\theta) \cdot s &amp; t_x \\
                 \sin(\theta) \cdot s &amp; \cos(\theta) \cdot s &amp; t_y
 \end{bmatrix} \)
 Where \( \theta \) is the rotation angle, \( s \) the scaling factor and \( t_x, t_y \) are
 translations in \( x, y \) axes respectively.

 <b>Note:</b>
 The RANSAC method can handle practically any ratio of outliers but need a threshold to
 distinguish inliers from outliers. The method LMeDS does not need any threshold but it works
 correctly only when there are more than 50% of inliers.

 SEE: estimateAffine2D, getAffineTransform</dd>
</dl>
</li>
</ul>
<a name="estimateAffinePartial2D-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>estimateAffinePartial2D</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;estimateAffinePartial2D(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;from,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;to,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers,
                                          int&nbsp;method)</pre>
<div class="block">Computes an optimal limited affine transformation with 4 degrees of freedom between
 two 2D point sets.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>from</code> - First input 2D point set.</dd>
<dd><code>to</code> - Second input 2D point set.</dd>
<dd><code>inliers</code> - Output vector indicating which points are inliers.</dd>
<dd><code>method</code> - Robust method used to compute transformation. The following methods are possible:
 <ul>
   <li>
    REF: RANSAC - RANSAC-based robust method
   </li>
   <li>
    REF: LMEDS - Least-Median robust method
 RANSAC is the default method.
   </li>
 </ul>
 a point as an inlier. Applies only to RANSAC.
 between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation
 significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.
 Passing 0 will disable refining, so the output matrix will be output of robust method.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Output 2D affine transformation (4 degrees of freedom) matrix \(2 \times 3\) or
 empty matrix if transformation could not be estimated.

 The function estimates an optimal 2D affine transformation with 4 degrees of freedom limited to
 combinations of translation, rotation, and uniform scaling. Uses the selected algorithm for robust
 estimation.

 The computed transformation is then refined further (using only inliers) with the
 Levenberg-Marquardt method to reduce the re-projection error even more.

 Estimated transformation matrix is:
 \( \begin{bmatrix} \cos(\theta) \cdot s &amp; -\sin(\theta) \cdot s &amp; t_x \\
                 \sin(\theta) \cdot s &amp; \cos(\theta) \cdot s &amp; t_y
 \end{bmatrix} \)
 Where \( \theta \) is the rotation angle, \( s \) the scaling factor and \( t_x, t_y \) are
 translations in \( x, y \) axes respectively.

 <b>Note:</b>
 The RANSAC method can handle practically any ratio of outliers but need a threshold to
 distinguish inliers from outliers. The method LMeDS does not need any threshold but it works
 correctly only when there are more than 50% of inliers.

 SEE: estimateAffine2D, getAffineTransform</dd>
</dl>
</li>
</ul>
<a name="estimateAffinePartial2D-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>estimateAffinePartial2D</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;estimateAffinePartial2D(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;from,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;to,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers,
                                          int&nbsp;method,
                                          double&nbsp;ransacReprojThreshold)</pre>
<div class="block">Computes an optimal limited affine transformation with 4 degrees of freedom between
 two 2D point sets.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>from</code> - First input 2D point set.</dd>
<dd><code>to</code> - Second input 2D point set.</dd>
<dd><code>inliers</code> - Output vector indicating which points are inliers.</dd>
<dd><code>method</code> - Robust method used to compute transformation. The following methods are possible:
 <ul>
   <li>
    REF: RANSAC - RANSAC-based robust method
   </li>
   <li>
    REF: LMEDS - Least-Median robust method
 RANSAC is the default method.
   </li>
 </ul></dd>
<dd><code>ransacReprojThreshold</code> - Maximum reprojection error in the RANSAC algorithm to consider
 a point as an inlier. Applies only to RANSAC.
 between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation
 significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.
 Passing 0 will disable refining, so the output matrix will be output of robust method.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Output 2D affine transformation (4 degrees of freedom) matrix \(2 \times 3\) or
 empty matrix if transformation could not be estimated.

 The function estimates an optimal 2D affine transformation with 4 degrees of freedom limited to
 combinations of translation, rotation, and uniform scaling. Uses the selected algorithm for robust
 estimation.

 The computed transformation is then refined further (using only inliers) with the
 Levenberg-Marquardt method to reduce the re-projection error even more.

 Estimated transformation matrix is:
 \( \begin{bmatrix} \cos(\theta) \cdot s &amp; -\sin(\theta) \cdot s &amp; t_x \\
                 \sin(\theta) \cdot s &amp; \cos(\theta) \cdot s &amp; t_y
 \end{bmatrix} \)
 Where \( \theta \) is the rotation angle, \( s \) the scaling factor and \( t_x, t_y \) are
 translations in \( x, y \) axes respectively.

 <b>Note:</b>
 The RANSAC method can handle practically any ratio of outliers but need a threshold to
 distinguish inliers from outliers. The method LMeDS does not need any threshold but it works
 correctly only when there are more than 50% of inliers.

 SEE: estimateAffine2D, getAffineTransform</dd>
</dl>
</li>
</ul>
<a name="estimateAffinePartial2D-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-double-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>estimateAffinePartial2D</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;estimateAffinePartial2D(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;from,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;to,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers,
                                          int&nbsp;method,
                                          double&nbsp;ransacReprojThreshold,
                                          long&nbsp;maxIters)</pre>
<div class="block">Computes an optimal limited affine transformation with 4 degrees of freedom between
 two 2D point sets.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>from</code> - First input 2D point set.</dd>
<dd><code>to</code> - Second input 2D point set.</dd>
<dd><code>inliers</code> - Output vector indicating which points are inliers.</dd>
<dd><code>method</code> - Robust method used to compute transformation. The following methods are possible:
 <ul>
   <li>
    REF: RANSAC - RANSAC-based robust method
   </li>
   <li>
    REF: LMEDS - Least-Median robust method
 RANSAC is the default method.
   </li>
 </ul></dd>
<dd><code>ransacReprojThreshold</code> - Maximum reprojection error in the RANSAC algorithm to consider
 a point as an inlier. Applies only to RANSAC.</dd>
<dd><code>maxIters</code> - The maximum number of robust method iterations.
 between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation
 significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.
 Passing 0 will disable refining, so the output matrix will be output of robust method.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Output 2D affine transformation (4 degrees of freedom) matrix \(2 \times 3\) or
 empty matrix if transformation could not be estimated.

 The function estimates an optimal 2D affine transformation with 4 degrees of freedom limited to
 combinations of translation, rotation, and uniform scaling. Uses the selected algorithm for robust
 estimation.

 The computed transformation is then refined further (using only inliers) with the
 Levenberg-Marquardt method to reduce the re-projection error even more.

 Estimated transformation matrix is:
 \( \begin{bmatrix} \cos(\theta) \cdot s &amp; -\sin(\theta) \cdot s &amp; t_x \\
                 \sin(\theta) \cdot s &amp; \cos(\theta) \cdot s &amp; t_y
 \end{bmatrix} \)
 Where \( \theta \) is the rotation angle, \( s \) the scaling factor and \( t_x, t_y \) are
 translations in \( x, y \) axes respectively.

 <b>Note:</b>
 The RANSAC method can handle practically any ratio of outliers but need a threshold to
 distinguish inliers from outliers. The method LMeDS does not need any threshold but it works
 correctly only when there are more than 50% of inliers.

 SEE: estimateAffine2D, getAffineTransform</dd>
</dl>
</li>
</ul>
<a name="estimateAffinePartial2D-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-double-long-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>estimateAffinePartial2D</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;estimateAffinePartial2D(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;from,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;to,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers,
                                          int&nbsp;method,
                                          double&nbsp;ransacReprojThreshold,
                                          long&nbsp;maxIters,
                                          double&nbsp;confidence)</pre>
<div class="block">Computes an optimal limited affine transformation with 4 degrees of freedom between
 two 2D point sets.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>from</code> - First input 2D point set.</dd>
<dd><code>to</code> - Second input 2D point set.</dd>
<dd><code>inliers</code> - Output vector indicating which points are inliers.</dd>
<dd><code>method</code> - Robust method used to compute transformation. The following methods are possible:
 <ul>
   <li>
    REF: RANSAC - RANSAC-based robust method
   </li>
   <li>
    REF: LMEDS - Least-Median robust method
 RANSAC is the default method.
   </li>
 </ul></dd>
<dd><code>ransacReprojThreshold</code> - Maximum reprojection error in the RANSAC algorithm to consider
 a point as an inlier. Applies only to RANSAC.</dd>
<dd><code>maxIters</code> - The maximum number of robust method iterations.</dd>
<dd><code>confidence</code> - Confidence level, between 0 and 1, for the estimated transformation. Anything
 between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation
 significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.
 Passing 0 will disable refining, so the output matrix will be output of robust method.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Output 2D affine transformation (4 degrees of freedom) matrix \(2 \times 3\) or
 empty matrix if transformation could not be estimated.

 The function estimates an optimal 2D affine transformation with 4 degrees of freedom limited to
 combinations of translation, rotation, and uniform scaling. Uses the selected algorithm for robust
 estimation.

 The computed transformation is then refined further (using only inliers) with the
 Levenberg-Marquardt method to reduce the re-projection error even more.

 Estimated transformation matrix is:
 \( \begin{bmatrix} \cos(\theta) \cdot s &amp; -\sin(\theta) \cdot s &amp; t_x \\
                 \sin(\theta) \cdot s &amp; \cos(\theta) \cdot s &amp; t_y
 \end{bmatrix} \)
 Where \( \theta \) is the rotation angle, \( s \) the scaling factor and \( t_x, t_y \) are
 translations in \( x, y \) axes respectively.

 <b>Note:</b>
 The RANSAC method can handle practically any ratio of outliers but need a threshold to
 distinguish inliers from outliers. The method LMeDS does not need any threshold but it works
 correctly only when there are more than 50% of inliers.

 SEE: estimateAffine2D, getAffineTransform</dd>
</dl>
</li>
</ul>
<a name="estimateAffinePartial2D-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-double-long-double-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>estimateAffinePartial2D</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;estimateAffinePartial2D(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;from,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;to,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers,
                                          int&nbsp;method,
                                          double&nbsp;ransacReprojThreshold,
                                          long&nbsp;maxIters,
                                          double&nbsp;confidence,
                                          long&nbsp;refineIters)</pre>
<div class="block">Computes an optimal limited affine transformation with 4 degrees of freedom between
 two 2D point sets.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>from</code> - First input 2D point set.</dd>
<dd><code>to</code> - Second input 2D point set.</dd>
<dd><code>inliers</code> - Output vector indicating which points are inliers.</dd>
<dd><code>method</code> - Robust method used to compute transformation. The following methods are possible:
 <ul>
   <li>
    REF: RANSAC - RANSAC-based robust method
   </li>
   <li>
    REF: LMEDS - Least-Median robust method
 RANSAC is the default method.
   </li>
 </ul></dd>
<dd><code>ransacReprojThreshold</code> - Maximum reprojection error in the RANSAC algorithm to consider
 a point as an inlier. Applies only to RANSAC.</dd>
<dd><code>maxIters</code> - The maximum number of robust method iterations.</dd>
<dd><code>confidence</code> - Confidence level, between 0 and 1, for the estimated transformation. Anything
 between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation
 significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.</dd>
<dd><code>refineIters</code> - Maximum number of iterations of refining algorithm (Levenberg-Marquardt).
 Passing 0 will disable refining, so the output matrix will be output of robust method.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Output 2D affine transformation (4 degrees of freedom) matrix \(2 \times 3\) or
 empty matrix if transformation could not be estimated.

 The function estimates an optimal 2D affine transformation with 4 degrees of freedom limited to
 combinations of translation, rotation, and uniform scaling. Uses the selected algorithm for robust
 estimation.

 The computed transformation is then refined further (using only inliers) with the
 Levenberg-Marquardt method to reduce the re-projection error even more.

 Estimated transformation matrix is:
 \( \begin{bmatrix} \cos(\theta) \cdot s &amp; -\sin(\theta) \cdot s &amp; t_x \\
                 \sin(\theta) \cdot s &amp; \cos(\theta) \cdot s &amp; t_y
 \end{bmatrix} \)
 Where \( \theta \) is the rotation angle, \( s \) the scaling factor and \( t_x, t_y \) are
 translations in \( x, y \) axes respectively.

 <b>Note:</b>
 The RANSAC method can handle practically any ratio of outliers but need a threshold to
 distinguish inliers from outliers. The method LMeDS does not need any threshold but it works
 correctly only when there are more than 50% of inliers.

 SEE: estimateAffine2D, getAffineTransform</dd>
</dl>
</li>
</ul>
<a name="estimateTranslation3D-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>estimateTranslation3D</h4>
<pre>public static&nbsp;int&nbsp;estimateTranslation3D(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;out,
                                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers)</pre>
<div class="block">Computes an optimal translation between two 3D point sets.

 It computes
 \(
 \begin{bmatrix}
 x\\
 y\\
 z\\
 \end{bmatrix}
 =
 \begin{bmatrix}
 X\\
 Y\\
 Z\\
 \end{bmatrix}
 +
 \begin{bmatrix}
 b_1\\
 b_2\\
 b_3\\
 \end{bmatrix}
 \)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - First input 3D point set containing \((X,Y,Z)\).</dd>
<dd><code>dst</code> - Second input 3D point set containing \((x,y,z)\).</dd>
<dd><code>out</code> - Output 3D translation vector \(3 \times 1\) of the form
 \(
 \begin{bmatrix}
 b_1 \\
 b_2 \\
 b_3 \\
 \end{bmatrix}
 \)</dd>
<dd><code>inliers</code> - Output vector indicating which points are inliers (1-inlier, 0-outlier).
 an inlier.
 between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation
 significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.

 The function estimates an optimal 3D translation between two 3D point sets using the
 RANSAC algorithm.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="estimateTranslation3D-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>estimateTranslation3D</h4>
<pre>public static&nbsp;int&nbsp;estimateTranslation3D(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;out,
                                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers,
                                        double&nbsp;ransacThreshold)</pre>
<div class="block">Computes an optimal translation between two 3D point sets.

 It computes
 \(
 \begin{bmatrix}
 x\\
 y\\
 z\\
 \end{bmatrix}
 =
 \begin{bmatrix}
 X\\
 Y\\
 Z\\
 \end{bmatrix}
 +
 \begin{bmatrix}
 b_1\\
 b_2\\
 b_3\\
 \end{bmatrix}
 \)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - First input 3D point set containing \((X,Y,Z)\).</dd>
<dd><code>dst</code> - Second input 3D point set containing \((x,y,z)\).</dd>
<dd><code>out</code> - Output 3D translation vector \(3 \times 1\) of the form
 \(
 \begin{bmatrix}
 b_1 \\
 b_2 \\
 b_3 \\
 \end{bmatrix}
 \)</dd>
<dd><code>inliers</code> - Output vector indicating which points are inliers (1-inlier, 0-outlier).</dd>
<dd><code>ransacThreshold</code> - Maximum reprojection error in the RANSAC algorithm to consider a point as
 an inlier.
 between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation
 significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.

 The function estimates an optimal 3D translation between two 3D point sets using the
 RANSAC algorithm.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="estimateTranslation3D-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>estimateTranslation3D</h4>
<pre>public static&nbsp;int&nbsp;estimateTranslation3D(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;out,
                                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers,
                                        double&nbsp;ransacThreshold,
                                        double&nbsp;confidence)</pre>
<div class="block">Computes an optimal translation between two 3D point sets.

 It computes
 \(
 \begin{bmatrix}
 x\\
 y\\
 z\\
 \end{bmatrix}
 =
 \begin{bmatrix}
 X\\
 Y\\
 Z\\
 \end{bmatrix}
 +
 \begin{bmatrix}
 b_1\\
 b_2\\
 b_3\\
 \end{bmatrix}
 \)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - First input 3D point set containing \((X,Y,Z)\).</dd>
<dd><code>dst</code> - Second input 3D point set containing \((x,y,z)\).</dd>
<dd><code>out</code> - Output 3D translation vector \(3 \times 1\) of the form
 \(
 \begin{bmatrix}
 b_1 \\
 b_2 \\
 b_3 \\
 \end{bmatrix}
 \)</dd>
<dd><code>inliers</code> - Output vector indicating which points are inliers (1-inlier, 0-outlier).</dd>
<dd><code>ransacThreshold</code> - Maximum reprojection error in the RANSAC algorithm to consider a point as
 an inlier.</dd>
<dd><code>confidence</code> - Confidence level, between 0 and 1, for the estimated transformation. Anything
 between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation
 significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.

 The function estimates an optimal 3D translation between two 3D point sets using the
 RANSAC algorithm.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="filterHomographyDecompByVisibleRefpoints-java.util.List-java.util.List-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filterHomographyDecompByVisibleRefpoints</h4>
<pre>public static&nbsp;void&nbsp;filterHomographyDecompByVisibleRefpoints(java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;rotations,
                                                            java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;normals,
                                                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;beforePoints,
                                                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;afterPoints,
                                                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;possibleSolutions)</pre>
<div class="block">Filters homography decompositions based on additional information.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>rotations</code> - Vector of rotation matrices.</dd>
<dd><code>normals</code> - Vector of plane normal matrices.</dd>
<dd><code>beforePoints</code> - Vector of (rectified) visible reference points before the homography is applied</dd>
<dd><code>afterPoints</code> - Vector of (rectified) visible reference points after the homography is applied</dd>
<dd><code>possibleSolutions</code> - Vector of int indices representing the viable solution set after filtering

 This function is intended to filter the output of the #decomposeHomographyMat based on additional
 information as described in CITE: Malis2007 . The summary of the method: the #decomposeHomographyMat function
 returns 2 unique solutions and their "opposites" for a total of 4 solutions. If we have access to the
 sets of points visible in the camera frame before and after the homography transformation is applied,
 we can determine which are the true potential solutions and which are the opposites by verifying which
 homographies are consistent with all visible reference points being in front of the camera. The inputs
 are left unchanged; the filtered solution set is returned as indices into the existing one.</dd>
</dl>
</li>
</ul>
<a name="filterHomographyDecompByVisibleRefpoints-java.util.List-java.util.List-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filterHomographyDecompByVisibleRefpoints</h4>
<pre>public static&nbsp;void&nbsp;filterHomographyDecompByVisibleRefpoints(java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;rotations,
                                                            java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;normals,
                                                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;beforePoints,
                                                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;afterPoints,
                                                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;possibleSolutions,
                                                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;pointsMask)</pre>
<div class="block">Filters homography decompositions based on additional information.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>rotations</code> - Vector of rotation matrices.</dd>
<dd><code>normals</code> - Vector of plane normal matrices.</dd>
<dd><code>beforePoints</code> - Vector of (rectified) visible reference points before the homography is applied</dd>
<dd><code>afterPoints</code> - Vector of (rectified) visible reference points after the homography is applied</dd>
<dd><code>possibleSolutions</code> - Vector of int indices representing the viable solution set after filtering</dd>
<dd><code>pointsMask</code> - optional Mat/Vector of 8u type representing the mask for the inliers as given by the #findHomography function

 This function is intended to filter the output of the #decomposeHomographyMat based on additional
 information as described in CITE: Malis2007 . The summary of the method: the #decomposeHomographyMat function
 returns 2 unique solutions and their "opposites" for a total of 4 solutions. If we have access to the
 sets of points visible in the camera frame before and after the homography transformation is applied,
 we can determine which are the true potential solutions and which are the opposites by verifying which
 homographies are consistent with all visible reference points being in front of the camera. The inputs
 are left unchanged; the filtered solution set is returned as indices into the existing one.</dd>
</dl>
</li>
</ul>
<a name="findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findEssentialMat</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;findEssentialMat(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - Array of N (N &gt;= 5) 2D points from the first image. The point coordinates should
 be floating-point (single or double precision).</dd>
<dd><code>points2</code> - Array of the second image points of the same size and format as points1 .
 are feature points from cameras with same focal length and principal point.
 <ul>
   <li>
    REF: RANSAC for the RANSAC algorithm.
   </li>
   <li>
    REF: LMEDS for the LMedS algorithm.
   </li>
 </ul>
 line in pixels, beyond which the point is considered an outlier and is not used for computing the
 final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the
 point localization, image resolution, and the image noise.
 confidence (probability) that the estimated matrix is correct.
 for the other points. The array is computed only in the RANSAC and LMedS methods.

 This function differs from the one above that it computes camera intrinsic matrix from focal length and
 principal point:

 \(A =
 \begin{bmatrix}
 f &amp; 0 &amp; x_{pp}  \\
 0 &amp; f &amp; y_{pp}  \\
 0 &amp; 0 &amp; 1
 \end{bmatrix}\)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findEssentialMat</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;findEssentialMat(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                                   double&nbsp;focal)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - Array of N (N &gt;= 5) 2D points from the first image. The point coordinates should
 be floating-point (single or double precision).</dd>
<dd><code>points2</code> - Array of the second image points of the same size and format as points1 .</dd>
<dd><code>focal</code> - focal length of the camera. Note that this function assumes that points1 and points2
 are feature points from cameras with same focal length and principal point.
 <ul>
   <li>
    REF: RANSAC for the RANSAC algorithm.
   </li>
   <li>
    REF: LMEDS for the LMedS algorithm.
   </li>
 </ul>
 line in pixels, beyond which the point is considered an outlier and is not used for computing the
 final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the
 point localization, image resolution, and the image noise.
 confidence (probability) that the estimated matrix is correct.
 for the other points. The array is computed only in the RANSAC and LMedS methods.

 This function differs from the one above that it computes camera intrinsic matrix from focal length and
 principal point:

 \(A =
 \begin{bmatrix}
 f &amp; 0 &amp; x_{pp}  \\
 0 &amp; f &amp; y_{pp}  \\
 0 &amp; 0 &amp; 1
 \end{bmatrix}\)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-double-org.opencv.core.Point-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findEssentialMat</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;findEssentialMat(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                                   double&nbsp;focal,
                                   <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pp)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - Array of N (N &gt;= 5) 2D points from the first image. The point coordinates should
 be floating-point (single or double precision).</dd>
<dd><code>points2</code> - Array of the second image points of the same size and format as points1 .</dd>
<dd><code>focal</code> - focal length of the camera. Note that this function assumes that points1 and points2
 are feature points from cameras with same focal length and principal point.</dd>
<dd><code>pp</code> - principal point of the camera.
 <ul>
   <li>
    REF: RANSAC for the RANSAC algorithm.
   </li>
   <li>
    REF: LMEDS for the LMedS algorithm.
   </li>
 </ul>
 line in pixels, beyond which the point is considered an outlier and is not used for computing the
 final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the
 point localization, image resolution, and the image noise.
 confidence (probability) that the estimated matrix is correct.
 for the other points. The array is computed only in the RANSAC and LMedS methods.

 This function differs from the one above that it computes camera intrinsic matrix from focal length and
 principal point:

 \(A =
 \begin{bmatrix}
 f &amp; 0 &amp; x_{pp}  \\
 0 &amp; f &amp; y_{pp}  \\
 0 &amp; 0 &amp; 1
 \end{bmatrix}\)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-double-org.opencv.core.Point-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findEssentialMat</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;findEssentialMat(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                                   double&nbsp;focal,
                                   <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pp,
                                   int&nbsp;method)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - Array of N (N &gt;= 5) 2D points from the first image. The point coordinates should
 be floating-point (single or double precision).</dd>
<dd><code>points2</code> - Array of the second image points of the same size and format as points1 .</dd>
<dd><code>focal</code> - focal length of the camera. Note that this function assumes that points1 and points2
 are feature points from cameras with same focal length and principal point.</dd>
<dd><code>pp</code> - principal point of the camera.</dd>
<dd><code>method</code> - Method for computing a fundamental matrix.
 <ul>
   <li>
    REF: RANSAC for the RANSAC algorithm.
   </li>
   <li>
    REF: LMEDS for the LMedS algorithm.
   </li>
 </ul>
 line in pixels, beyond which the point is considered an outlier and is not used for computing the
 final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the
 point localization, image resolution, and the image noise.
 confidence (probability) that the estimated matrix is correct.
 for the other points. The array is computed only in the RANSAC and LMedS methods.

 This function differs from the one above that it computes camera intrinsic matrix from focal length and
 principal point:

 \(A =
 \begin{bmatrix}
 f &amp; 0 &amp; x_{pp}  \\
 0 &amp; f &amp; y_{pp}  \\
 0 &amp; 0 &amp; 1
 \end{bmatrix}\)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-double-org.opencv.core.Point-int-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findEssentialMat</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;findEssentialMat(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                                   double&nbsp;focal,
                                   <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pp,
                                   int&nbsp;method,
                                   double&nbsp;prob)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - Array of N (N &gt;= 5) 2D points from the first image. The point coordinates should
 be floating-point (single or double precision).</dd>
<dd><code>points2</code> - Array of the second image points of the same size and format as points1 .</dd>
<dd><code>focal</code> - focal length of the camera. Note that this function assumes that points1 and points2
 are feature points from cameras with same focal length and principal point.</dd>
<dd><code>pp</code> - principal point of the camera.</dd>
<dd><code>method</code> - Method for computing a fundamental matrix.
 <ul>
   <li>
    REF: RANSAC for the RANSAC algorithm.
   </li>
   <li>
    REF: LMEDS for the LMedS algorithm.
   </li>
 </ul>
 line in pixels, beyond which the point is considered an outlier and is not used for computing the
 final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the
 point localization, image resolution, and the image noise.</dd>
<dd><code>prob</code> - Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of
 confidence (probability) that the estimated matrix is correct.
 for the other points. The array is computed only in the RANSAC and LMedS methods.

 This function differs from the one above that it computes camera intrinsic matrix from focal length and
 principal point:

 \(A =
 \begin{bmatrix}
 f &amp; 0 &amp; x_{pp}  \\
 0 &amp; f &amp; y_{pp}  \\
 0 &amp; 0 &amp; 1
 \end{bmatrix}\)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-double-org.opencv.core.Point-int-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findEssentialMat</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;findEssentialMat(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                                   double&nbsp;focal,
                                   <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pp,
                                   int&nbsp;method,
                                   double&nbsp;prob,
                                   double&nbsp;threshold)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - Array of N (N &gt;= 5) 2D points from the first image. The point coordinates should
 be floating-point (single or double precision).</dd>
<dd><code>points2</code> - Array of the second image points of the same size and format as points1 .</dd>
<dd><code>focal</code> - focal length of the camera. Note that this function assumes that points1 and points2
 are feature points from cameras with same focal length and principal point.</dd>
<dd><code>pp</code> - principal point of the camera.</dd>
<dd><code>method</code> - Method for computing a fundamental matrix.
 <ul>
   <li>
    REF: RANSAC for the RANSAC algorithm.
   </li>
   <li>
    REF: LMEDS for the LMedS algorithm.
   </li>
 </ul></dd>
<dd><code>threshold</code> - Parameter used for RANSAC. It is the maximum distance from a point to an epipolar
 line in pixels, beyond which the point is considered an outlier and is not used for computing the
 final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the
 point localization, image resolution, and the image noise.</dd>
<dd><code>prob</code> - Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of
 confidence (probability) that the estimated matrix is correct.
 for the other points. The array is computed only in the RANSAC and LMedS methods.

 This function differs from the one above that it computes camera intrinsic matrix from focal length and
 principal point:

 \(A =
 \begin{bmatrix}
 f &amp; 0 &amp; x_{pp}  \\
 0 &amp; f &amp; y_{pp}  \\
 0 &amp; 0 &amp; 1
 \end{bmatrix}\)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-double-org.opencv.core.Point-int-double-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findEssentialMat</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;findEssentialMat(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                                   double&nbsp;focal,
                                   <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pp,
                                   int&nbsp;method,
                                   double&nbsp;prob,
                                   double&nbsp;threshold,
                                   int&nbsp;maxIters)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - Array of N (N &gt;= 5) 2D points from the first image. The point coordinates should
 be floating-point (single or double precision).</dd>
<dd><code>points2</code> - Array of the second image points of the same size and format as points1 .</dd>
<dd><code>focal</code> - focal length of the camera. Note that this function assumes that points1 and points2
 are feature points from cameras with same focal length and principal point.</dd>
<dd><code>pp</code> - principal point of the camera.</dd>
<dd><code>method</code> - Method for computing a fundamental matrix.
 <ul>
   <li>
    REF: RANSAC for the RANSAC algorithm.
   </li>
   <li>
    REF: LMEDS for the LMedS algorithm.
   </li>
 </ul></dd>
<dd><code>threshold</code> - Parameter used for RANSAC. It is the maximum distance from a point to an epipolar
 line in pixels, beyond which the point is considered an outlier and is not used for computing the
 final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the
 point localization, image resolution, and the image noise.</dd>
<dd><code>prob</code> - Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of
 confidence (probability) that the estimated matrix is correct.
 for the other points. The array is computed only in the RANSAC and LMedS methods.</dd>
<dd><code>maxIters</code> - The maximum number of robust method iterations.

 This function differs from the one above that it computes camera intrinsic matrix from focal length and
 principal point:

 \(A =
 \begin{bmatrix}
 f &amp; 0 &amp; x_{pp}  \\
 0 &amp; f &amp; y_{pp}  \\
 0 &amp; 0 &amp; 1
 \end{bmatrix}\)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-double-org.opencv.core.Point-int-double-double-int-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findEssentialMat</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;findEssentialMat(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                                   double&nbsp;focal,
                                   <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pp,
                                   int&nbsp;method,
                                   double&nbsp;prob,
                                   double&nbsp;threshold,
                                   int&nbsp;maxIters,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - Array of N (N &gt;= 5) 2D points from the first image. The point coordinates should
 be floating-point (single or double precision).</dd>
<dd><code>points2</code> - Array of the second image points of the same size and format as points1 .</dd>
<dd><code>focal</code> - focal length of the camera. Note that this function assumes that points1 and points2
 are feature points from cameras with same focal length and principal point.</dd>
<dd><code>pp</code> - principal point of the camera.</dd>
<dd><code>method</code> - Method for computing a fundamental matrix.
 <ul>
   <li>
    REF: RANSAC for the RANSAC algorithm.
   </li>
   <li>
    REF: LMEDS for the LMedS algorithm.
   </li>
 </ul></dd>
<dd><code>threshold</code> - Parameter used for RANSAC. It is the maximum distance from a point to an epipolar
 line in pixels, beyond which the point is considered an outlier and is not used for computing the
 final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the
 point localization, image resolution, and the image noise.</dd>
<dd><code>prob</code> - Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of
 confidence (probability) that the estimated matrix is correct.</dd>
<dd><code>mask</code> - Output array of N elements, every element of which is set to 0 for outliers and to 1
 for the other points. The array is computed only in the RANSAC and LMedS methods.</dd>
<dd><code>maxIters</code> - The maximum number of robust method iterations.

 This function differs from the one above that it computes camera intrinsic matrix from focal length and
 principal point:

 \(A =
 \begin{bmatrix}
 f &amp; 0 &amp; x_{pp}  \\
 0 &amp; f &amp; y_{pp}  \\
 0 &amp; 0 &amp; 1
 \end{bmatrix}\)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findEssentialMat</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;findEssentialMat(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix)</pre>
<div class="block">Calculates an essential matrix from the corresponding points in two images.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - Array of N (N &gt;= 5) 2D points from the first image. The point coordinates should
 be floating-point (single or double precision).</dd>
<dd><code>points2</code> - Array of the second image points of the same size and format as points1.</dd>
<dd><code>cameraMatrix</code> - Camera intrinsic matrix \(\cameramatrix{A}\) .
 Note that this function assumes that points1 and points2 are feature points from cameras with the
 same camera intrinsic matrix. If this assumption does not hold for your use case, use another
 function overload or #undistortPoints with <code>P = cv::NoArray()</code> for both cameras to transform image
 points to normalized image coordinates, which are valid for the identity camera intrinsic matrix.
 When passing these coordinates, pass the identity matrix for this parameter.
 <ul>
   <li>
    REF: RANSAC for the RANSAC algorithm.
   </li>
   <li>
    REF: LMEDS for the LMedS algorithm.
   </li>
 </ul>
 confidence (probability) that the estimated matrix is correct.
 line in pixels, beyond which the point is considered an outlier and is not used for computing the
 final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the
 point localization, image resolution, and the image noise.
 for the other points. The array is computed only in the RANSAC and LMedS methods.

 This function estimates essential matrix based on the five-point algorithm solver in CITE: Nister03 .
 CITE: SteweniusCFS is also a related. The epipolar geometry is described by the following equation:

 \([p_2; 1]^T K^{-T} E K^{-1} [p_1; 1] = 0\)

 where \(E\) is an essential matrix, \(p_1\) and \(p_2\) are corresponding points in the first and the
 second images, respectively. The result of this function may be passed further to
 #decomposeEssentialMat or #recoverPose to recover the relative pose between cameras.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findEssentialMat</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;findEssentialMat(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                   int&nbsp;method)</pre>
<div class="block">Calculates an essential matrix from the corresponding points in two images.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - Array of N (N &gt;= 5) 2D points from the first image. The point coordinates should
 be floating-point (single or double precision).</dd>
<dd><code>points2</code> - Array of the second image points of the same size and format as points1.</dd>
<dd><code>cameraMatrix</code> - Camera intrinsic matrix \(\cameramatrix{A}\) .
 Note that this function assumes that points1 and points2 are feature points from cameras with the
 same camera intrinsic matrix. If this assumption does not hold for your use case, use another
 function overload or #undistortPoints with <code>P = cv::NoArray()</code> for both cameras to transform image
 points to normalized image coordinates, which are valid for the identity camera intrinsic matrix.
 When passing these coordinates, pass the identity matrix for this parameter.</dd>
<dd><code>method</code> - Method for computing an essential matrix.
 <ul>
   <li>
    REF: RANSAC for the RANSAC algorithm.
   </li>
   <li>
    REF: LMEDS for the LMedS algorithm.
   </li>
 </ul>
 confidence (probability) that the estimated matrix is correct.
 line in pixels, beyond which the point is considered an outlier and is not used for computing the
 final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the
 point localization, image resolution, and the image noise.
 for the other points. The array is computed only in the RANSAC and LMedS methods.

 This function estimates essential matrix based on the five-point algorithm solver in CITE: Nister03 .
 CITE: SteweniusCFS is also a related. The epipolar geometry is described by the following equation:

 \([p_2; 1]^T K^{-T} E K^{-1} [p_1; 1] = 0\)

 where \(E\) is an essential matrix, \(p_1\) and \(p_2\) are corresponding points in the first and the
 second images, respectively. The result of this function may be passed further to
 #decomposeEssentialMat or #recoverPose to recover the relative pose between cameras.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findEssentialMat</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;findEssentialMat(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                   int&nbsp;method,
                                   double&nbsp;prob)</pre>
<div class="block">Calculates an essential matrix from the corresponding points in two images.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - Array of N (N &gt;= 5) 2D points from the first image. The point coordinates should
 be floating-point (single or double precision).</dd>
<dd><code>points2</code> - Array of the second image points of the same size and format as points1.</dd>
<dd><code>cameraMatrix</code> - Camera intrinsic matrix \(\cameramatrix{A}\) .
 Note that this function assumes that points1 and points2 are feature points from cameras with the
 same camera intrinsic matrix. If this assumption does not hold for your use case, use another
 function overload or #undistortPoints with <code>P = cv::NoArray()</code> for both cameras to transform image
 points to normalized image coordinates, which are valid for the identity camera intrinsic matrix.
 When passing these coordinates, pass the identity matrix for this parameter.</dd>
<dd><code>method</code> - Method for computing an essential matrix.
 <ul>
   <li>
    REF: RANSAC for the RANSAC algorithm.
   </li>
   <li>
    REF: LMEDS for the LMedS algorithm.
   </li>
 </ul></dd>
<dd><code>prob</code> - Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of
 confidence (probability) that the estimated matrix is correct.
 line in pixels, beyond which the point is considered an outlier and is not used for computing the
 final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the
 point localization, image resolution, and the image noise.
 for the other points. The array is computed only in the RANSAC and LMedS methods.

 This function estimates essential matrix based on the five-point algorithm solver in CITE: Nister03 .
 CITE: SteweniusCFS is also a related. The epipolar geometry is described by the following equation:

 \([p_2; 1]^T K^{-T} E K^{-1} [p_1; 1] = 0\)

 where \(E\) is an essential matrix, \(p_1\) and \(p_2\) are corresponding points in the first and the
 second images, respectively. The result of this function may be passed further to
 #decomposeEssentialMat or #recoverPose to recover the relative pose between cameras.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findEssentialMat</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;findEssentialMat(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                   int&nbsp;method,
                                   double&nbsp;prob,
                                   double&nbsp;threshold)</pre>
<div class="block">Calculates an essential matrix from the corresponding points in two images.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - Array of N (N &gt;= 5) 2D points from the first image. The point coordinates should
 be floating-point (single or double precision).</dd>
<dd><code>points2</code> - Array of the second image points of the same size and format as points1.</dd>
<dd><code>cameraMatrix</code> - Camera intrinsic matrix \(\cameramatrix{A}\) .
 Note that this function assumes that points1 and points2 are feature points from cameras with the
 same camera intrinsic matrix. If this assumption does not hold for your use case, use another
 function overload or #undistortPoints with <code>P = cv::NoArray()</code> for both cameras to transform image
 points to normalized image coordinates, which are valid for the identity camera intrinsic matrix.
 When passing these coordinates, pass the identity matrix for this parameter.</dd>
<dd><code>method</code> - Method for computing an essential matrix.
 <ul>
   <li>
    REF: RANSAC for the RANSAC algorithm.
   </li>
   <li>
    REF: LMEDS for the LMedS algorithm.
   </li>
 </ul></dd>
<dd><code>prob</code> - Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of
 confidence (probability) that the estimated matrix is correct.</dd>
<dd><code>threshold</code> - Parameter used for RANSAC. It is the maximum distance from a point to an epipolar
 line in pixels, beyond which the point is considered an outlier and is not used for computing the
 final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the
 point localization, image resolution, and the image noise.
 for the other points. The array is computed only in the RANSAC and LMedS methods.

 This function estimates essential matrix based on the five-point algorithm solver in CITE: Nister03 .
 CITE: SteweniusCFS is also a related. The epipolar geometry is described by the following equation:

 \([p_2; 1]^T K^{-T} E K^{-1} [p_1; 1] = 0\)

 where \(E\) is an essential matrix, \(p_1\) and \(p_2\) are corresponding points in the first and the
 second images, respectively. The result of this function may be passed further to
 #decomposeEssentialMat or #recoverPose to recover the relative pose between cameras.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findEssentialMat</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;findEssentialMat(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                   int&nbsp;method,
                                   double&nbsp;prob,
                                   double&nbsp;threshold,
                                   int&nbsp;maxIters)</pre>
<div class="block">Calculates an essential matrix from the corresponding points in two images.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - Array of N (N &gt;= 5) 2D points from the first image. The point coordinates should
 be floating-point (single or double precision).</dd>
<dd><code>points2</code> - Array of the second image points of the same size and format as points1.</dd>
<dd><code>cameraMatrix</code> - Camera intrinsic matrix \(\cameramatrix{A}\) .
 Note that this function assumes that points1 and points2 are feature points from cameras with the
 same camera intrinsic matrix. If this assumption does not hold for your use case, use another
 function overload or #undistortPoints with <code>P = cv::NoArray()</code> for both cameras to transform image
 points to normalized image coordinates, which are valid for the identity camera intrinsic matrix.
 When passing these coordinates, pass the identity matrix for this parameter.</dd>
<dd><code>method</code> - Method for computing an essential matrix.
 <ul>
   <li>
    REF: RANSAC for the RANSAC algorithm.
   </li>
   <li>
    REF: LMEDS for the LMedS algorithm.
   </li>
 </ul></dd>
<dd><code>prob</code> - Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of
 confidence (probability) that the estimated matrix is correct.</dd>
<dd><code>threshold</code> - Parameter used for RANSAC. It is the maximum distance from a point to an epipolar
 line in pixels, beyond which the point is considered an outlier and is not used for computing the
 final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the
 point localization, image resolution, and the image noise.
 for the other points. The array is computed only in the RANSAC and LMedS methods.</dd>
<dd><code>maxIters</code> - The maximum number of robust method iterations.

 This function estimates essential matrix based on the five-point algorithm solver in CITE: Nister03 .
 CITE: SteweniusCFS is also a related. The epipolar geometry is described by the following equation:

 \([p_2; 1]^T K^{-T} E K^{-1} [p_1; 1] = 0\)

 where \(E\) is an essential matrix, \(p_1\) and \(p_2\) are corresponding points in the first and the
 second images, respectively. The result of this function may be passed further to
 #decomposeEssentialMat or #recoverPose to recover the relative pose between cameras.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-int-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findEssentialMat</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;findEssentialMat(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                   int&nbsp;method,
                                   double&nbsp;prob,
                                   double&nbsp;threshold,
                                   int&nbsp;maxIters,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
<div class="block">Calculates an essential matrix from the corresponding points in two images.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - Array of N (N &gt;= 5) 2D points from the first image. The point coordinates should
 be floating-point (single or double precision).</dd>
<dd><code>points2</code> - Array of the second image points of the same size and format as points1.</dd>
<dd><code>cameraMatrix</code> - Camera intrinsic matrix \(\cameramatrix{A}\) .
 Note that this function assumes that points1 and points2 are feature points from cameras with the
 same camera intrinsic matrix. If this assumption does not hold for your use case, use another
 function overload or #undistortPoints with <code>P = cv::NoArray()</code> for both cameras to transform image
 points to normalized image coordinates, which are valid for the identity camera intrinsic matrix.
 When passing these coordinates, pass the identity matrix for this parameter.</dd>
<dd><code>method</code> - Method for computing an essential matrix.
 <ul>
   <li>
    REF: RANSAC for the RANSAC algorithm.
   </li>
   <li>
    REF: LMEDS for the LMedS algorithm.
   </li>
 </ul></dd>
<dd><code>prob</code> - Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of
 confidence (probability) that the estimated matrix is correct.</dd>
<dd><code>threshold</code> - Parameter used for RANSAC. It is the maximum distance from a point to an epipolar
 line in pixels, beyond which the point is considered an outlier and is not used for computing the
 final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the
 point localization, image resolution, and the image noise.</dd>
<dd><code>mask</code> - Output array of N elements, every element of which is set to 0 for outliers and to 1
 for the other points. The array is computed only in the RANSAC and LMedS methods.</dd>
<dd><code>maxIters</code> - The maximum number of robust method iterations.

 This function estimates essential matrix based on the five-point algorithm solver in CITE: Nister03 .
 CITE: SteweniusCFS is also a related. The epipolar geometry is described by the following equation:

 \([p_2; 1]^T K^{-T} E K^{-1} [p_1; 1] = 0\)

 where \(E\) is an essential matrix, \(p_1\) and \(p_2\) are corresponding points in the first and the
 second images, respectively. The result of this function may be passed further to
 #decomposeEssentialMat or #recoverPose to recover the relative pose between cameras.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findEssentialMat</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;findEssentialMat(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix1,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs1,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix2,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs2)</pre>
<div class="block">Calculates an essential matrix from the corresponding points in two images from potentially two different cameras.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - Array of N (N &gt;= 5) 2D points from the first image. The point coordinates should
 be floating-point (single or double precision).</dd>
<dd><code>points2</code> - Array of the second image points of the same size and format as points1.</dd>
<dd><code>cameraMatrix1</code> - Camera matrix for the first camera \(K = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\) .</dd>
<dd><code>cameraMatrix2</code> - Camera matrix for the second camera \(K = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\) .</dd>
<dd><code>distCoeffs1</code> - Input vector of distortion coefficients for the first camera
 \((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\)
 of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</dd>
<dd><code>distCoeffs2</code> - Input vector of distortion coefficients for the second camera
 \((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\)
 of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.
 <ul>
   <li>
    REF: RANSAC for the RANSAC algorithm.
   </li>
   <li>
    REF: LMEDS for the LMedS algorithm.
   </li>
 </ul>
 confidence (probability) that the estimated matrix is correct.
 line in pixels, beyond which the point is considered an outlier and is not used for computing the
 final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the
 point localization, image resolution, and the image noise.
 for the other points. The array is computed only in the RANSAC and LMedS methods.

 This function estimates essential matrix based on the five-point algorithm solver in CITE: Nister03 .
 CITE: SteweniusCFS is also a related. The epipolar geometry is described by the following equation:

 \([p_2; 1]^T K^{-T} E K^{-1} [p_1; 1] = 0\)

 where \(E\) is an essential matrix, \(p_1\) and \(p_2\) are corresponding points in the first and the
 second images, respectively. The result of this function may be passed further to
 #decomposeEssentialMat or  #recoverPose to recover the relative pose between cameras.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findEssentialMat</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;findEssentialMat(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix1,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs1,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix2,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs2,
                                   int&nbsp;method)</pre>
<div class="block">Calculates an essential matrix from the corresponding points in two images from potentially two different cameras.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - Array of N (N &gt;= 5) 2D points from the first image. The point coordinates should
 be floating-point (single or double precision).</dd>
<dd><code>points2</code> - Array of the second image points of the same size and format as points1.</dd>
<dd><code>cameraMatrix1</code> - Camera matrix for the first camera \(K = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\) .</dd>
<dd><code>cameraMatrix2</code> - Camera matrix for the second camera \(K = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\) .</dd>
<dd><code>distCoeffs1</code> - Input vector of distortion coefficients for the first camera
 \((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\)
 of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</dd>
<dd><code>distCoeffs2</code> - Input vector of distortion coefficients for the second camera
 \((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\)
 of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</dd>
<dd><code>method</code> - Method for computing an essential matrix.
 <ul>
   <li>
    REF: RANSAC for the RANSAC algorithm.
   </li>
   <li>
    REF: LMEDS for the LMedS algorithm.
   </li>
 </ul>
 confidence (probability) that the estimated matrix is correct.
 line in pixels, beyond which the point is considered an outlier and is not used for computing the
 final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the
 point localization, image resolution, and the image noise.
 for the other points. The array is computed only in the RANSAC and LMedS methods.

 This function estimates essential matrix based on the five-point algorithm solver in CITE: Nister03 .
 CITE: SteweniusCFS is also a related. The epipolar geometry is described by the following equation:

 \([p_2; 1]^T K^{-T} E K^{-1} [p_1; 1] = 0\)

 where \(E\) is an essential matrix, \(p_1\) and \(p_2\) are corresponding points in the first and the
 second images, respectively. The result of this function may be passed further to
 #decomposeEssentialMat or  #recoverPose to recover the relative pose between cameras.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findEssentialMat</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;findEssentialMat(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix1,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs1,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix2,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs2,
                                   int&nbsp;method,
                                   double&nbsp;prob)</pre>
<div class="block">Calculates an essential matrix from the corresponding points in two images from potentially two different cameras.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - Array of N (N &gt;= 5) 2D points from the first image. The point coordinates should
 be floating-point (single or double precision).</dd>
<dd><code>points2</code> - Array of the second image points of the same size and format as points1.</dd>
<dd><code>cameraMatrix1</code> - Camera matrix for the first camera \(K = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\) .</dd>
<dd><code>cameraMatrix2</code> - Camera matrix for the second camera \(K = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\) .</dd>
<dd><code>distCoeffs1</code> - Input vector of distortion coefficients for the first camera
 \((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\)
 of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</dd>
<dd><code>distCoeffs2</code> - Input vector of distortion coefficients for the second camera
 \((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\)
 of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</dd>
<dd><code>method</code> - Method for computing an essential matrix.
 <ul>
   <li>
    REF: RANSAC for the RANSAC algorithm.
   </li>
   <li>
    REF: LMEDS for the LMedS algorithm.
   </li>
 </ul></dd>
<dd><code>prob</code> - Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of
 confidence (probability) that the estimated matrix is correct.
 line in pixels, beyond which the point is considered an outlier and is not used for computing the
 final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the
 point localization, image resolution, and the image noise.
 for the other points. The array is computed only in the RANSAC and LMedS methods.

 This function estimates essential matrix based on the five-point algorithm solver in CITE: Nister03 .
 CITE: SteweniusCFS is also a related. The epipolar geometry is described by the following equation:

 \([p_2; 1]^T K^{-T} E K^{-1} [p_1; 1] = 0\)

 where \(E\) is an essential matrix, \(p_1\) and \(p_2\) are corresponding points in the first and the
 second images, respectively. The result of this function may be passed further to
 #decomposeEssentialMat or  #recoverPose to recover the relative pose between cameras.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findEssentialMat</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;findEssentialMat(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix1,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs1,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix2,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs2,
                                   int&nbsp;method,
                                   double&nbsp;prob,
                                   double&nbsp;threshold)</pre>
<div class="block">Calculates an essential matrix from the corresponding points in two images from potentially two different cameras.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - Array of N (N &gt;= 5) 2D points from the first image. The point coordinates should
 be floating-point (single or double precision).</dd>
<dd><code>points2</code> - Array of the second image points of the same size and format as points1.</dd>
<dd><code>cameraMatrix1</code> - Camera matrix for the first camera \(K = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\) .</dd>
<dd><code>cameraMatrix2</code> - Camera matrix for the second camera \(K = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\) .</dd>
<dd><code>distCoeffs1</code> - Input vector of distortion coefficients for the first camera
 \((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\)
 of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</dd>
<dd><code>distCoeffs2</code> - Input vector of distortion coefficients for the second camera
 \((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\)
 of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</dd>
<dd><code>method</code> - Method for computing an essential matrix.
 <ul>
   <li>
    REF: RANSAC for the RANSAC algorithm.
   </li>
   <li>
    REF: LMEDS for the LMedS algorithm.
   </li>
 </ul></dd>
<dd><code>prob</code> - Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of
 confidence (probability) that the estimated matrix is correct.</dd>
<dd><code>threshold</code> - Parameter used for RANSAC. It is the maximum distance from a point to an epipolar
 line in pixels, beyond which the point is considered an outlier and is not used for computing the
 final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the
 point localization, image resolution, and the image noise.
 for the other points. The array is computed only in the RANSAC and LMedS methods.

 This function estimates essential matrix based on the five-point algorithm solver in CITE: Nister03 .
 CITE: SteweniusCFS is also a related. The epipolar geometry is described by the following equation:

 \([p_2; 1]^T K^{-T} E K^{-1} [p_1; 1] = 0\)

 where \(E\) is an essential matrix, \(p_1\) and \(p_2\) are corresponding points in the first and the
 second images, respectively. The result of this function may be passed further to
 #decomposeEssentialMat or  #recoverPose to recover the relative pose between cameras.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findEssentialMat</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;findEssentialMat(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix1,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs1,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix2,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs2,
                                   int&nbsp;method,
                                   double&nbsp;prob,
                                   double&nbsp;threshold,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
<div class="block">Calculates an essential matrix from the corresponding points in two images from potentially two different cameras.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - Array of N (N &gt;= 5) 2D points from the first image. The point coordinates should
 be floating-point (single or double precision).</dd>
<dd><code>points2</code> - Array of the second image points of the same size and format as points1.</dd>
<dd><code>cameraMatrix1</code> - Camera matrix for the first camera \(K = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\) .</dd>
<dd><code>cameraMatrix2</code> - Camera matrix for the second camera \(K = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\) .</dd>
<dd><code>distCoeffs1</code> - Input vector of distortion coefficients for the first camera
 \((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\)
 of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</dd>
<dd><code>distCoeffs2</code> - Input vector of distortion coefficients for the second camera
 \((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\)
 of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</dd>
<dd><code>method</code> - Method for computing an essential matrix.
 <ul>
   <li>
    REF: RANSAC for the RANSAC algorithm.
   </li>
   <li>
    REF: LMEDS for the LMedS algorithm.
   </li>
 </ul></dd>
<dd><code>prob</code> - Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of
 confidence (probability) that the estimated matrix is correct.</dd>
<dd><code>threshold</code> - Parameter used for RANSAC. It is the maximum distance from a point to an epipolar
 line in pixels, beyond which the point is considered an outlier and is not used for computing the
 final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the
 point localization, image resolution, and the image noise.</dd>
<dd><code>mask</code> - Output array of N elements, every element of which is set to 0 for outliers and to 1
 for the other points. The array is computed only in the RANSAC and LMedS methods.

 This function estimates essential matrix based on the five-point algorithm solver in CITE: Nister03 .
 CITE: SteweniusCFS is also a related. The epipolar geometry is described by the following equation:

 \([p_2; 1]^T K^{-T} E K^{-1} [p_1; 1] = 0\)

 where \(E\) is an essential matrix, \(p_1\) and \(p_2\) are corresponding points in the first and the
 second images, respectively. The result of this function may be passed further to
 #decomposeEssentialMat or  #recoverPose to recover the relative pose between cameras.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="findEssentialMat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.cv3d.UsacParams-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findEssentialMat</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;findEssentialMat(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix1,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix2,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dist_coeff1,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dist_coeff2,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                                   <a href="../../../org/opencv/cv3d/UsacParams.html" title="class in org.opencv.cv3d">UsacParams</a>&nbsp;params)</pre>
</li>
</ul>
<a name="findFundamentalMat-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findFundamentalMat</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;findFundamentalMat(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points1,
                                     <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points2)</pre>
</li>
</ul>
<a name="findFundamentalMat-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findFundamentalMat</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;findFundamentalMat(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points1,
                                     <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points2,
                                     int&nbsp;method)</pre>
</li>
</ul>
<a name="findFundamentalMat-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-int-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findFundamentalMat</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;findFundamentalMat(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points1,
                                     <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points2,
                                     int&nbsp;method,
                                     double&nbsp;ransacReprojThreshold)</pre>
</li>
</ul>
<a name="findFundamentalMat-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-int-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findFundamentalMat</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;findFundamentalMat(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points1,
                                     <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points2,
                                     int&nbsp;method,
                                     double&nbsp;ransacReprojThreshold,
                                     double&nbsp;confidence)</pre>
</li>
</ul>
<a name="findFundamentalMat-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-int-double-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findFundamentalMat</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;findFundamentalMat(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points1,
                                     <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points2,
                                     int&nbsp;method,
                                     double&nbsp;ransacReprojThreshold,
                                     double&nbsp;confidence,
                                     int&nbsp;maxIters)</pre>
<div class="block">Calculates a fundamental matrix from the corresponding points in two images.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - Array of N points from the first image. The point coordinates should be
 floating-point (single or double precision).</dd>
<dd><code>points2</code> - Array of the second image points of the same size and format as points1 .</dd>
<dd><code>method</code> - Method for computing a fundamental matrix.
 <ul>
   <li>
    REF: FM_7POINT for a 7-point algorithm. \(N = 7\)
   </li>
   <li>
    REF: FM_8POINT for an 8-point algorithm. \(N \ge 8\)
   </li>
   <li>
    REF: FM_RANSAC for the RANSAC algorithm. \(N \ge 8\)
   </li>
   <li>
    REF: FM_LMEDS for the LMedS algorithm. \(N \ge 8\)
   </li>
 </ul></dd>
<dd><code>ransacReprojThreshold</code> - Parameter used only for RANSAC. It is the maximum distance from a point to an epipolar
 line in pixels, beyond which the point is considered an outlier and is not used for computing the
 final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the
 point localization, image resolution, and the image noise.</dd>
<dd><code>confidence</code> - Parameter used for the RANSAC and LMedS methods only. It specifies a desirable level
 of confidence (probability) that the estimated matrix is correct.</dd>
<dd><code>maxIters</code> - The maximum number of robust method iterations.

 The epipolar geometry is described by the following equation:

 \([p_2; 1]^T F [p_1; 1] = 0\)

 where \(F\) is a fundamental matrix, \(p_1\) and \(p_2\) are corresponding points in the first and the
 second images, respectively.

 The function calculates the fundamental matrix using one of four methods listed above and returns
 the found fundamental matrix. Normally just one matrix is found. But in case of the 7-point
 algorithm, the function may return up to 3 solutions ( \(9 \times 3\) matrix that stores all 3
 matrices sequentially).

 The calculated fundamental matrix may be passed further to #computeCorrespondEpilines that finds the
 epipolar lines corresponding to the specified points. It can also be passed to
 #stereoRectifyUncalibrated to compute the rectification transformation. :
 <code>
     // Example. Estimation of fundamental matrix using the RANSAC algorithm
     int point_count = 100;
     vector&lt;Point2f&gt; points1(point_count);
     vector&lt;Point2f&gt; points2(point_count);

     // initialize the points here ...
     for( int i = 0; i &lt; point_count; i++ )
     {
         points1[i] = ...;
         points2[i] = ...;
     }

     Mat fundamental_matrix =
      findFundamentalMat(points1, points2, FM_RANSAC, 3, 0.99);
 </code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="findFundamentalMat-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-int-double-double-int-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findFundamentalMat</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;findFundamentalMat(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points1,
                                     <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points2,
                                     int&nbsp;method,
                                     double&nbsp;ransacReprojThreshold,
                                     double&nbsp;confidence,
                                     int&nbsp;maxIters,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
<div class="block">Calculates a fundamental matrix from the corresponding points in two images.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - Array of N points from the first image. The point coordinates should be
 floating-point (single or double precision).</dd>
<dd><code>points2</code> - Array of the second image points of the same size and format as points1 .</dd>
<dd><code>method</code> - Method for computing a fundamental matrix.
 <ul>
   <li>
    REF: FM_7POINT for a 7-point algorithm. \(N = 7\)
   </li>
   <li>
    REF: FM_8POINT for an 8-point algorithm. \(N \ge 8\)
   </li>
   <li>
    REF: FM_RANSAC for the RANSAC algorithm. \(N \ge 8\)
   </li>
   <li>
    REF: FM_LMEDS for the LMedS algorithm. \(N \ge 8\)
   </li>
 </ul></dd>
<dd><code>ransacReprojThreshold</code> - Parameter used only for RANSAC. It is the maximum distance from a point to an epipolar
 line in pixels, beyond which the point is considered an outlier and is not used for computing the
 final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the
 point localization, image resolution, and the image noise.</dd>
<dd><code>confidence</code> - Parameter used for the RANSAC and LMedS methods only. It specifies a desirable level
 of confidence (probability) that the estimated matrix is correct.</dd>
<dd><code>mask</code> - optional output mask</dd>
<dd><code>maxIters</code> - The maximum number of robust method iterations.

 The epipolar geometry is described by the following equation:

 \([p_2; 1]^T F [p_1; 1] = 0\)

 where \(F\) is a fundamental matrix, \(p_1\) and \(p_2\) are corresponding points in the first and the
 second images, respectively.

 The function calculates the fundamental matrix using one of four methods listed above and returns
 the found fundamental matrix. Normally just one matrix is found. But in case of the 7-point
 algorithm, the function may return up to 3 solutions ( \(9 \times 3\) matrix that stores all 3
 matrices sequentially).

 The calculated fundamental matrix may be passed further to #computeCorrespondEpilines that finds the
 epipolar lines corresponding to the specified points. It can also be passed to
 #stereoRectifyUncalibrated to compute the rectification transformation. :
 <code>
     // Example. Estimation of fundamental matrix using the RANSAC algorithm
     int point_count = 100;
     vector&lt;Point2f&gt; points1(point_count);
     vector&lt;Point2f&gt; points2(point_count);

     // initialize the points here ...
     for( int i = 0; i &lt; point_count; i++ )
     {
         points1[i] = ...;
         points2[i] = ...;
     }

     Mat fundamental_matrix =
      findFundamentalMat(points1, points2, FM_RANSAC, 3, 0.99);
 </code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="findFundamentalMat-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-int-double-double-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findFundamentalMat</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;findFundamentalMat(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points1,
                                     <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points2,
                                     int&nbsp;method,
                                     double&nbsp;ransacReprojThreshold,
                                     double&nbsp;confidence,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
</li>
</ul>
<a name="findFundamentalMat-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-org.opencv.cv3d.UsacParams-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findFundamentalMat</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;findFundamentalMat(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points1,
                                     <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points2,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                                     <a href="../../../org/opencv/cv3d/UsacParams.html" title="class in org.opencv.cv3d">UsacParams</a>&nbsp;params)</pre>
</li>
</ul>
<a name="findHomography-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findHomography</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;findHomography(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;srcPoints,
                                 <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;dstPoints)</pre>
<div class="block">Finds a perspective transformation between two planes.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>srcPoints</code> - Coordinates of the points in the original plane, a matrix of the type CV_32FC2
 or vector&lt;Point2f&gt; .</dd>
<dd><code>dstPoints</code> - Coordinates of the points in the target plane, a matrix of the type CV_32FC2 or
 a vector&lt;Point2f&gt; .
 <ul>
   <li>
    <b>0</b> - a regular method using all the points, i.e., the least squares method
   </li>
   <li>
    REF: RANSAC - RANSAC-based robust method
   </li>
   <li>
    REF: LMEDS - Least-Median robust method
   </li>
   <li>
    REF: RHO - PROSAC-based robust method
   </li>
 </ul>
 (used in the RANSAC and RHO methods only). That is, if
 \(\| \texttt{dstPoints} _i -  \texttt{convertPointsHomogeneous} ( \texttt{H} \cdot \texttt{srcPoints} _i) \|_2  &gt;  \texttt{ransacReprojThreshold}\)
 then the point \(i\) is considered as an outlier. If srcPoints and dstPoints are measured in pixels,
 it usually makes sense to set this parameter somewhere in the range of 1 to 10.
 mask values are ignored.

 The function finds and returns the perspective transformation \(H\) between the source and the
 destination planes:

 \(s_i  \vecthree{x'_i}{y'_i}{1} \sim H  \vecthree{x_i}{y_i}{1}\)

 so that the back-projection error

 \(\sum _i \left ( x'_i- \frac{h_{11} x_i + h_{12} y_i + h_{13}}{h_{31} x_i + h_{32} y_i + h_{33}} \right )^2+ \left ( y'_i- \frac{h_{21} x_i + h_{22} y_i + h_{23}}{h_{31} x_i + h_{32} y_i + h_{33}} \right )^2\)

 is minimized. If the parameter method is set to the default value 0, the function uses all the point
 pairs to compute an initial homography estimate with a simple least-squares scheme.

 However, if not all of the point pairs ( \(srcPoints_i\), \(dstPoints_i\) ) fit the rigid perspective
 transformation (that is, there are some outliers), this initial estimate will be poor. In this case,
 you can use one of the three robust methods. The methods RANSAC, LMeDS and RHO try many different
 random subsets of the corresponding point pairs (of four pairs each, collinear pairs are discarded), estimate the homography matrix
 using this subset and a simple least-squares algorithm, and then compute the quality/goodness of the
 computed homography (which is the number of inliers for RANSAC or the least median re-projection error for
 LMeDS). The best subset is then used to produce the initial estimate of the homography matrix and
 the mask of inliers/outliers.

 Regardless of the method, robust or not, the computed homography matrix is refined further (using
 inliers only in case of a robust method) with the Levenberg-Marquardt method to reduce the
 re-projection error even more.

 The methods RANSAC and RHO can handle practically any ratio of outliers but need a threshold to
 distinguish inliers from outliers. The method LMeDS does not need any threshold but it works
 correctly only when there are more than 50% of inliers. Finally, if there are no outliers and the
 noise is rather small, use the default method (method=0).

 The function is used to find initial intrinsic and extrinsic matrices. Homography matrix is
 determined up to a scale. If \(h_{33}\) is non-zero, the matrix is normalized so that \(h_{33}=1\).
 <b>Note:</b> Whenever an \(H\) matrix cannot be estimated, an empty one will be returned.

 SEE:
 getAffineTransform, estimateAffine2D, estimateAffinePartial2D, getPerspectiveTransform, warpPerspective,
 perspectiveTransform</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="findHomography-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findHomography</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;findHomography(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;srcPoints,
                                 <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;dstPoints,
                                 int&nbsp;method)</pre>
<div class="block">Finds a perspective transformation between two planes.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>srcPoints</code> - Coordinates of the points in the original plane, a matrix of the type CV_32FC2
 or vector&lt;Point2f&gt; .</dd>
<dd><code>dstPoints</code> - Coordinates of the points in the target plane, a matrix of the type CV_32FC2 or
 a vector&lt;Point2f&gt; .</dd>
<dd><code>method</code> - Method used to compute a homography matrix. The following methods are possible:
 <ul>
   <li>
    <b>0</b> - a regular method using all the points, i.e., the least squares method
   </li>
   <li>
    REF: RANSAC - RANSAC-based robust method
   </li>
   <li>
    REF: LMEDS - Least-Median robust method
   </li>
   <li>
    REF: RHO - PROSAC-based robust method
   </li>
 </ul>
 (used in the RANSAC and RHO methods only). That is, if
 \(\| \texttt{dstPoints} _i -  \texttt{convertPointsHomogeneous} ( \texttt{H} \cdot \texttt{srcPoints} _i) \|_2  &gt;  \texttt{ransacReprojThreshold}\)
 then the point \(i\) is considered as an outlier. If srcPoints and dstPoints are measured in pixels,
 it usually makes sense to set this parameter somewhere in the range of 1 to 10.
 mask values are ignored.

 The function finds and returns the perspective transformation \(H\) between the source and the
 destination planes:

 \(s_i  \vecthree{x'_i}{y'_i}{1} \sim H  \vecthree{x_i}{y_i}{1}\)

 so that the back-projection error

 \(\sum _i \left ( x'_i- \frac{h_{11} x_i + h_{12} y_i + h_{13}}{h_{31} x_i + h_{32} y_i + h_{33}} \right )^2+ \left ( y'_i- \frac{h_{21} x_i + h_{22} y_i + h_{23}}{h_{31} x_i + h_{32} y_i + h_{33}} \right )^2\)

 is minimized. If the parameter method is set to the default value 0, the function uses all the point
 pairs to compute an initial homography estimate with a simple least-squares scheme.

 However, if not all of the point pairs ( \(srcPoints_i\), \(dstPoints_i\) ) fit the rigid perspective
 transformation (that is, there are some outliers), this initial estimate will be poor. In this case,
 you can use one of the three robust methods. The methods RANSAC, LMeDS and RHO try many different
 random subsets of the corresponding point pairs (of four pairs each, collinear pairs are discarded), estimate the homography matrix
 using this subset and a simple least-squares algorithm, and then compute the quality/goodness of the
 computed homography (which is the number of inliers for RANSAC or the least median re-projection error for
 LMeDS). The best subset is then used to produce the initial estimate of the homography matrix and
 the mask of inliers/outliers.

 Regardless of the method, robust or not, the computed homography matrix is refined further (using
 inliers only in case of a robust method) with the Levenberg-Marquardt method to reduce the
 re-projection error even more.

 The methods RANSAC and RHO can handle practically any ratio of outliers but need a threshold to
 distinguish inliers from outliers. The method LMeDS does not need any threshold but it works
 correctly only when there are more than 50% of inliers. Finally, if there are no outliers and the
 noise is rather small, use the default method (method=0).

 The function is used to find initial intrinsic and extrinsic matrices. Homography matrix is
 determined up to a scale. If \(h_{33}\) is non-zero, the matrix is normalized so that \(h_{33}=1\).
 <b>Note:</b> Whenever an \(H\) matrix cannot be estimated, an empty one will be returned.

 SEE:
 getAffineTransform, estimateAffine2D, estimateAffinePartial2D, getPerspectiveTransform, warpPerspective,
 perspectiveTransform</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="findHomography-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-int-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findHomography</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;findHomography(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;srcPoints,
                                 <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;dstPoints,
                                 int&nbsp;method,
                                 double&nbsp;ransacReprojThreshold)</pre>
<div class="block">Finds a perspective transformation between two planes.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>srcPoints</code> - Coordinates of the points in the original plane, a matrix of the type CV_32FC2
 or vector&lt;Point2f&gt; .</dd>
<dd><code>dstPoints</code> - Coordinates of the points in the target plane, a matrix of the type CV_32FC2 or
 a vector&lt;Point2f&gt; .</dd>
<dd><code>method</code> - Method used to compute a homography matrix. The following methods are possible:
 <ul>
   <li>
    <b>0</b> - a regular method using all the points, i.e., the least squares method
   </li>
   <li>
    REF: RANSAC - RANSAC-based robust method
   </li>
   <li>
    REF: LMEDS - Least-Median robust method
   </li>
   <li>
    REF: RHO - PROSAC-based robust method
   </li>
 </ul></dd>
<dd><code>ransacReprojThreshold</code> - Maximum allowed reprojection error to treat a point pair as an inlier
 (used in the RANSAC and RHO methods only). That is, if
 \(\| \texttt{dstPoints} _i -  \texttt{convertPointsHomogeneous} ( \texttt{H} \cdot \texttt{srcPoints} _i) \|_2  &gt;  \texttt{ransacReprojThreshold}\)
 then the point \(i\) is considered as an outlier. If srcPoints and dstPoints are measured in pixels,
 it usually makes sense to set this parameter somewhere in the range of 1 to 10.
 mask values are ignored.

 The function finds and returns the perspective transformation \(H\) between the source and the
 destination planes:

 \(s_i  \vecthree{x'_i}{y'_i}{1} \sim H  \vecthree{x_i}{y_i}{1}\)

 so that the back-projection error

 \(\sum _i \left ( x'_i- \frac{h_{11} x_i + h_{12} y_i + h_{13}}{h_{31} x_i + h_{32} y_i + h_{33}} \right )^2+ \left ( y'_i- \frac{h_{21} x_i + h_{22} y_i + h_{23}}{h_{31} x_i + h_{32} y_i + h_{33}} \right )^2\)

 is minimized. If the parameter method is set to the default value 0, the function uses all the point
 pairs to compute an initial homography estimate with a simple least-squares scheme.

 However, if not all of the point pairs ( \(srcPoints_i\), \(dstPoints_i\) ) fit the rigid perspective
 transformation (that is, there are some outliers), this initial estimate will be poor. In this case,
 you can use one of the three robust methods. The methods RANSAC, LMeDS and RHO try many different
 random subsets of the corresponding point pairs (of four pairs each, collinear pairs are discarded), estimate the homography matrix
 using this subset and a simple least-squares algorithm, and then compute the quality/goodness of the
 computed homography (which is the number of inliers for RANSAC or the least median re-projection error for
 LMeDS). The best subset is then used to produce the initial estimate of the homography matrix and
 the mask of inliers/outliers.

 Regardless of the method, robust or not, the computed homography matrix is refined further (using
 inliers only in case of a robust method) with the Levenberg-Marquardt method to reduce the
 re-projection error even more.

 The methods RANSAC and RHO can handle practically any ratio of outliers but need a threshold to
 distinguish inliers from outliers. The method LMeDS does not need any threshold but it works
 correctly only when there are more than 50% of inliers. Finally, if there are no outliers and the
 noise is rather small, use the default method (method=0).

 The function is used to find initial intrinsic and extrinsic matrices. Homography matrix is
 determined up to a scale. If \(h_{33}\) is non-zero, the matrix is normalized so that \(h_{33}=1\).
 <b>Note:</b> Whenever an \(H\) matrix cannot be estimated, an empty one will be returned.

 SEE:
 getAffineTransform, estimateAffine2D, estimateAffinePartial2D, getPerspectiveTransform, warpPerspective,
 perspectiveTransform</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="findHomography-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-int-double-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findHomography</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;findHomography(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;srcPoints,
                                 <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;dstPoints,
                                 int&nbsp;method,
                                 double&nbsp;ransacReprojThreshold,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
<div class="block">Finds a perspective transformation between two planes.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>srcPoints</code> - Coordinates of the points in the original plane, a matrix of the type CV_32FC2
 or vector&lt;Point2f&gt; .</dd>
<dd><code>dstPoints</code> - Coordinates of the points in the target plane, a matrix of the type CV_32FC2 or
 a vector&lt;Point2f&gt; .</dd>
<dd><code>method</code> - Method used to compute a homography matrix. The following methods are possible:
 <ul>
   <li>
    <b>0</b> - a regular method using all the points, i.e., the least squares method
   </li>
   <li>
    REF: RANSAC - RANSAC-based robust method
   </li>
   <li>
    REF: LMEDS - Least-Median robust method
   </li>
   <li>
    REF: RHO - PROSAC-based robust method
   </li>
 </ul></dd>
<dd><code>ransacReprojThreshold</code> - Maximum allowed reprojection error to treat a point pair as an inlier
 (used in the RANSAC and RHO methods only). That is, if
 \(\| \texttt{dstPoints} _i -  \texttt{convertPointsHomogeneous} ( \texttt{H} \cdot \texttt{srcPoints} _i) \|_2  &gt;  \texttt{ransacReprojThreshold}\)
 then the point \(i\) is considered as an outlier. If srcPoints and dstPoints are measured in pixels,
 it usually makes sense to set this parameter somewhere in the range of 1 to 10.</dd>
<dd><code>mask</code> - Optional output mask set by a robust method ( RANSAC or LMeDS ). Note that the input
 mask values are ignored.

 The function finds and returns the perspective transformation \(H\) between the source and the
 destination planes:

 \(s_i  \vecthree{x'_i}{y'_i}{1} \sim H  \vecthree{x_i}{y_i}{1}\)

 so that the back-projection error

 \(\sum _i \left ( x'_i- \frac{h_{11} x_i + h_{12} y_i + h_{13}}{h_{31} x_i + h_{32} y_i + h_{33}} \right )^2+ \left ( y'_i- \frac{h_{21} x_i + h_{22} y_i + h_{23}}{h_{31} x_i + h_{32} y_i + h_{33}} \right )^2\)

 is minimized. If the parameter method is set to the default value 0, the function uses all the point
 pairs to compute an initial homography estimate with a simple least-squares scheme.

 However, if not all of the point pairs ( \(srcPoints_i\), \(dstPoints_i\) ) fit the rigid perspective
 transformation (that is, there are some outliers), this initial estimate will be poor. In this case,
 you can use one of the three robust methods. The methods RANSAC, LMeDS and RHO try many different
 random subsets of the corresponding point pairs (of four pairs each, collinear pairs are discarded), estimate the homography matrix
 using this subset and a simple least-squares algorithm, and then compute the quality/goodness of the
 computed homography (which is the number of inliers for RANSAC or the least median re-projection error for
 LMeDS). The best subset is then used to produce the initial estimate of the homography matrix and
 the mask of inliers/outliers.

 Regardless of the method, robust or not, the computed homography matrix is refined further (using
 inliers only in case of a robust method) with the Levenberg-Marquardt method to reduce the
 re-projection error even more.

 The methods RANSAC and RHO can handle practically any ratio of outliers but need a threshold to
 distinguish inliers from outliers. The method LMeDS does not need any threshold but it works
 correctly only when there are more than 50% of inliers. Finally, if there are no outliers and the
 noise is rather small, use the default method (method=0).

 The function is used to find initial intrinsic and extrinsic matrices. Homography matrix is
 determined up to a scale. If \(h_{33}\) is non-zero, the matrix is normalized so that \(h_{33}=1\).
 <b>Note:</b> Whenever an \(H\) matrix cannot be estimated, an empty one will be returned.

 SEE:
 getAffineTransform, estimateAffine2D, estimateAffinePartial2D, getPerspectiveTransform, warpPerspective,
 perspectiveTransform</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="findHomography-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-int-double-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findHomography</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;findHomography(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;srcPoints,
                                 <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;dstPoints,
                                 int&nbsp;method,
                                 double&nbsp;ransacReprojThreshold,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                                 int&nbsp;maxIters)</pre>
<div class="block">Finds a perspective transformation between two planes.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>srcPoints</code> - Coordinates of the points in the original plane, a matrix of the type CV_32FC2
 or vector&lt;Point2f&gt; .</dd>
<dd><code>dstPoints</code> - Coordinates of the points in the target plane, a matrix of the type CV_32FC2 or
 a vector&lt;Point2f&gt; .</dd>
<dd><code>method</code> - Method used to compute a homography matrix. The following methods are possible:
 <ul>
   <li>
    <b>0</b> - a regular method using all the points, i.e., the least squares method
   </li>
   <li>
    REF: RANSAC - RANSAC-based robust method
   </li>
   <li>
    REF: LMEDS - Least-Median robust method
   </li>
   <li>
    REF: RHO - PROSAC-based robust method
   </li>
 </ul></dd>
<dd><code>ransacReprojThreshold</code> - Maximum allowed reprojection error to treat a point pair as an inlier
 (used in the RANSAC and RHO methods only). That is, if
 \(\| \texttt{dstPoints} _i -  \texttt{convertPointsHomogeneous} ( \texttt{H} \cdot \texttt{srcPoints} _i) \|_2  &gt;  \texttt{ransacReprojThreshold}\)
 then the point \(i\) is considered as an outlier. If srcPoints and dstPoints are measured in pixels,
 it usually makes sense to set this parameter somewhere in the range of 1 to 10.</dd>
<dd><code>mask</code> - Optional output mask set by a robust method ( RANSAC or LMeDS ). Note that the input
 mask values are ignored.</dd>
<dd><code>maxIters</code> - The maximum number of RANSAC iterations.

 The function finds and returns the perspective transformation \(H\) between the source and the
 destination planes:

 \(s_i  \vecthree{x'_i}{y'_i}{1} \sim H  \vecthree{x_i}{y_i}{1}\)

 so that the back-projection error

 \(\sum _i \left ( x'_i- \frac{h_{11} x_i + h_{12} y_i + h_{13}}{h_{31} x_i + h_{32} y_i + h_{33}} \right )^2+ \left ( y'_i- \frac{h_{21} x_i + h_{22} y_i + h_{23}}{h_{31} x_i + h_{32} y_i + h_{33}} \right )^2\)

 is minimized. If the parameter method is set to the default value 0, the function uses all the point
 pairs to compute an initial homography estimate with a simple least-squares scheme.

 However, if not all of the point pairs ( \(srcPoints_i\), \(dstPoints_i\) ) fit the rigid perspective
 transformation (that is, there are some outliers), this initial estimate will be poor. In this case,
 you can use one of the three robust methods. The methods RANSAC, LMeDS and RHO try many different
 random subsets of the corresponding point pairs (of four pairs each, collinear pairs are discarded), estimate the homography matrix
 using this subset and a simple least-squares algorithm, and then compute the quality/goodness of the
 computed homography (which is the number of inliers for RANSAC or the least median re-projection error for
 LMeDS). The best subset is then used to produce the initial estimate of the homography matrix and
 the mask of inliers/outliers.

 Regardless of the method, robust or not, the computed homography matrix is refined further (using
 inliers only in case of a robust method) with the Levenberg-Marquardt method to reduce the
 re-projection error even more.

 The methods RANSAC and RHO can handle practically any ratio of outliers but need a threshold to
 distinguish inliers from outliers. The method LMeDS does not need any threshold but it works
 correctly only when there are more than 50% of inliers. Finally, if there are no outliers and the
 noise is rather small, use the default method (method=0).

 The function is used to find initial intrinsic and extrinsic matrices. Homography matrix is
 determined up to a scale. If \(h_{33}\) is non-zero, the matrix is normalized so that \(h_{33}=1\).
 <b>Note:</b> Whenever an \(H\) matrix cannot be estimated, an empty one will be returned.

 SEE:
 getAffineTransform, estimateAffine2D, estimateAffinePartial2D, getPerspectiveTransform, warpPerspective,
 perspectiveTransform</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="findHomography-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-int-double-org.opencv.core.Mat-int-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findHomography</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;findHomography(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;srcPoints,
                                 <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;dstPoints,
                                 int&nbsp;method,
                                 double&nbsp;ransacReprojThreshold,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                                 int&nbsp;maxIters,
                                 double&nbsp;confidence)</pre>
<div class="block">Finds a perspective transformation between two planes.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>srcPoints</code> - Coordinates of the points in the original plane, a matrix of the type CV_32FC2
 or vector&lt;Point2f&gt; .</dd>
<dd><code>dstPoints</code> - Coordinates of the points in the target plane, a matrix of the type CV_32FC2 or
 a vector&lt;Point2f&gt; .</dd>
<dd><code>method</code> - Method used to compute a homography matrix. The following methods are possible:
 <ul>
   <li>
    <b>0</b> - a regular method using all the points, i.e., the least squares method
   </li>
   <li>
    REF: RANSAC - RANSAC-based robust method
   </li>
   <li>
    REF: LMEDS - Least-Median robust method
   </li>
   <li>
    REF: RHO - PROSAC-based robust method
   </li>
 </ul></dd>
<dd><code>ransacReprojThreshold</code> - Maximum allowed reprojection error to treat a point pair as an inlier
 (used in the RANSAC and RHO methods only). That is, if
 \(\| \texttt{dstPoints} _i -  \texttt{convertPointsHomogeneous} ( \texttt{H} \cdot \texttt{srcPoints} _i) \|_2  &gt;  \texttt{ransacReprojThreshold}\)
 then the point \(i\) is considered as an outlier. If srcPoints and dstPoints are measured in pixels,
 it usually makes sense to set this parameter somewhere in the range of 1 to 10.</dd>
<dd><code>mask</code> - Optional output mask set by a robust method ( RANSAC or LMeDS ). Note that the input
 mask values are ignored.</dd>
<dd><code>maxIters</code> - The maximum number of RANSAC iterations.</dd>
<dd><code>confidence</code> - Confidence level, between 0 and 1.

 The function finds and returns the perspective transformation \(H\) between the source and the
 destination planes:

 \(s_i  \vecthree{x'_i}{y'_i}{1} \sim H  \vecthree{x_i}{y_i}{1}\)

 so that the back-projection error

 \(\sum _i \left ( x'_i- \frac{h_{11} x_i + h_{12} y_i + h_{13}}{h_{31} x_i + h_{32} y_i + h_{33}} \right )^2+ \left ( y'_i- \frac{h_{21} x_i + h_{22} y_i + h_{23}}{h_{31} x_i + h_{32} y_i + h_{33}} \right )^2\)

 is minimized. If the parameter method is set to the default value 0, the function uses all the point
 pairs to compute an initial homography estimate with a simple least-squares scheme.

 However, if not all of the point pairs ( \(srcPoints_i\), \(dstPoints_i\) ) fit the rigid perspective
 transformation (that is, there are some outliers), this initial estimate will be poor. In this case,
 you can use one of the three robust methods. The methods RANSAC, LMeDS and RHO try many different
 random subsets of the corresponding point pairs (of four pairs each, collinear pairs are discarded), estimate the homography matrix
 using this subset and a simple least-squares algorithm, and then compute the quality/goodness of the
 computed homography (which is the number of inliers for RANSAC or the least median re-projection error for
 LMeDS). The best subset is then used to produce the initial estimate of the homography matrix and
 the mask of inliers/outliers.

 Regardless of the method, robust or not, the computed homography matrix is refined further (using
 inliers only in case of a robust method) with the Levenberg-Marquardt method to reduce the
 re-projection error even more.

 The methods RANSAC and RHO can handle practically any ratio of outliers but need a threshold to
 distinguish inliers from outliers. The method LMeDS does not need any threshold but it works
 correctly only when there are more than 50% of inliers. Finally, if there are no outliers and the
 noise is rather small, use the default method (method=0).

 The function is used to find initial intrinsic and extrinsic matrices. Homography matrix is
 determined up to a scale. If \(h_{33}\) is non-zero, the matrix is normalized so that \(h_{33}=1\).
 <b>Note:</b> Whenever an \(H\) matrix cannot be estimated, an empty one will be returned.

 SEE:
 getAffineTransform, estimateAffine2D, estimateAffinePartial2D, getPerspectiveTransform, warpPerspective,
 perspectiveTransform</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="findHomography-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-org.opencv.cv3d.UsacParams-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findHomography</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;findHomography(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;srcPoints,
                                 <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;dstPoints,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                                 <a href="../../../org/opencv/cv3d/UsacParams.html" title="class in org.opencv.cv3d">UsacParams</a>&nbsp;params)</pre>
</li>
</ul>
<a name="findPlanes-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPlanes</h4>
<pre>public static&nbsp;void&nbsp;findPlanes(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points3d,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;normals,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;plane_coefficients)</pre>
<div class="block">Find the planes in a depth image</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points3d</code> - the 3d points organized like the depth image: rows x cols with 3 channels</dd>
<dd><code>normals</code> - the normals for every point in the depth image; optional, can be empty</dd>
<dd><code>mask</code> - An image where each pixel is labeled with the plane it belongs to
 and 255 if it does not belong to any plane</dd>
<dd><code>plane_coefficients</code> - the coefficients of the corresponding planes (a,b,c,d) such that ax+by+cz+d=0, norm(a,b,c)=1
 and c &lt; 0 (so that the normal points towards the camera)</dd>
</dl>
</li>
</ul>
<a name="findPlanes-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPlanes</h4>
<pre>public static&nbsp;void&nbsp;findPlanes(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points3d,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;normals,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;plane_coefficients,
                              int&nbsp;block_size)</pre>
<div class="block">Find the planes in a depth image</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points3d</code> - the 3d points organized like the depth image: rows x cols with 3 channels</dd>
<dd><code>normals</code> - the normals for every point in the depth image; optional, can be empty</dd>
<dd><code>mask</code> - An image where each pixel is labeled with the plane it belongs to
 and 255 if it does not belong to any plane</dd>
<dd><code>plane_coefficients</code> - the coefficients of the corresponding planes (a,b,c,d) such that ax+by+cz+d=0, norm(a,b,c)=1
 and c &lt; 0 (so that the normal points towards the camera)</dd>
<dd><code>block_size</code> - The size of the blocks to look at for a stable MSE</dd>
</dl>
</li>
</ul>
<a name="findPlanes-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPlanes</h4>
<pre>public static&nbsp;void&nbsp;findPlanes(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points3d,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;normals,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;plane_coefficients,
                              int&nbsp;block_size,
                              int&nbsp;min_size)</pre>
<div class="block">Find the planes in a depth image</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points3d</code> - the 3d points organized like the depth image: rows x cols with 3 channels</dd>
<dd><code>normals</code> - the normals for every point in the depth image; optional, can be empty</dd>
<dd><code>mask</code> - An image where each pixel is labeled with the plane it belongs to
 and 255 if it does not belong to any plane</dd>
<dd><code>plane_coefficients</code> - the coefficients of the corresponding planes (a,b,c,d) such that ax+by+cz+d=0, norm(a,b,c)=1
 and c &lt; 0 (so that the normal points towards the camera)</dd>
<dd><code>block_size</code> - The size of the blocks to look at for a stable MSE</dd>
<dd><code>min_size</code> - The minimum size of a cluster to be considered a plane</dd>
</dl>
</li>
</ul>
<a name="findPlanes-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-int-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPlanes</h4>
<pre>public static&nbsp;void&nbsp;findPlanes(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points3d,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;normals,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;plane_coefficients,
                              int&nbsp;block_size,
                              int&nbsp;min_size,
                              double&nbsp;threshold)</pre>
<div class="block">Find the planes in a depth image</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points3d</code> - the 3d points organized like the depth image: rows x cols with 3 channels</dd>
<dd><code>normals</code> - the normals for every point in the depth image; optional, can be empty</dd>
<dd><code>mask</code> - An image where each pixel is labeled with the plane it belongs to
 and 255 if it does not belong to any plane</dd>
<dd><code>plane_coefficients</code> - the coefficients of the corresponding planes (a,b,c,d) such that ax+by+cz+d=0, norm(a,b,c)=1
 and c &lt; 0 (so that the normal points towards the camera)</dd>
<dd><code>block_size</code> - The size of the blocks to look at for a stable MSE</dd>
<dd><code>min_size</code> - The minimum size of a cluster to be considered a plane</dd>
<dd><code>threshold</code> - The maximum distance of a point from a plane to belong to it (in meters)</dd>
</dl>
</li>
</ul>
<a name="findPlanes-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-int-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPlanes</h4>
<pre>public static&nbsp;void&nbsp;findPlanes(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points3d,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;normals,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;plane_coefficients,
                              int&nbsp;block_size,
                              int&nbsp;min_size,
                              double&nbsp;threshold,
                              double&nbsp;sensor_error_a)</pre>
<div class="block">Find the planes in a depth image</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points3d</code> - the 3d points organized like the depth image: rows x cols with 3 channels</dd>
<dd><code>normals</code> - the normals for every point in the depth image; optional, can be empty</dd>
<dd><code>mask</code> - An image where each pixel is labeled with the plane it belongs to
 and 255 if it does not belong to any plane</dd>
<dd><code>plane_coefficients</code> - the coefficients of the corresponding planes (a,b,c,d) such that ax+by+cz+d=0, norm(a,b,c)=1
 and c &lt; 0 (so that the normal points towards the camera)</dd>
<dd><code>block_size</code> - The size of the blocks to look at for a stable MSE</dd>
<dd><code>min_size</code> - The minimum size of a cluster to be considered a plane</dd>
<dd><code>threshold</code> - The maximum distance of a point from a plane to belong to it (in meters)</dd>
<dd><code>sensor_error_a</code> - coefficient of the sensor error. 0 by default, use 0.0075 for a Kinect</dd>
</dl>
</li>
</ul>
<a name="findPlanes-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-int-double-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPlanes</h4>
<pre>public static&nbsp;void&nbsp;findPlanes(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points3d,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;normals,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;plane_coefficients,
                              int&nbsp;block_size,
                              int&nbsp;min_size,
                              double&nbsp;threshold,
                              double&nbsp;sensor_error_a,
                              double&nbsp;sensor_error_b)</pre>
<div class="block">Find the planes in a depth image</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points3d</code> - the 3d points organized like the depth image: rows x cols with 3 channels</dd>
<dd><code>normals</code> - the normals for every point in the depth image; optional, can be empty</dd>
<dd><code>mask</code> - An image where each pixel is labeled with the plane it belongs to
 and 255 if it does not belong to any plane</dd>
<dd><code>plane_coefficients</code> - the coefficients of the corresponding planes (a,b,c,d) such that ax+by+cz+d=0, norm(a,b,c)=1
 and c &lt; 0 (so that the normal points towards the camera)</dd>
<dd><code>block_size</code> - The size of the blocks to look at for a stable MSE</dd>
<dd><code>min_size</code> - The minimum size of a cluster to be considered a plane</dd>
<dd><code>threshold</code> - The maximum distance of a point from a plane to belong to it (in meters)</dd>
<dd><code>sensor_error_a</code> - coefficient of the sensor error. 0 by default, use 0.0075 for a Kinect</dd>
<dd><code>sensor_error_b</code> - coefficient of the sensor error. 0 by default</dd>
</dl>
</li>
</ul>
<a name="findPlanes-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-int-double-double-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPlanes</h4>
<pre>public static&nbsp;void&nbsp;findPlanes(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points3d,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;normals,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;plane_coefficients,
                              int&nbsp;block_size,
                              int&nbsp;min_size,
                              double&nbsp;threshold,
                              double&nbsp;sensor_error_a,
                              double&nbsp;sensor_error_b,
                              double&nbsp;sensor_error_c)</pre>
<div class="block">Find the planes in a depth image</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points3d</code> - the 3d points organized like the depth image: rows x cols with 3 channels</dd>
<dd><code>normals</code> - the normals for every point in the depth image; optional, can be empty</dd>
<dd><code>mask</code> - An image where each pixel is labeled with the plane it belongs to
 and 255 if it does not belong to any plane</dd>
<dd><code>plane_coefficients</code> - the coefficients of the corresponding planes (a,b,c,d) such that ax+by+cz+d=0, norm(a,b,c)=1
 and c &lt; 0 (so that the normal points towards the camera)</dd>
<dd><code>block_size</code> - The size of the blocks to look at for a stable MSE</dd>
<dd><code>min_size</code> - The minimum size of a cluster to be considered a plane</dd>
<dd><code>threshold</code> - The maximum distance of a point from a plane to belong to it (in meters)</dd>
<dd><code>sensor_error_a</code> - coefficient of the sensor error. 0 by default, use 0.0075 for a Kinect</dd>
<dd><code>sensor_error_b</code> - coefficient of the sensor error. 0 by default</dd>
<dd><code>sensor_error_c</code> - coefficient of the sensor error. 0 by default</dd>
</dl>
</li>
</ul>
<a name="findPlanes-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-int-double-double-double-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPlanes</h4>
<pre>public static&nbsp;void&nbsp;findPlanes(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points3d,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;normals,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;plane_coefficients,
                              int&nbsp;block_size,
                              int&nbsp;min_size,
                              double&nbsp;threshold,
                              double&nbsp;sensor_error_a,
                              double&nbsp;sensor_error_b,
                              double&nbsp;sensor_error_c,
                              int&nbsp;method)</pre>
<div class="block">Find the planes in a depth image</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points3d</code> - the 3d points organized like the depth image: rows x cols with 3 channels</dd>
<dd><code>normals</code> - the normals for every point in the depth image; optional, can be empty</dd>
<dd><code>mask</code> - An image where each pixel is labeled with the plane it belongs to
 and 255 if it does not belong to any plane</dd>
<dd><code>plane_coefficients</code> - the coefficients of the corresponding planes (a,b,c,d) such that ax+by+cz+d=0, norm(a,b,c)=1
 and c &lt; 0 (so that the normal points towards the camera)</dd>
<dd><code>block_size</code> - The size of the blocks to look at for a stable MSE</dd>
<dd><code>min_size</code> - The minimum size of a cluster to be considered a plane</dd>
<dd><code>threshold</code> - The maximum distance of a point from a plane to belong to it (in meters)</dd>
<dd><code>sensor_error_a</code> - coefficient of the sensor error. 0 by default, use 0.0075 for a Kinect</dd>
<dd><code>sensor_error_b</code> - coefficient of the sensor error. 0 by default</dd>
<dd><code>sensor_error_c</code> - coefficient of the sensor error. 0 by default</dd>
<dd><code>method</code> - The method to use to compute the planes.</dd>
</dl>
</li>
</ul>
<a name="fisheye_distortPoints-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fisheye_distortPoints</h4>
<pre>public static&nbsp;void&nbsp;fisheye_distortPoints(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;undistorted,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distorted,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;D)</pre>
<div class="block">Distorts 2D points using fisheye model.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>undistorted</code> - Array of object points, 1xN/Nx1 2-channel (or vector&lt;Point2f&gt; ), where N is
 the number of points in the view.</dd>
<dd><code>K</code> - Camera intrinsic matrix \(cameramatrix{K}\).</dd>
<dd><code>D</code> - Input vector of distortion coefficients \(\distcoeffsfisheye\).</dd>
<dd><code>distorted</code> - Output array of image points, 1xN/Nx1 2-channel, or vector&lt;Point2f&gt; .

 Note that the function assumes the camera intrinsic matrix of the undistorted points to be identity.
 This means if you want to distort image points you have to multiply them with \(K^{-1}\) or
 use another function overload.</dd>
</dl>
</li>
</ul>
<a name="fisheye_distortPoints-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fisheye_distortPoints</h4>
<pre>public static&nbsp;void&nbsp;fisheye_distortPoints(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;undistorted,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distorted,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;D,
                                         double&nbsp;alpha)</pre>
<div class="block">Distorts 2D points using fisheye model.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>undistorted</code> - Array of object points, 1xN/Nx1 2-channel (or vector&lt;Point2f&gt; ), where N is
 the number of points in the view.</dd>
<dd><code>K</code> - Camera intrinsic matrix \(cameramatrix{K}\).</dd>
<dd><code>D</code> - Input vector of distortion coefficients \(\distcoeffsfisheye\).</dd>
<dd><code>alpha</code> - The skew coefficient.</dd>
<dd><code>distorted</code> - Output array of image points, 1xN/Nx1 2-channel, or vector&lt;Point2f&gt; .

 Note that the function assumes the camera intrinsic matrix of the undistorted points to be identity.
 This means if you want to distort image points you have to multiply them with \(K^{-1}\) or
 use another function overload.</dd>
</dl>
</li>
</ul>
<a name="fisheye_distortPoints-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fisheye_distortPoints</h4>
<pre>public static&nbsp;void&nbsp;fisheye_distortPoints(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;undistorted,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distorted,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Kundistorted,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;D)</pre>
<div class="block">Overload of distortPoints function to handle cases when undistorted points are got with non-identity
 camera matrix, e.g. output of #estimateNewCameraMatrixForUndistortRectify.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>undistorted</code> - Array of object points, 1xN/Nx1 2-channel (or vector&lt;Point2f&gt; ), where N is
 the number of points in the view.</dd>
<dd><code>Kundistorted</code> - Camera intrinsic matrix used as new camera matrix for undistortion.</dd>
<dd><code>K</code> - Camera intrinsic matrix \(cameramatrix{K}\).</dd>
<dd><code>D</code> - Input vector of distortion coefficients \(\distcoeffsfisheye\).</dd>
<dd><code>distorted</code> - Output array of image points, 1xN/Nx1 2-channel, or vector&lt;Point2f&gt; .
 SEE: estimateNewCameraMatrixForUndistortRectify</dd>
</dl>
</li>
</ul>
<a name="fisheye_distortPoints-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fisheye_distortPoints</h4>
<pre>public static&nbsp;void&nbsp;fisheye_distortPoints(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;undistorted,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distorted,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Kundistorted,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;D,
                                         double&nbsp;alpha)</pre>
<div class="block">Overload of distortPoints function to handle cases when undistorted points are got with non-identity
 camera matrix, e.g. output of #estimateNewCameraMatrixForUndistortRectify.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>undistorted</code> - Array of object points, 1xN/Nx1 2-channel (or vector&lt;Point2f&gt; ), where N is
 the number of points in the view.</dd>
<dd><code>Kundistorted</code> - Camera intrinsic matrix used as new camera matrix for undistortion.</dd>
<dd><code>K</code> - Camera intrinsic matrix \(cameramatrix{K}\).</dd>
<dd><code>D</code> - Input vector of distortion coefficients \(\distcoeffsfisheye\).</dd>
<dd><code>alpha</code> - The skew coefficient.</dd>
<dd><code>distorted</code> - Output array of image points, 1xN/Nx1 2-channel, or vector&lt;Point2f&gt; .
 SEE: estimateNewCameraMatrixForUndistortRectify</dd>
</dl>
</li>
</ul>
<a name="fisheye_estimateNewCameraMatrixForUndistortRectify-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fisheye_estimateNewCameraMatrixForUndistortRectify</h4>
<pre>public static&nbsp;void&nbsp;fisheye_estimateNewCameraMatrixForUndistortRectify(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                                                                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;D,
                                                                      <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;image_size,
                                                                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
                                                                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;P)</pre>
<div class="block">Estimates new camera intrinsic matrix for undistortion or rectification.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>K</code> - Camera intrinsic matrix \(cameramatrix{K}\).</dd>
<dd><code>image_size</code> - Size of the image</dd>
<dd><code>D</code> - Input vector of distortion coefficients \(\distcoeffsfisheye\).</dd>
<dd><code>R</code> - Rectification transformation in the object space: 3x3 1-channel, or vector: 3x1/1x3
 1-channel or 1x1 3-channel</dd>
<dd><code>P</code> - New camera intrinsic matrix (3x3) or new projection matrix (3x4)
 length. Balance is in range of [0, 1].</dd>
</dl>
</li>
</ul>
<a name="fisheye_estimateNewCameraMatrixForUndistortRectify-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-org.opencv.core.Mat-org.opencv.core.Mat-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fisheye_estimateNewCameraMatrixForUndistortRectify</h4>
<pre>public static&nbsp;void&nbsp;fisheye_estimateNewCameraMatrixForUndistortRectify(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                                                                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;D,
                                                                      <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;image_size,
                                                                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
                                                                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;P,
                                                                      double&nbsp;balance)</pre>
<div class="block">Estimates new camera intrinsic matrix for undistortion or rectification.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>K</code> - Camera intrinsic matrix \(cameramatrix{K}\).</dd>
<dd><code>image_size</code> - Size of the image</dd>
<dd><code>D</code> - Input vector of distortion coefficients \(\distcoeffsfisheye\).</dd>
<dd><code>R</code> - Rectification transformation in the object space: 3x3 1-channel, or vector: 3x1/1x3
 1-channel or 1x1 3-channel</dd>
<dd><code>P</code> - New camera intrinsic matrix (3x3) or new projection matrix (3x4)</dd>
<dd><code>balance</code> - Sets the new focal length in range between the min focal length and the max focal
 length. Balance is in range of [0, 1].</dd>
</dl>
</li>
</ul>
<a name="fisheye_estimateNewCameraMatrixForUndistortRectify-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-org.opencv.core.Mat-org.opencv.core.Mat-double-org.opencv.core.Size-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fisheye_estimateNewCameraMatrixForUndistortRectify</h4>
<pre>public static&nbsp;void&nbsp;fisheye_estimateNewCameraMatrixForUndistortRectify(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                                                                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;D,
                                                                      <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;image_size,
                                                                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
                                                                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;P,
                                                                      double&nbsp;balance,
                                                                      <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;new_size)</pre>
<div class="block">Estimates new camera intrinsic matrix for undistortion or rectification.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>K</code> - Camera intrinsic matrix \(cameramatrix{K}\).</dd>
<dd><code>image_size</code> - Size of the image</dd>
<dd><code>D</code> - Input vector of distortion coefficients \(\distcoeffsfisheye\).</dd>
<dd><code>R</code> - Rectification transformation in the object space: 3x3 1-channel, or vector: 3x1/1x3
 1-channel or 1x1 3-channel</dd>
<dd><code>P</code> - New camera intrinsic matrix (3x3) or new projection matrix (3x4)</dd>
<dd><code>balance</code> - Sets the new focal length in range between the min focal length and the max focal
 length. Balance is in range of [0, 1].</dd>
<dd><code>new_size</code> - the new size</dd>
</dl>
</li>
</ul>
<a name="fisheye_estimateNewCameraMatrixForUndistortRectify-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-org.opencv.core.Mat-org.opencv.core.Mat-double-org.opencv.core.Size-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fisheye_estimateNewCameraMatrixForUndistortRectify</h4>
<pre>public static&nbsp;void&nbsp;fisheye_estimateNewCameraMatrixForUndistortRectify(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                                                                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;D,
                                                                      <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;image_size,
                                                                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
                                                                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;P,
                                                                      double&nbsp;balance,
                                                                      <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;new_size,
                                                                      double&nbsp;fov_scale)</pre>
<div class="block">Estimates new camera intrinsic matrix for undistortion or rectification.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>K</code> - Camera intrinsic matrix \(cameramatrix{K}\).</dd>
<dd><code>image_size</code> - Size of the image</dd>
<dd><code>D</code> - Input vector of distortion coefficients \(\distcoeffsfisheye\).</dd>
<dd><code>R</code> - Rectification transformation in the object space: 3x3 1-channel, or vector: 3x1/1x3
 1-channel or 1x1 3-channel</dd>
<dd><code>P</code> - New camera intrinsic matrix (3x3) or new projection matrix (3x4)</dd>
<dd><code>balance</code> - Sets the new focal length in range between the min focal length and the max focal
 length. Balance is in range of [0, 1].</dd>
<dd><code>new_size</code> - the new size</dd>
<dd><code>fov_scale</code> - Divisor for new focal length.</dd>
</dl>
</li>
</ul>
<a name="fisheye_initUndistortRectifyMap-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-int-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fisheye_initUndistortRectifyMap</h4>
<pre>public static&nbsp;void&nbsp;fisheye_initUndistortRectifyMap(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;D,
                                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
                                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;P,
                                                   <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;size,
                                                   int&nbsp;m1type,
                                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map1,
                                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map2)</pre>
<div class="block">Computes undistortion and rectification maps for image transform by cv::remap(). If D is empty zero
 distortion is used, if R or P is empty identity matrixes are used.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>K</code> - Camera intrinsic matrix \(cameramatrix{K}\).</dd>
<dd><code>D</code> - Input vector of distortion coefficients \(\distcoeffsfisheye\).</dd>
<dd><code>R</code> - Rectification transformation in the object space: 3x3 1-channel, or vector: 3x1/1x3
 1-channel or 1x1 3-channel</dd>
<dd><code>P</code> - New camera intrinsic matrix (3x3) or new projection matrix (3x4)</dd>
<dd><code>size</code> - Undistorted image size.</dd>
<dd><code>m1type</code> - Type of the first output map that can be CV_32FC1 or CV_16SC2 . See convertMaps()
 for details.</dd>
<dd><code>map1</code> - The first output map.</dd>
<dd><code>map2</code> - The second output map.</dd>
</dl>
</li>
</ul>
<a name="fisheye_projectPoints-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fisheye_projectPoints</h4>
<pre>public static&nbsp;void&nbsp;fisheye_projectPoints(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;D)</pre>
</li>
</ul>
<a name="fisheye_projectPoints-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fisheye_projectPoints</h4>
<pre>public static&nbsp;void&nbsp;fisheye_projectPoints(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;D,
                                         double&nbsp;alpha)</pre>
</li>
</ul>
<a name="fisheye_projectPoints-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fisheye_projectPoints</h4>
<pre>public static&nbsp;void&nbsp;fisheye_projectPoints(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;D,
                                         double&nbsp;alpha,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;jacobian)</pre>
</li>
</ul>
<a name="fisheye_solvePnP-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fisheye_solvePnP</h4>
<pre>public static&nbsp;boolean&nbsp;fisheye_solvePnP(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec)</pre>
<div class="block">Finds an object pose from 3D-2D point correspondences for fisheye camera moodel.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>objectPoints</code> - Array of object points in the object coordinate space, Nx3 1-channel or
 1xN/Nx1 3-channel, where N is the number of points. vector&lt;Point3d&gt; can be also passed here.</dd>
<dd><code>imagePoints</code> - Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,
 where N is the number of points. vector&lt;Point2d&gt; can be also passed here.</dd>
<dd><code>cameraMatrix</code> - Input camera intrinsic matrix \(\cameramatrix{A}\) .</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients (4x1/1x4).</dd>
<dd><code>rvec</code> - Output rotation vector (see REF: Rodrigues ) that, together with tvec, brings points from
 the model coordinate system to the camera coordinate system.</dd>
<dd><code>tvec</code> - Output translation vector.
 the provided rvec and tvec values as initial approximations of the rotation and translation
 vectors, respectively, and further optimizes them.
 This function returns the rotation and the translation vectors that transform a 3D point expressed in the object
 coordinate frame to the camera coordinate frame, using different methods:
 <ul>
   <li>
  P3P methods (REF: SOLVEPNP_P3P, REF: SOLVEPNP_AP3P): need 4 input points to return a unique solution.
   </li>
   <li>
  REF: SOLVEPNP_IPPE Input points must be &gt;= 4 and object points must be coplanar.
   </li>
   <li>
  REF: SOLVEPNP_IPPE_SQUARE Special case suitable for marker pose estimation.
 Number of input points must be 4. Object points must be defined in the following order:
   </li>
   <li>
  point 0: [-squareLength / 2,  squareLength / 2, 0]
   </li>
   <li>
  point 1: [ squareLength / 2,  squareLength / 2, 0]
   </li>
   <li>
  point 2: [ squareLength / 2, -squareLength / 2, 0]
   </li>
   <li>
  point 3: [-squareLength / 2, -squareLength / 2, 0]
   </li>
   <li>
  for all the other flags, number of input points must be &gt;= 4 and object points can be in any configuration.
   </li>
 </ul>
 The function interally undistorts points with REF: undistortPoints and call REF: cv::solvePnP,
 thus the input are very similar. Check there and Perspective-n-Points is described in REF: calib3d_solvePnP
 for more information.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="fisheye_solvePnP-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fisheye_solvePnP</h4>
<pre>public static&nbsp;boolean&nbsp;fisheye_solvePnP(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                                       boolean&nbsp;useExtrinsicGuess)</pre>
<div class="block">Finds an object pose from 3D-2D point correspondences for fisheye camera moodel.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>objectPoints</code> - Array of object points in the object coordinate space, Nx3 1-channel or
 1xN/Nx1 3-channel, where N is the number of points. vector&lt;Point3d&gt; can be also passed here.</dd>
<dd><code>imagePoints</code> - Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,
 where N is the number of points. vector&lt;Point2d&gt; can be also passed here.</dd>
<dd><code>cameraMatrix</code> - Input camera intrinsic matrix \(\cameramatrix{A}\) .</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients (4x1/1x4).</dd>
<dd><code>rvec</code> - Output rotation vector (see REF: Rodrigues ) that, together with tvec, brings points from
 the model coordinate system to the camera coordinate system.</dd>
<dd><code>tvec</code> - Output translation vector.</dd>
<dd><code>useExtrinsicGuess</code> - Parameter used for #SOLVEPNP_ITERATIVE. If true (1), the function uses
 the provided rvec and tvec values as initial approximations of the rotation and translation
 vectors, respectively, and further optimizes them.
 This function returns the rotation and the translation vectors that transform a 3D point expressed in the object
 coordinate frame to the camera coordinate frame, using different methods:
 <ul>
   <li>
  P3P methods (REF: SOLVEPNP_P3P, REF: SOLVEPNP_AP3P): need 4 input points to return a unique solution.
   </li>
   <li>
  REF: SOLVEPNP_IPPE Input points must be &gt;= 4 and object points must be coplanar.
   </li>
   <li>
  REF: SOLVEPNP_IPPE_SQUARE Special case suitable for marker pose estimation.
 Number of input points must be 4. Object points must be defined in the following order:
   </li>
   <li>
  point 0: [-squareLength / 2,  squareLength / 2, 0]
   </li>
   <li>
  point 1: [ squareLength / 2,  squareLength / 2, 0]
   </li>
   <li>
  point 2: [ squareLength / 2, -squareLength / 2, 0]
   </li>
   <li>
  point 3: [-squareLength / 2, -squareLength / 2, 0]
   </li>
   <li>
  for all the other flags, number of input points must be &gt;= 4 and object points can be in any configuration.
   </li>
 </ul>
 The function interally undistorts points with REF: undistortPoints and call REF: cv::solvePnP,
 thus the input are very similar. Check there and Perspective-n-Points is described in REF: calib3d_solvePnP
 for more information.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="fisheye_solvePnP-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-boolean-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fisheye_solvePnP</h4>
<pre>public static&nbsp;boolean&nbsp;fisheye_solvePnP(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                                       boolean&nbsp;useExtrinsicGuess,
                                       int&nbsp;flags)</pre>
<div class="block">Finds an object pose from 3D-2D point correspondences for fisheye camera moodel.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>objectPoints</code> - Array of object points in the object coordinate space, Nx3 1-channel or
 1xN/Nx1 3-channel, where N is the number of points. vector&lt;Point3d&gt; can be also passed here.</dd>
<dd><code>imagePoints</code> - Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,
 where N is the number of points. vector&lt;Point2d&gt; can be also passed here.</dd>
<dd><code>cameraMatrix</code> - Input camera intrinsic matrix \(\cameramatrix{A}\) .</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients (4x1/1x4).</dd>
<dd><code>rvec</code> - Output rotation vector (see REF: Rodrigues ) that, together with tvec, brings points from
 the model coordinate system to the camera coordinate system.</dd>
<dd><code>tvec</code> - Output translation vector.</dd>
<dd><code>useExtrinsicGuess</code> - Parameter used for #SOLVEPNP_ITERATIVE. If true (1), the function uses
 the provided rvec and tvec values as initial approximations of the rotation and translation
 vectors, respectively, and further optimizes them.</dd>
<dd><code>flags</code> - Method for solving a PnP problem: see REF: calib3d_solvePnP_flags
 This function returns the rotation and the translation vectors that transform a 3D point expressed in the object
 coordinate frame to the camera coordinate frame, using different methods:
 <ul>
   <li>
  P3P methods (REF: SOLVEPNP_P3P, REF: SOLVEPNP_AP3P): need 4 input points to return a unique solution.
   </li>
   <li>
  REF: SOLVEPNP_IPPE Input points must be &gt;= 4 and object points must be coplanar.
   </li>
   <li>
  REF: SOLVEPNP_IPPE_SQUARE Special case suitable for marker pose estimation.
 Number of input points must be 4. Object points must be defined in the following order:
   </li>
   <li>
  point 0: [-squareLength / 2,  squareLength / 2, 0]
   </li>
   <li>
  point 1: [ squareLength / 2,  squareLength / 2, 0]
   </li>
   <li>
  point 2: [ squareLength / 2, -squareLength / 2, 0]
   </li>
   <li>
  point 3: [-squareLength / 2, -squareLength / 2, 0]
   </li>
   <li>
  for all the other flags, number of input points must be &gt;= 4 and object points can be in any configuration.
   </li>
 </ul>
 The function interally undistorts points with REF: undistortPoints and call REF: cv::solvePnP,
 thus the input are very similar. Check there and Perspective-n-Points is described in REF: calib3d_solvePnP
 for more information.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="fisheye_solvePnP-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-boolean-int-org.opencv.core.TermCriteria-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fisheye_solvePnP</h4>
<pre>public static&nbsp;boolean&nbsp;fisheye_solvePnP(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                                       boolean&nbsp;useExtrinsicGuess,
                                       int&nbsp;flags,
                                       <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria)</pre>
<div class="block">Finds an object pose from 3D-2D point correspondences for fisheye camera moodel.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>objectPoints</code> - Array of object points in the object coordinate space, Nx3 1-channel or
 1xN/Nx1 3-channel, where N is the number of points. vector&lt;Point3d&gt; can be also passed here.</dd>
<dd><code>imagePoints</code> - Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,
 where N is the number of points. vector&lt;Point2d&gt; can be also passed here.</dd>
<dd><code>cameraMatrix</code> - Input camera intrinsic matrix \(\cameramatrix{A}\) .</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients (4x1/1x4).</dd>
<dd><code>rvec</code> - Output rotation vector (see REF: Rodrigues ) that, together with tvec, brings points from
 the model coordinate system to the camera coordinate system.</dd>
<dd><code>tvec</code> - Output translation vector.</dd>
<dd><code>useExtrinsicGuess</code> - Parameter used for #SOLVEPNP_ITERATIVE. If true (1), the function uses
 the provided rvec and tvec values as initial approximations of the rotation and translation
 vectors, respectively, and further optimizes them.</dd>
<dd><code>flags</code> - Method for solving a PnP problem: see REF: calib3d_solvePnP_flags
 This function returns the rotation and the translation vectors that transform a 3D point expressed in the object
 coordinate frame to the camera coordinate frame, using different methods:
 <ul>
   <li>
  P3P methods (REF: SOLVEPNP_P3P, REF: SOLVEPNP_AP3P): need 4 input points to return a unique solution.
   </li>
   <li>
  REF: SOLVEPNP_IPPE Input points must be &gt;= 4 and object points must be coplanar.
   </li>
   <li>
  REF: SOLVEPNP_IPPE_SQUARE Special case suitable for marker pose estimation.
 Number of input points must be 4. Object points must be defined in the following order:
   </li>
   <li>
  point 0: [-squareLength / 2,  squareLength / 2, 0]
   </li>
   <li>
  point 1: [ squareLength / 2,  squareLength / 2, 0]
   </li>
   <li>
  point 2: [ squareLength / 2, -squareLength / 2, 0]
   </li>
   <li>
  point 3: [-squareLength / 2, -squareLength / 2, 0]
   </li>
   <li>
  for all the other flags, number of input points must be &gt;= 4 and object points can be in any configuration.
   </li>
 </ul></dd>
<dd><code>criteria</code> - Termination criteria for internal undistortPoints call.
 The function interally undistorts points with REF: undistortPoints and call REF: cv::solvePnP,
 thus the input are very similar. Check there and Perspective-n-Points is described in REF: calib3d_solvePnP
 for more information.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="fisheye_undistortImage-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fisheye_undistortImage</h4>
<pre>public static&nbsp;void&nbsp;fisheye_undistortImage(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distorted,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;undistorted,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;D)</pre>
<div class="block">Transforms an image to compensate for fisheye lens distortion.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>distorted</code> - image with fisheye lens distortion.</dd>
<dd><code>undistorted</code> - Output image with compensated fisheye lens distortion.</dd>
<dd><code>K</code> - Camera intrinsic matrix \(cameramatrix{K}\).</dd>
<dd><code>D</code> - Input vector of distortion coefficients \(\distcoeffsfisheye\).
 may additionally scale and shift the result by using a different matrix.

 The function transforms an image to compensate radial and tangential lens distortion.

 The function is simply a combination of fisheye::initUndistortRectifyMap (with unity R ) and remap
 (with bilinear interpolation). See the former function for details of the transformation being
 performed.

 See below the results of undistortImage.
 <ul>
   <li>
       a\) result of undistort of perspective camera model (all possible coefficients (k_1, k_2, k_3,
         k_4, k_5, k_6) of distortion were optimized under calibration)
   <ul>
     <li>
        b\) result of fisheye::undistortImage of fisheye camera model (all possible coefficients (k_1, k_2,
         k_3, k_4) of fisheye distortion were optimized under calibration)
     </li>
     <li>
        c\) original image was captured with fisheye lens
     </li>
   </ul>

 Pictures a) and b) almost the same. But if we consider points of image located far from the center
 of image, we can notice that on image a) these points are distorted.
   </li>
 </ul>

 ![image](pics/fisheye_undistorted.jpg)</dd>
</dl>
</li>
</ul>
<a name="fisheye_undistortImage-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fisheye_undistortImage</h4>
<pre>public static&nbsp;void&nbsp;fisheye_undistortImage(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distorted,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;undistorted,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;D,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Knew)</pre>
<div class="block">Transforms an image to compensate for fisheye lens distortion.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>distorted</code> - image with fisheye lens distortion.</dd>
<dd><code>undistorted</code> - Output image with compensated fisheye lens distortion.</dd>
<dd><code>K</code> - Camera intrinsic matrix \(cameramatrix{K}\).</dd>
<dd><code>D</code> - Input vector of distortion coefficients \(\distcoeffsfisheye\).</dd>
<dd><code>Knew</code> - Camera intrinsic matrix of the distorted image. By default, it is the identity matrix but you
 may additionally scale and shift the result by using a different matrix.

 The function transforms an image to compensate radial and tangential lens distortion.

 The function is simply a combination of fisheye::initUndistortRectifyMap (with unity R ) and remap
 (with bilinear interpolation). See the former function for details of the transformation being
 performed.

 See below the results of undistortImage.
 <ul>
   <li>
       a\) result of undistort of perspective camera model (all possible coefficients (k_1, k_2, k_3,
         k_4, k_5, k_6) of distortion were optimized under calibration)
   <ul>
     <li>
        b\) result of fisheye::undistortImage of fisheye camera model (all possible coefficients (k_1, k_2,
         k_3, k_4) of fisheye distortion were optimized under calibration)
     </li>
     <li>
        c\) original image was captured with fisheye lens
     </li>
   </ul>

 Pictures a) and b) almost the same. But if we consider points of image located far from the center
 of image, we can notice that on image a) these points are distorted.
   </li>
 </ul>

 ![image](pics/fisheye_undistorted.jpg)</dd>
</dl>
</li>
</ul>
<a name="fisheye_undistortImage-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fisheye_undistortImage</h4>
<pre>public static&nbsp;void&nbsp;fisheye_undistortImage(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distorted,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;undistorted,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;D,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Knew,
                                          <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;new_size)</pre>
<div class="block">Transforms an image to compensate for fisheye lens distortion.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>distorted</code> - image with fisheye lens distortion.</dd>
<dd><code>undistorted</code> - Output image with compensated fisheye lens distortion.</dd>
<dd><code>K</code> - Camera intrinsic matrix \(cameramatrix{K}\).</dd>
<dd><code>D</code> - Input vector of distortion coefficients \(\distcoeffsfisheye\).</dd>
<dd><code>Knew</code> - Camera intrinsic matrix of the distorted image. By default, it is the identity matrix but you
 may additionally scale and shift the result by using a different matrix.</dd>
<dd><code>new_size</code> - the new size

 The function transforms an image to compensate radial and tangential lens distortion.

 The function is simply a combination of fisheye::initUndistortRectifyMap (with unity R ) and remap
 (with bilinear interpolation). See the former function for details of the transformation being
 performed.

 See below the results of undistortImage.
 <ul>
   <li>
       a\) result of undistort of perspective camera model (all possible coefficients (k_1, k_2, k_3,
         k_4, k_5, k_6) of distortion were optimized under calibration)
   <ul>
     <li>
        b\) result of fisheye::undistortImage of fisheye camera model (all possible coefficients (k_1, k_2,
         k_3, k_4) of fisheye distortion were optimized under calibration)
     </li>
     <li>
        c\) original image was captured with fisheye lens
     </li>
   </ul>

 Pictures a) and b) almost the same. But if we consider points of image located far from the center
 of image, we can notice that on image a) these points are distorted.
   </li>
 </ul>

 ![image](pics/fisheye_undistorted.jpg)</dd>
</dl>
</li>
</ul>
<a name="fisheye_undistortPoints-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fisheye_undistortPoints</h4>
<pre>public static&nbsp;void&nbsp;fisheye_undistortPoints(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distorted,
                                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;undistorted,
                                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;D)</pre>
<div class="block">Undistorts 2D points using fisheye model</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>distorted</code> - Array of object points, 1xN/Nx1 2-channel (or vector&lt;Point2f&gt; ), where N is the
 number of points in the view.</dd>
<dd><code>K</code> - Camera intrinsic matrix \(cameramatrix{K}\).</dd>
<dd><code>D</code> - Input vector of distortion coefficients \(\distcoeffsfisheye\).
 1-channel or 1x1 3-channel</dd>
<dd><code>undistorted</code> - Output array of image points, 1xN/Nx1 2-channel, or vector&lt;Point2f&gt; .</dd>
</dl>
</li>
</ul>
<a name="fisheye_undistortPoints-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fisheye_undistortPoints</h4>
<pre>public static&nbsp;void&nbsp;fisheye_undistortPoints(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distorted,
                                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;undistorted,
                                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;D,
                                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R)</pre>
<div class="block">Undistorts 2D points using fisheye model</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>distorted</code> - Array of object points, 1xN/Nx1 2-channel (or vector&lt;Point2f&gt; ), where N is the
 number of points in the view.</dd>
<dd><code>K</code> - Camera intrinsic matrix \(cameramatrix{K}\).</dd>
<dd><code>D</code> - Input vector of distortion coefficients \(\distcoeffsfisheye\).</dd>
<dd><code>R</code> - Rectification transformation in the object space: 3x3 1-channel, or vector: 3x1/1x3
 1-channel or 1x1 3-channel</dd>
<dd><code>undistorted</code> - Output array of image points, 1xN/Nx1 2-channel, or vector&lt;Point2f&gt; .</dd>
</dl>
</li>
</ul>
<a name="fisheye_undistortPoints-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fisheye_undistortPoints</h4>
<pre>public static&nbsp;void&nbsp;fisheye_undistortPoints(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distorted,
                                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;undistorted,
                                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;D,
                                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
                                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;P)</pre>
<div class="block">Undistorts 2D points using fisheye model</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>distorted</code> - Array of object points, 1xN/Nx1 2-channel (or vector&lt;Point2f&gt; ), where N is the
 number of points in the view.</dd>
<dd><code>K</code> - Camera intrinsic matrix \(cameramatrix{K}\).</dd>
<dd><code>D</code> - Input vector of distortion coefficients \(\distcoeffsfisheye\).</dd>
<dd><code>R</code> - Rectification transformation in the object space: 3x3 1-channel, or vector: 3x1/1x3
 1-channel or 1x1 3-channel</dd>
<dd><code>P</code> - New camera intrinsic matrix (3x3) or new projection matrix (3x4)</dd>
<dd><code>undistorted</code> - Output array of image points, 1xN/Nx1 2-channel, or vector&lt;Point2f&gt; .</dd>
</dl>
</li>
</ul>
<a name="fisheye_undistortPoints-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.TermCriteria-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fisheye_undistortPoints</h4>
<pre>public static&nbsp;void&nbsp;fisheye_undistortPoints(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distorted,
                                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;undistorted,
                                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;K,
                                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;D,
                                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
                                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;P,
                                           <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria)</pre>
<div class="block">Undistorts 2D points using fisheye model</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>distorted</code> - Array of object points, 1xN/Nx1 2-channel (or vector&lt;Point2f&gt; ), where N is the
 number of points in the view.</dd>
<dd><code>K</code> - Camera intrinsic matrix \(cameramatrix{K}\).</dd>
<dd><code>D</code> - Input vector of distortion coefficients \(\distcoeffsfisheye\).</dd>
<dd><code>R</code> - Rectification transformation in the object space: 3x3 1-channel, or vector: 3x1/1x3
 1-channel or 1x1 3-channel</dd>
<dd><code>P</code> - New camera intrinsic matrix (3x3) or new projection matrix (3x4)</dd>
<dd><code>criteria</code> - Termination criteria</dd>
<dd><code>undistorted</code> - Output array of image points, 1xN/Nx1 2-channel, or vector&lt;Point2f&gt; .</dd>
</dl>
</li>
</ul>
<a name="getDefaultNewCameraMatrix-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDefaultNewCameraMatrix</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;getDefaultNewCameraMatrix(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix)</pre>
<div class="block">Returns the default new camera matrix.

 The function returns the camera matrix that is either an exact copy of the input cameraMatrix (when
 centerPrinicipalPoint=false ), or the modified one (when centerPrincipalPoint=true).

 In the latter case, the new camera matrix will be:

 \(\begin{bmatrix} f_x &amp;&amp; 0 &amp;&amp; ( \texttt{imgSize.width} -1)*0.5  \\ 0 &amp;&amp; f_y &amp;&amp; ( \texttt{imgSize.height} -1)*0.5  \\ 0 &amp;&amp; 0 &amp;&amp; 1 \end{bmatrix} ,\)

 where \(f_x\) and \(f_y\) are \((0,0)\) and \((1,1)\) elements of cameraMatrix, respectively.

 By default, the undistortion functions in OpenCV (see #initUndistortRectifyMap, #undistort) do not
 move the principal point. However, when you work with stereo, it is important to move the principal
 points in both views to the same y-coordinate (which is required by most of stereo correspondence
 algorithms), and may be to the same x-coordinate too. So, you can form the new camera matrix for
 each view where the principal points are located at the center.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>cameraMatrix</code> - Input camera matrix.
 parameter indicates whether this location should be at the image center or not.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="getDefaultNewCameraMatrix-org.opencv.core.Mat-org.opencv.core.Size-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDefaultNewCameraMatrix</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;getDefaultNewCameraMatrix(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                            <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;imgsize)</pre>
<div class="block">Returns the default new camera matrix.

 The function returns the camera matrix that is either an exact copy of the input cameraMatrix (when
 centerPrinicipalPoint=false ), or the modified one (when centerPrincipalPoint=true).

 In the latter case, the new camera matrix will be:

 \(\begin{bmatrix} f_x &amp;&amp; 0 &amp;&amp; ( \texttt{imgSize.width} -1)*0.5  \\ 0 &amp;&amp; f_y &amp;&amp; ( \texttt{imgSize.height} -1)*0.5  \\ 0 &amp;&amp; 0 &amp;&amp; 1 \end{bmatrix} ,\)

 where \(f_x\) and \(f_y\) are \((0,0)\) and \((1,1)\) elements of cameraMatrix, respectively.

 By default, the undistortion functions in OpenCV (see #initUndistortRectifyMap, #undistort) do not
 move the principal point. However, when you work with stereo, it is important to move the principal
 points in both views to the same y-coordinate (which is required by most of stereo correspondence
 algorithms), and may be to the same x-coordinate too. So, you can form the new camera matrix for
 each view where the principal points are located at the center.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>cameraMatrix</code> - Input camera matrix.</dd>
<dd><code>imgsize</code> - Camera view image size in pixels.
 parameter indicates whether this location should be at the image center or not.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="getDefaultNewCameraMatrix-org.opencv.core.Mat-org.opencv.core.Size-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDefaultNewCameraMatrix</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;getDefaultNewCameraMatrix(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                            <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;imgsize,
                                            boolean&nbsp;centerPrincipalPoint)</pre>
<div class="block">Returns the default new camera matrix.

 The function returns the camera matrix that is either an exact copy of the input cameraMatrix (when
 centerPrinicipalPoint=false ), or the modified one (when centerPrincipalPoint=true).

 In the latter case, the new camera matrix will be:

 \(\begin{bmatrix} f_x &amp;&amp; 0 &amp;&amp; ( \texttt{imgSize.width} -1)*0.5  \\ 0 &amp;&amp; f_y &amp;&amp; ( \texttt{imgSize.height} -1)*0.5  \\ 0 &amp;&amp; 0 &amp;&amp; 1 \end{bmatrix} ,\)

 where \(f_x\) and \(f_y\) are \((0,0)\) and \((1,1)\) elements of cameraMatrix, respectively.

 By default, the undistortion functions in OpenCV (see #initUndistortRectifyMap, #undistort) do not
 move the principal point. However, when you work with stereo, it is important to move the principal
 points in both views to the same y-coordinate (which is required by most of stereo correspondence
 algorithms), and may be to the same x-coordinate too. So, you can form the new camera matrix for
 each view where the principal points are located at the center.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>cameraMatrix</code> - Input camera matrix.</dd>
<dd><code>imgsize</code> - Camera view image size in pixels.</dd>
<dd><code>centerPrincipalPoint</code> - Location of the principal point in the new camera matrix. The
 parameter indicates whether this location should be at the image center or not.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="getOptimalNewCameraMatrix-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOptimalNewCameraMatrix</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;getOptimalNewCameraMatrix(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                                            <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;imageSize,
                                            double&nbsp;alpha)</pre>
<div class="block">Returns the new camera intrinsic matrix based on the free scaling parameter.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>cameraMatrix</code> - Input camera intrinsic matrix.</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are
 assumed.</dd>
<dd><code>imageSize</code> - Original image size.</dd>
<dd><code>alpha</code> - Free scaling parameter between 0 (when all the pixels in the undistorted image are
 valid) and 1 (when all the source image pixels are retained in the undistorted image). See
 #stereoRectify for details.
 undistorted image. See roi1, roi2 description in #stereoRectify .
 principal point should be at the image center or not. By default, the principal point is chosen to
 best fit a subset of the source image (determined by alpha) to the corrected image.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>new_camera_matrix Output new camera intrinsic matrix.

 The function computes and returns the optimal new camera intrinsic matrix based on the free scaling parameter.
 By varying this parameter, you may retrieve only sensible pixels alpha=0 , keep all the original
 image pixels if there is valuable information in the corners alpha=1 , or get something in between.
 When alpha&gt;0 , the undistorted result is likely to have some black pixels corresponding to
 "virtual" pixels outside of the captured distorted image. The original camera intrinsic matrix, distortion
 coefficients, the computed new camera intrinsic matrix, and newImageSize should be passed to
 #initUndistortRectifyMap to produce the maps for #remap .</dd>
</dl>
</li>
</ul>
<a name="getOptimalNewCameraMatrix-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-double-org.opencv.core.Size-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOptimalNewCameraMatrix</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;getOptimalNewCameraMatrix(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                                            <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;imageSize,
                                            double&nbsp;alpha,
                                            <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;newImgSize)</pre>
<div class="block">Returns the new camera intrinsic matrix based on the free scaling parameter.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>cameraMatrix</code> - Input camera intrinsic matrix.</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are
 assumed.</dd>
<dd><code>imageSize</code> - Original image size.</dd>
<dd><code>alpha</code> - Free scaling parameter between 0 (when all the pixels in the undistorted image are
 valid) and 1 (when all the source image pixels are retained in the undistorted image). See
 #stereoRectify for details.</dd>
<dd><code>newImgSize</code> - Image size after rectification. By default, it is set to imageSize .
 undistorted image. See roi1, roi2 description in #stereoRectify .
 principal point should be at the image center or not. By default, the principal point is chosen to
 best fit a subset of the source image (determined by alpha) to the corrected image.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>new_camera_matrix Output new camera intrinsic matrix.

 The function computes and returns the optimal new camera intrinsic matrix based on the free scaling parameter.
 By varying this parameter, you may retrieve only sensible pixels alpha=0 , keep all the original
 image pixels if there is valuable information in the corners alpha=1 , or get something in between.
 When alpha&gt;0 , the undistorted result is likely to have some black pixels corresponding to
 "virtual" pixels outside of the captured distorted image. The original camera intrinsic matrix, distortion
 coefficients, the computed new camera intrinsic matrix, and newImageSize should be passed to
 #initUndistortRectifyMap to produce the maps for #remap .</dd>
</dl>
</li>
</ul>
<a name="getOptimalNewCameraMatrix-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-double-org.opencv.core.Size-org.opencv.core.Rect-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOptimalNewCameraMatrix</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;getOptimalNewCameraMatrix(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                                            <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;imageSize,
                                            double&nbsp;alpha,
                                            <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;newImgSize,
                                            <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;validPixROI)</pre>
<div class="block">Returns the new camera intrinsic matrix based on the free scaling parameter.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>cameraMatrix</code> - Input camera intrinsic matrix.</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are
 assumed.</dd>
<dd><code>imageSize</code> - Original image size.</dd>
<dd><code>alpha</code> - Free scaling parameter between 0 (when all the pixels in the undistorted image are
 valid) and 1 (when all the source image pixels are retained in the undistorted image). See
 #stereoRectify for details.</dd>
<dd><code>newImgSize</code> - Image size after rectification. By default, it is set to imageSize .</dd>
<dd><code>validPixROI</code> - Optional output rectangle that outlines all-good-pixels region in the
 undistorted image. See roi1, roi2 description in #stereoRectify .
 principal point should be at the image center or not. By default, the principal point is chosen to
 best fit a subset of the source image (determined by alpha) to the corrected image.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>new_camera_matrix Output new camera intrinsic matrix.

 The function computes and returns the optimal new camera intrinsic matrix based on the free scaling parameter.
 By varying this parameter, you may retrieve only sensible pixels alpha=0 , keep all the original
 image pixels if there is valuable information in the corners alpha=1 , or get something in between.
 When alpha&gt;0 , the undistorted result is likely to have some black pixels corresponding to
 "virtual" pixels outside of the captured distorted image. The original camera intrinsic matrix, distortion
 coefficients, the computed new camera intrinsic matrix, and newImageSize should be passed to
 #initUndistortRectifyMap to produce the maps for #remap .</dd>
</dl>
</li>
</ul>
<a name="getOptimalNewCameraMatrix-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-double-org.opencv.core.Size-org.opencv.core.Rect-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOptimalNewCameraMatrix</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;getOptimalNewCameraMatrix(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                                            <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;imageSize,
                                            double&nbsp;alpha,
                                            <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;newImgSize,
                                            <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;validPixROI,
                                            boolean&nbsp;centerPrincipalPoint)</pre>
<div class="block">Returns the new camera intrinsic matrix based on the free scaling parameter.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>cameraMatrix</code> - Input camera intrinsic matrix.</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are
 assumed.</dd>
<dd><code>imageSize</code> - Original image size.</dd>
<dd><code>alpha</code> - Free scaling parameter between 0 (when all the pixels in the undistorted image are
 valid) and 1 (when all the source image pixels are retained in the undistorted image). See
 #stereoRectify for details.</dd>
<dd><code>newImgSize</code> - Image size after rectification. By default, it is set to imageSize .</dd>
<dd><code>validPixROI</code> - Optional output rectangle that outlines all-good-pixels region in the
 undistorted image. See roi1, roi2 description in #stereoRectify .</dd>
<dd><code>centerPrincipalPoint</code> - Optional flag that indicates whether in the new camera intrinsic matrix the
 principal point should be at the image center or not. By default, the principal point is chosen to
 best fit a subset of the source image (determined by alpha) to the corrected image.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>new_camera_matrix Output new camera intrinsic matrix.

 The function computes and returns the optimal new camera intrinsic matrix based on the free scaling parameter.
 By varying this parameter, you may retrieve only sensible pixels alpha=0 , keep all the original
 image pixels if there is valuable information in the corners alpha=1 , or get something in between.
 When alpha&gt;0 , the undistorted result is likely to have some black pixels corresponding to
 "virtual" pixels outside of the captured distorted image. The original camera intrinsic matrix, distortion
 coefficients, the computed new camera intrinsic matrix, and newImageSize should be passed to
 #initUndistortRectifyMap to produce the maps for #remap .</dd>
</dl>
</li>
</ul>
<a name="initInverseRectificationMap-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-int-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>initInverseRectificationMap</h4>
<pre>public static&nbsp;void&nbsp;initInverseRectificationMap(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
                                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;newCameraMatrix,
                                               <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;size,
                                               int&nbsp;m1type,
                                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map1,
                                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map2)</pre>
<div class="block">Computes the projection and inverse-rectification transformation map. In essense, this is the inverse of
 #initUndistortRectifyMap to accomodate stereo-rectification of projectors ('inverse-cameras') in projector-camera pairs.

 The function computes the joint projection and inverse rectification transformation and represents the
 result in the form of maps for #remap. The projected image looks like a distorted version of the original which,
 once projected by a projector, should visually match the original. In case of a monocular camera, newCameraMatrix
 is usually equal to cameraMatrix, or it can be computed by
 #getOptimalNewCameraMatrix for a better control over scaling. In case of a projector-camera pair,
 newCameraMatrix is normally set to P1 or P2 computed by #stereoRectify .

 The projector is oriented differently in the coordinate space, according to R. In case of projector-camera pairs,
 this helps align the projector (in the same manner as #initUndistortRectifyMap for the camera) to create a stereo-rectified pair. This
 allows epipolar lines on both images to become horizontal and have the same y-coordinate (in case of a horizontally aligned projector-camera pair).

 The function builds the maps for the inverse mapping algorithm that is used by #remap. That
 is, for each pixel \((u, v)\) in the destination (projected and inverse-rectified) image, the function
 computes the corresponding coordinates in the source image (that is, in the original digital image). The following process is applied:

 \(
 \begin{array}{l}
 \text{newCameraMatrix}\\
 x  \leftarrow (u - {c'}_x)/{f'}_x  \\
 y  \leftarrow (v - {c'}_y)/{f'}_y  \\

 \\\text{Undistortion}
 \\\scriptsize{\textit{though equation shown is for radial undistortion, function implements cv::undistortPoints()}}\\
 r^2  \leftarrow x^2 + y^2 \\
 \theta \leftarrow \frac{1 + k_1 r^2 + k_2 r^4 + k_3 r^6}{1 + k_4 r^2 + k_5 r^4 + k_6 r^6}\\
 x' \leftarrow \frac{x}{\theta} \\
 y'  \leftarrow \frac{y}{\theta} \\

 \\\text{Rectification}\\
 {[X\,Y\,W]} ^T  \leftarrow R*[x' \, y' \, 1]^T  \\
 x''  \leftarrow X/W  \\
 y''  \leftarrow Y/W  \\

 \\\text{cameraMatrix}\\
 map_x(u,v)  \leftarrow x'' f_x + c_x  \\
 map_y(u,v)  \leftarrow y'' f_y + c_y
 \end{array}
 \)
 where \((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\)
 are the distortion coefficients vector distCoeffs.

 In case of a stereo-rectified projector-camera pair, this function is called for the projector while #initUndistortRectifyMap is called for the camera head.
 This is done after #stereoRectify, which in turn is called after #stereoCalibrate. If the projector-camera pair
 is not calibrated, it is still possible to compute the rectification transformations directly from
 the fundamental matrix using #stereoRectifyUncalibrated. For the projector and camera, the function computes
 homography H as the rectification transformation in a pixel domain, not a rotation matrix R in 3D
 space. R can be computed from H as
 \(\texttt{R} = \texttt{cameraMatrix} ^{-1} \cdot \texttt{H} \cdot \texttt{cameraMatrix}\)
 where cameraMatrix can be chosen arbitrarily.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>cameraMatrix</code> - Input camera matrix \(A=\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\) .</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\)
 of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</dd>
<dd><code>R</code> - Optional rectification transformation in the object space (3x3 matrix). R1 or R2,
 computed by #stereoRectify can be passed here. If the matrix is empty, the identity transformation
 is assumed.</dd>
<dd><code>newCameraMatrix</code> - New camera matrix \(A'=\vecthreethree{f_x'}{0}{c_x'}{0}{f_y'}{c_y'}{0}{0}{1}\).</dd>
<dd><code>size</code> - Distorted image size.</dd>
<dd><code>m1type</code> - Type of the first output map. Can be CV_32FC1, CV_32FC2 or CV_16SC2, see #convertMaps</dd>
<dd><code>map1</code> - The first output map for #remap.</dd>
<dd><code>map2</code> - The second output map for #remap.</dd>
</dl>
</li>
</ul>
<a name="initUndistortRectifyMap-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-int-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>initUndistortRectifyMap</h4>
<pre>public static&nbsp;void&nbsp;initUndistortRectifyMap(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
                                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;newCameraMatrix,
                                           <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;size,
                                           int&nbsp;m1type,
                                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map1,
                                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map2)</pre>
<div class="block">Computes the undistortion and rectification transformation map.

 The function computes the joint undistortion and rectification transformation and represents the
 result in the form of maps for #remap. The undistorted image looks like original, as if it is
 captured with a camera using the camera matrix =newCameraMatrix and zero distortion. In case of a
 monocular camera, newCameraMatrix is usually equal to cameraMatrix, or it can be computed by
 #getOptimalNewCameraMatrix for a better control over scaling. In case of a stereo camera,
 newCameraMatrix is normally set to P1 or P2 computed by #stereoRectify .

 Also, this new camera is oriented differently in the coordinate space, according to R. That, for
 example, helps to align two heads of a stereo camera so that the epipolar lines on both images
 become horizontal and have the same y- coordinate (in case of a horizontally aligned stereo camera).

 The function actually builds the maps for the inverse mapping algorithm that is used by #remap. That
 is, for each pixel \((u, v)\) in the destination (corrected and rectified) image, the function
 computes the corresponding coordinates in the source image (that is, in the original image from
 camera). The following process is applied:
 \(
 \begin{array}{l}
 x  \leftarrow (u - {c'}_x)/{f'}_x  \\
 y  \leftarrow (v - {c'}_y)/{f'}_y  \\
 {[X\,Y\,W]} ^T  \leftarrow R^{-1}*[x \, y \, 1]^T  \\
 x'  \leftarrow X/W  \\
 y'  \leftarrow Y/W  \\
 r^2  \leftarrow x'^2 + y'^2 \\
 x''  \leftarrow x' \frac{1 + k_1 r^2 + k_2 r^4 + k_3 r^6}{1 + k_4 r^2 + k_5 r^4 + k_6 r^6}
 + 2p_1 x' y' + p_2(r^2 + 2 x'^2)  + s_1 r^2 + s_2 r^4\\
 y''  \leftarrow y' \frac{1 + k_1 r^2 + k_2 r^4 + k_3 r^6}{1 + k_4 r^2 + k_5 r^4 + k_6 r^6}
 + p_1 (r^2 + 2 y'^2) + 2 p_2 x' y' + s_3 r^2 + s_4 r^4 \\
 s\vecthree{x'''}{y'''}{1} =
 \vecthreethree{R_{33}(\tau_x, \tau_y)}{0}{-R_{13}((\tau_x, \tau_y)}
 {0}{R_{33}(\tau_x, \tau_y)}{-R_{23}(\tau_x, \tau_y)}
 {0}{0}{1} R(\tau_x, \tau_y) \vecthree{x''}{y''}{1}\\
 map_x(u,v)  \leftarrow x''' f_x + c_x  \\
 map_y(u,v)  \leftarrow y''' f_y + c_y
 \end{array}
 \)
 where \((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\)
 are the distortion coefficients.

 In case of a stereo camera, this function is called twice: once for each camera head, after
 #stereoRectify, which in its turn is called after #stereoCalibrate. But if the stereo camera
 was not calibrated, it is still possible to compute the rectification transformations directly from
 the fundamental matrix using #stereoRectifyUncalibrated. For each camera, the function computes
 homography H as the rectification transformation in a pixel domain, not a rotation matrix R in 3D
 space. R can be computed from H as
 \(\texttt{R} = \texttt{cameraMatrix} ^{-1} \cdot \texttt{H} \cdot \texttt{cameraMatrix}\)
 where cameraMatrix can be chosen arbitrarily.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>cameraMatrix</code> - Input camera matrix \(A=\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\) .</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\)
 of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</dd>
<dd><code>R</code> - Optional rectification transformation in the object space (3x3 matrix). R1 or R2 ,
 computed by #stereoRectify can be passed here. If the matrix is empty, the identity transformation
 is assumed. In #initUndistortRectifyMap R assumed to be an identity matrix.</dd>
<dd><code>newCameraMatrix</code> - New camera matrix \(A'=\vecthreethree{f_x'}{0}{c_x'}{0}{f_y'}{c_y'}{0}{0}{1}\).</dd>
<dd><code>size</code> - Undistorted image size.</dd>
<dd><code>m1type</code> - Type of the first output map that can be CV_32FC1, CV_32FC2 or CV_16SC2, see #convertMaps</dd>
<dd><code>map1</code> - The first output map.</dd>
<dd><code>map2</code> - The second output map.</dd>
</dl>
</li>
</ul>
<a name="loadMesh-java.lang.String-org.opencv.core.Mat-java.util.List-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>loadMesh</h4>
<pre>public static&nbsp;void&nbsp;loadMesh(java.lang.String&nbsp;filename,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices,
                            java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;indices)</pre>
<div class="block">Loads a mesh from a file.

 The function loads mesh from the specified file and returns it.
 If the mesh cannot be read, throws an error
 Vertex attributes (i.e. space and texture coodinates, normals and colors) are returned in same-sized
 arrays with corresponding elements having the same indices.
 This means that if a face uses a vertex with a normal or a texture coordinate with different indices
 (which is typical for OBJ files for example), this vertex will be duplicated for each face it uses.

 Currently, the following file formats are supported:
 -  [Wavefront obj file *.obj](https://en.wikipedia.org/wiki/Wavefront_.obj_file) (ONLY TRIANGULATED FACES)
 -  [Polygon File Format *.ply](https://en.wikipedia.org/wiki/PLY_(file_format))</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>filename</code> - Name of the file</dd>
<dd><code>vertices</code> - vertex coordinates, each value contains 3 floats</dd>
<dd><code>indices</code> - per-face list of vertices, each value is a vector of ints</dd>
</dl>
</li>
</ul>
<a name="loadMesh-java.lang.String-org.opencv.core.Mat-java.util.List-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>loadMesh</h4>
<pre>public static&nbsp;void&nbsp;loadMesh(java.lang.String&nbsp;filename,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices,
                            java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;indices,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;normals)</pre>
<div class="block">Loads a mesh from a file.

 The function loads mesh from the specified file and returns it.
 If the mesh cannot be read, throws an error
 Vertex attributes (i.e. space and texture coodinates, normals and colors) are returned in same-sized
 arrays with corresponding elements having the same indices.
 This means that if a face uses a vertex with a normal or a texture coordinate with different indices
 (which is typical for OBJ files for example), this vertex will be duplicated for each face it uses.

 Currently, the following file formats are supported:
 -  [Wavefront obj file *.obj](https://en.wikipedia.org/wiki/Wavefront_.obj_file) (ONLY TRIANGULATED FACES)
 -  [Polygon File Format *.ply](https://en.wikipedia.org/wiki/PLY_(file_format))</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>filename</code> - Name of the file</dd>
<dd><code>vertices</code> - vertex coordinates, each value contains 3 floats</dd>
<dd><code>indices</code> - per-face list of vertices, each value is a vector of ints</dd>
<dd><code>normals</code> - per-vertex normals, each value contains 3 floats</dd>
</dl>
</li>
</ul>
<a name="loadMesh-java.lang.String-org.opencv.core.Mat-java.util.List-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>loadMesh</h4>
<pre>public static&nbsp;void&nbsp;loadMesh(java.lang.String&nbsp;filename,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices,
                            java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;indices,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;normals,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;colors)</pre>
<div class="block">Loads a mesh from a file.

 The function loads mesh from the specified file and returns it.
 If the mesh cannot be read, throws an error
 Vertex attributes (i.e. space and texture coodinates, normals and colors) are returned in same-sized
 arrays with corresponding elements having the same indices.
 This means that if a face uses a vertex with a normal or a texture coordinate with different indices
 (which is typical for OBJ files for example), this vertex will be duplicated for each face it uses.

 Currently, the following file formats are supported:
 -  [Wavefront obj file *.obj](https://en.wikipedia.org/wiki/Wavefront_.obj_file) (ONLY TRIANGULATED FACES)
 -  [Polygon File Format *.ply](https://en.wikipedia.org/wiki/PLY_(file_format))</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>filename</code> - Name of the file</dd>
<dd><code>vertices</code> - vertex coordinates, each value contains 3 floats</dd>
<dd><code>indices</code> - per-face list of vertices, each value is a vector of ints</dd>
<dd><code>normals</code> - per-vertex normals, each value contains 3 floats</dd>
<dd><code>colors</code> - per-vertex colors, each value contains 3 floats</dd>
</dl>
</li>
</ul>
<a name="loadMesh-java.lang.String-org.opencv.core.Mat-java.util.List-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>loadMesh</h4>
<pre>public static&nbsp;void&nbsp;loadMesh(java.lang.String&nbsp;filename,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices,
                            java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;indices,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;normals,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;colors,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;texCoords)</pre>
<div class="block">Loads a mesh from a file.

 The function loads mesh from the specified file and returns it.
 If the mesh cannot be read, throws an error
 Vertex attributes (i.e. space and texture coodinates, normals and colors) are returned in same-sized
 arrays with corresponding elements having the same indices.
 This means that if a face uses a vertex with a normal or a texture coordinate with different indices
 (which is typical for OBJ files for example), this vertex will be duplicated for each face it uses.

 Currently, the following file formats are supported:
 -  [Wavefront obj file *.obj](https://en.wikipedia.org/wiki/Wavefront_.obj_file) (ONLY TRIANGULATED FACES)
 -  [Polygon File Format *.ply](https://en.wikipedia.org/wiki/PLY_(file_format))</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>filename</code> - Name of the file</dd>
<dd><code>vertices</code> - vertex coordinates, each value contains 3 floats</dd>
<dd><code>indices</code> - per-face list of vertices, each value is a vector of ints</dd>
<dd><code>normals</code> - per-vertex normals, each value contains 3 floats</dd>
<dd><code>colors</code> - per-vertex colors, each value contains 3 floats</dd>
<dd><code>texCoords</code> - per-vertex texture coordinates, each value contains 2 or 3 floats</dd>
</dl>
</li>
</ul>
<a name="loadPointCloud-java.lang.String-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>loadPointCloud</h4>
<pre>public static&nbsp;void&nbsp;loadPointCloud(java.lang.String&nbsp;filename,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices)</pre>
<div class="block">Loads a point cloud from a file.

 The function loads point cloud from the specified file and returns it.
 If the cloud cannot be read, throws an error.
 Vertex coordinates, normals and colors are returned as they are saved in the file
 even if these arrays have different sizes and their elements do not correspond to each other
 (which is typical for OBJ files for example)

 Currently, the following file formats are supported:
 -  [Wavefront obj file *.obj](https://en.wikipedia.org/wiki/Wavefront_.obj_file)
 -  [Polygon File Format *.ply](https://en.wikipedia.org/wiki/PLY_(file_format))</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>filename</code> - Name of the file</dd>
<dd><code>vertices</code> - vertex coordinates, each value contains 3 floats</dd>
</dl>
</li>
</ul>
<a name="loadPointCloud-java.lang.String-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>loadPointCloud</h4>
<pre>public static&nbsp;void&nbsp;loadPointCloud(java.lang.String&nbsp;filename,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;normals)</pre>
<div class="block">Loads a point cloud from a file.

 The function loads point cloud from the specified file and returns it.
 If the cloud cannot be read, throws an error.
 Vertex coordinates, normals and colors are returned as they are saved in the file
 even if these arrays have different sizes and their elements do not correspond to each other
 (which is typical for OBJ files for example)

 Currently, the following file formats are supported:
 -  [Wavefront obj file *.obj](https://en.wikipedia.org/wiki/Wavefront_.obj_file)
 -  [Polygon File Format *.ply](https://en.wikipedia.org/wiki/PLY_(file_format))</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>filename</code> - Name of the file</dd>
<dd><code>vertices</code> - vertex coordinates, each value contains 3 floats</dd>
<dd><code>normals</code> - per-vertex normals, each value contains 3 floats</dd>
</dl>
</li>
</ul>
<a name="loadPointCloud-java.lang.String-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>loadPointCloud</h4>
<pre>public static&nbsp;void&nbsp;loadPointCloud(java.lang.String&nbsp;filename,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;normals,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rgb)</pre>
<div class="block">Loads a point cloud from a file.

 The function loads point cloud from the specified file and returns it.
 If the cloud cannot be read, throws an error.
 Vertex coordinates, normals and colors are returned as they are saved in the file
 even if these arrays have different sizes and their elements do not correspond to each other
 (which is typical for OBJ files for example)

 Currently, the following file formats are supported:
 -  [Wavefront obj file *.obj](https://en.wikipedia.org/wiki/Wavefront_.obj_file)
 -  [Polygon File Format *.ply](https://en.wikipedia.org/wiki/PLY_(file_format))</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>filename</code> - Name of the file</dd>
<dd><code>vertices</code> - vertex coordinates, each value contains 3 floats</dd>
<dd><code>normals</code> - per-vertex normals, each value contains 3 floats</dd>
<dd><code>rgb</code> - per-vertex colors, each value contains 3 floats</dd>
</dl>
</li>
</ul>
<a name="matMulDeriv-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>matMulDeriv</h4>
<pre>public static&nbsp;void&nbsp;matMulDeriv(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;A,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;B,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dABdA,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dABdB)</pre>
<div class="block">Computes partial derivatives of the matrix product for each multiplied matrix.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>A</code> - First multiplied matrix.</dd>
<dd><code>B</code> - Second multiplied matrix.</dd>
<dd><code>dABdA</code> - First output derivative matrix d(A\*B)/dA of size
 \(\texttt{A.rows*B.cols} \times {A.rows*A.cols}\) .</dd>
<dd><code>dABdB</code> - Second output derivative matrix d(A\*B)/dB of size
 \(\texttt{A.rows*B.cols} \times {B.rows*B.cols}\) .

 The function computes partial derivatives of the elements of the matrix product \(A*B\) with regard to
 the elements of each of the two input matrices. The function is used to compute the Jacobian
 matrices in #stereoCalibrate but can also be used in any other similar optimization function.</dd>
</dl>
</li>
</ul>
<a name="projectPoints-org.opencv.core.MatOfPoint3f-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.MatOfDouble-org.opencv.core.MatOfPoint2f-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>projectPoints</h4>
<pre>public static&nbsp;void&nbsp;projectPoints(<a href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                 <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
                                 <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints)</pre>
<div class="block">Projects 3D points to an image plane.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>objectPoints</code> - Array of object points expressed wrt. the world coordinate frame. A 3xN/Nx3
 1-channel or 1xN/Nx1 3-channel (or vector&lt;Point3f&gt; ), where N is the number of points in the view.</dd>
<dd><code>rvec</code> - The rotation vector (REF: Rodrigues) that, together with tvec, performs a change of
 basis from world to camera coordinate system, see REF: calibrateCamera for details.</dd>
<dd><code>tvec</code> - The translation vector, see parameter description above.</dd>
<dd><code>cameraMatrix</code> - Camera intrinsic matrix \(\cameramatrix{A}\) .</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \(\distcoeffs\) . If the vector is empty, the zero distortion coefficients are assumed.</dd>
<dd><code>imagePoints</code> - Output array of image points, 1xN/Nx1 2-channel, or
 vector&lt;Point2f&gt; .
 points with respect to components of the rotation vector, translation vector, focal lengths,
 coordinates of the principal point and the distortion coefficients. In the old interface different
 components of the jacobian are returned via different output parameters.
 function assumes that the aspect ratio (\(f_x / f_y\)) is fixed and correspondingly adjusts the
 jacobian matrix.

 The function computes the 2D projections of 3D points to the image plane, given intrinsic and
 extrinsic camera parameters. Optionally, the function computes Jacobians -matrices of partial
 derivatives of image points coordinates (as functions of all the input parameters) with respect to
 the particular parameters, intrinsic and/or extrinsic. The Jacobians are used during the global
 optimization in REF: calibrateCamera, REF: solvePnP, and REF: stereoCalibrate. The function itself
 can also be used to compute a re-projection error, given the current intrinsic and extrinsic
 parameters.

 <b>Note:</b> By setting rvec = tvec = \([0, 0, 0]\), or by setting cameraMatrix to a 3x3 identity matrix,
 or by passing zero distortion coefficients, one can get various useful partial cases of the
 function. This means, one can compute the distorted coordinates for a sparse set of points or apply
 a perspective transformation (and also compute the derivatives) in the ideal zero-distortion setup.</dd>
</dl>
</li>
</ul>
<a name="projectPoints-org.opencv.core.MatOfPoint3f-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.MatOfDouble-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>projectPoints</h4>
<pre>public static&nbsp;void&nbsp;projectPoints(<a href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                 <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
                                 <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;jacobian)</pre>
<div class="block">Projects 3D points to an image plane.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>objectPoints</code> - Array of object points expressed wrt. the world coordinate frame. A 3xN/Nx3
 1-channel or 1xN/Nx1 3-channel (or vector&lt;Point3f&gt; ), where N is the number of points in the view.</dd>
<dd><code>rvec</code> - The rotation vector (REF: Rodrigues) that, together with tvec, performs a change of
 basis from world to camera coordinate system, see REF: calibrateCamera for details.</dd>
<dd><code>tvec</code> - The translation vector, see parameter description above.</dd>
<dd><code>cameraMatrix</code> - Camera intrinsic matrix \(\cameramatrix{A}\) .</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \(\distcoeffs\) . If the vector is empty, the zero distortion coefficients are assumed.</dd>
<dd><code>imagePoints</code> - Output array of image points, 1xN/Nx1 2-channel, or
 vector&lt;Point2f&gt; .</dd>
<dd><code>jacobian</code> - Optional output 2Nx(10+&lt;numDistCoeffs&gt;) jacobian matrix of derivatives of image
 points with respect to components of the rotation vector, translation vector, focal lengths,
 coordinates of the principal point and the distortion coefficients. In the old interface different
 components of the jacobian are returned via different output parameters.
 function assumes that the aspect ratio (\(f_x / f_y\)) is fixed and correspondingly adjusts the
 jacobian matrix.

 The function computes the 2D projections of 3D points to the image plane, given intrinsic and
 extrinsic camera parameters. Optionally, the function computes Jacobians -matrices of partial
 derivatives of image points coordinates (as functions of all the input parameters) with respect to
 the particular parameters, intrinsic and/or extrinsic. The Jacobians are used during the global
 optimization in REF: calibrateCamera, REF: solvePnP, and REF: stereoCalibrate. The function itself
 can also be used to compute a re-projection error, given the current intrinsic and extrinsic
 parameters.

 <b>Note:</b> By setting rvec = tvec = \([0, 0, 0]\), or by setting cameraMatrix to a 3x3 identity matrix,
 or by passing zero distortion coefficients, one can get various useful partial cases of the
 function. This means, one can compute the distorted coordinates for a sparse set of points or apply
 a perspective transformation (and also compute the derivatives) in the ideal zero-distortion setup.</dd>
</dl>
</li>
</ul>
<a name="projectPoints-org.opencv.core.MatOfPoint3f-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.MatOfDouble-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>projectPoints</h4>
<pre>public static&nbsp;void&nbsp;projectPoints(<a href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                 <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
                                 <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;jacobian,
                                 double&nbsp;aspectRatio)</pre>
<div class="block">Projects 3D points to an image plane.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>objectPoints</code> - Array of object points expressed wrt. the world coordinate frame. A 3xN/Nx3
 1-channel or 1xN/Nx1 3-channel (or vector&lt;Point3f&gt; ), where N is the number of points in the view.</dd>
<dd><code>rvec</code> - The rotation vector (REF: Rodrigues) that, together with tvec, performs a change of
 basis from world to camera coordinate system, see REF: calibrateCamera for details.</dd>
<dd><code>tvec</code> - The translation vector, see parameter description above.</dd>
<dd><code>cameraMatrix</code> - Camera intrinsic matrix \(\cameramatrix{A}\) .</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \(\distcoeffs\) . If the vector is empty, the zero distortion coefficients are assumed.</dd>
<dd><code>imagePoints</code> - Output array of image points, 1xN/Nx1 2-channel, or
 vector&lt;Point2f&gt; .</dd>
<dd><code>jacobian</code> - Optional output 2Nx(10+&lt;numDistCoeffs&gt;) jacobian matrix of derivatives of image
 points with respect to components of the rotation vector, translation vector, focal lengths,
 coordinates of the principal point and the distortion coefficients. In the old interface different
 components of the jacobian are returned via different output parameters.</dd>
<dd><code>aspectRatio</code> - Optional "fixed aspect ratio" parameter. If the parameter is not 0, the
 function assumes that the aspect ratio (\(f_x / f_y\)) is fixed and correspondingly adjusts the
 jacobian matrix.

 The function computes the 2D projections of 3D points to the image plane, given intrinsic and
 extrinsic camera parameters. Optionally, the function computes Jacobians -matrices of partial
 derivatives of image points coordinates (as functions of all the input parameters) with respect to
 the particular parameters, intrinsic and/or extrinsic. The Jacobians are used during the global
 optimization in REF: calibrateCamera, REF: solvePnP, and REF: stereoCalibrate. The function itself
 can also be used to compute a re-projection error, given the current intrinsic and extrinsic
 parameters.

 <b>Note:</b> By setting rvec = tvec = \([0, 0, 0]\), or by setting cameraMatrix to a 3x3 identity matrix,
 or by passing zero distortion coefficients, one can get various useful partial cases of the
 function. This means, one can compute the distorted coordinates for a sparse set of points or apply
 a perspective transformation (and also compute the derivatives) in the ideal zero-distortion setup.</dd>
</dl>
</li>
</ul>
<a name="projectPointsSepJ-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>projectPointsSepJ</h4>
<pre>public static&nbsp;void&nbsp;projectPointsSepJ(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdr,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdt)</pre>
</li>
</ul>
<a name="projectPointsSepJ-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>projectPointsSepJ</h4>
<pre>public static&nbsp;void&nbsp;projectPointsSepJ(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdr,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdt,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdf)</pre>
</li>
</ul>
<a name="projectPointsSepJ-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>projectPointsSepJ</h4>
<pre>public static&nbsp;void&nbsp;projectPointsSepJ(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdr,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdt,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdf,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdc)</pre>
</li>
</ul>
<a name="projectPointsSepJ-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>projectPointsSepJ</h4>
<pre>public static&nbsp;void&nbsp;projectPointsSepJ(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdr,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdt,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdf,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdc,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdk)</pre>
</li>
</ul>
<a name="projectPointsSepJ-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>projectPointsSepJ</h4>
<pre>public static&nbsp;void&nbsp;projectPointsSepJ(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdr,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdt,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdf,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdc,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdk,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdo)</pre>
</li>
</ul>
<a name="projectPointsSepJ-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>projectPointsSepJ</h4>
<pre>public static&nbsp;void&nbsp;projectPointsSepJ(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdr,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdt,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdf,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdc,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdk,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dpdo,
                                     double&nbsp;aspectRatio)</pre>
</li>
</ul>
<a name="recoverPose-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>recoverPose</h4>
<pre>public static&nbsp;int&nbsp;recoverPose(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;E,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;t)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>E</code> - The input essential matrix.</dd>
<dd><code>points1</code> - Array of N 2D points from the first image. The point coordinates should be
 floating-point (single or double precision).</dd>
<dd><code>points2</code> - Array of the second image points of the same size and format as points1 .</dd>
<dd><code>R</code> - Output rotation matrix. Together with the translation vector, this matrix makes up a tuple
 that performs a change of basis from the first camera's coordinate system to the second camera's
 coordinate system. Note that, in general, t can not be used for this tuple, see the parameter
 description below.</dd>
<dd><code>t</code> - Output translation vector. This vector is obtained by REF: decomposeEssentialMat and
 therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit
 length.
 are feature points from cameras with same focal length and principal point.
 inliers in points1 and points2 for the given essential matrix E. Only these inliers will be used to
 recover pose. In the output mask only inliers which pass the chirality check.

 This function differs from the one above that it computes camera intrinsic matrix from focal length and
 principal point:

 \(A =
 \begin{bmatrix}
 f &amp; 0 &amp; x_{pp}  \\
 0 &amp; f &amp; y_{pp}  \\
 0 &amp; 0 &amp; 1
 \end{bmatrix}\)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="recoverPose-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>recoverPose</h4>
<pre>public static&nbsp;int&nbsp;recoverPose(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;E,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;t,
                              double&nbsp;focal)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>E</code> - The input essential matrix.</dd>
<dd><code>points1</code> - Array of N 2D points from the first image. The point coordinates should be
 floating-point (single or double precision).</dd>
<dd><code>points2</code> - Array of the second image points of the same size and format as points1 .</dd>
<dd><code>R</code> - Output rotation matrix. Together with the translation vector, this matrix makes up a tuple
 that performs a change of basis from the first camera's coordinate system to the second camera's
 coordinate system. Note that, in general, t can not be used for this tuple, see the parameter
 description below.</dd>
<dd><code>t</code> - Output translation vector. This vector is obtained by REF: decomposeEssentialMat and
 therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit
 length.</dd>
<dd><code>focal</code> - Focal length of the camera. Note that this function assumes that points1 and points2
 are feature points from cameras with same focal length and principal point.
 inliers in points1 and points2 for the given essential matrix E. Only these inliers will be used to
 recover pose. In the output mask only inliers which pass the chirality check.

 This function differs from the one above that it computes camera intrinsic matrix from focal length and
 principal point:

 \(A =
 \begin{bmatrix}
 f &amp; 0 &amp; x_{pp}  \\
 0 &amp; f &amp; y_{pp}  \\
 0 &amp; 0 &amp; 1
 \end{bmatrix}\)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="recoverPose-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-org.opencv.core.Point-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>recoverPose</h4>
<pre>public static&nbsp;int&nbsp;recoverPose(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;E,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;t,
                              double&nbsp;focal,
                              <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pp)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>E</code> - The input essential matrix.</dd>
<dd><code>points1</code> - Array of N 2D points from the first image. The point coordinates should be
 floating-point (single or double precision).</dd>
<dd><code>points2</code> - Array of the second image points of the same size and format as points1 .</dd>
<dd><code>R</code> - Output rotation matrix. Together with the translation vector, this matrix makes up a tuple
 that performs a change of basis from the first camera's coordinate system to the second camera's
 coordinate system. Note that, in general, t can not be used for this tuple, see the parameter
 description below.</dd>
<dd><code>t</code> - Output translation vector. This vector is obtained by REF: decomposeEssentialMat and
 therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit
 length.</dd>
<dd><code>focal</code> - Focal length of the camera. Note that this function assumes that points1 and points2
 are feature points from cameras with same focal length and principal point.</dd>
<dd><code>pp</code> - principal point of the camera.
 inliers in points1 and points2 for the given essential matrix E. Only these inliers will be used to
 recover pose. In the output mask only inliers which pass the chirality check.

 This function differs from the one above that it computes camera intrinsic matrix from focal length and
 principal point:

 \(A =
 \begin{bmatrix}
 f &amp; 0 &amp; x_{pp}  \\
 0 &amp; f &amp; y_{pp}  \\
 0 &amp; 0 &amp; 1
 \end{bmatrix}\)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="recoverPose-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-org.opencv.core.Point-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>recoverPose</h4>
<pre>public static&nbsp;int&nbsp;recoverPose(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;E,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;t,
                              double&nbsp;focal,
                              <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pp,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>E</code> - The input essential matrix.</dd>
<dd><code>points1</code> - Array of N 2D points from the first image. The point coordinates should be
 floating-point (single or double precision).</dd>
<dd><code>points2</code> - Array of the second image points of the same size and format as points1 .</dd>
<dd><code>R</code> - Output rotation matrix. Together with the translation vector, this matrix makes up a tuple
 that performs a change of basis from the first camera's coordinate system to the second camera's
 coordinate system. Note that, in general, t can not be used for this tuple, see the parameter
 description below.</dd>
<dd><code>t</code> - Output translation vector. This vector is obtained by REF: decomposeEssentialMat and
 therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit
 length.</dd>
<dd><code>focal</code> - Focal length of the camera. Note that this function assumes that points1 and points2
 are feature points from cameras with same focal length and principal point.</dd>
<dd><code>pp</code> - principal point of the camera.</dd>
<dd><code>mask</code> - Input/output mask for inliers in points1 and points2. If it is not empty, then it marks
 inliers in points1 and points2 for the given essential matrix E. Only these inliers will be used to
 recover pose. In the output mask only inliers which pass the chirality check.

 This function differs from the one above that it computes camera intrinsic matrix from focal length and
 principal point:

 \(A =
 \begin{bmatrix}
 f &amp; 0 &amp; x_{pp}  \\
 0 &amp; f &amp; y_{pp}  \\
 0 &amp; 0 &amp; 1
 \end{bmatrix}\)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="recoverPose-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>recoverPose</h4>
<pre>public static&nbsp;int&nbsp;recoverPose(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;E,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;t)</pre>
<div class="block">Recovers the relative camera rotation and the translation from an estimated essential
 matrix and the corresponding points in two images, using chirality check. Returns the number of
 inliers that pass the check.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>E</code> - The input essential matrix.</dd>
<dd><code>points1</code> - Array of N 2D points from the first image. The point coordinates should be
 floating-point (single or double precision).</dd>
<dd><code>points2</code> - Array of the second image points of the same size and format as points1 .</dd>
<dd><code>cameraMatrix</code> - Camera intrinsic matrix \(\cameramatrix{A}\) .
 Note that this function assumes that points1 and points2 are feature points from cameras with the
 same camera intrinsic matrix.</dd>
<dd><code>R</code> - Output rotation matrix. Together with the translation vector, this matrix makes up a tuple
 that performs a change of basis from the first camera's coordinate system to the second camera's
 coordinate system. Note that, in general, t can not be used for this tuple, see the parameter
 described below.</dd>
<dd><code>t</code> - Output translation vector. This vector is obtained by REF: decomposeEssentialMat and
 therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit
 length.
 inliers in points1 and points2 for the given essential matrix E. Only these inliers will be used to
 recover pose. In the output mask only inliers which pass the chirality check.

 This function decomposes an essential matrix using REF: decomposeEssentialMat and then verifies
 possible pose hypotheses by doing chirality check. The chirality check means that the
 triangulated 3D points should have positive depth. Some details can be found in CITE: Nister03.

 This function can be used to process the output E and mask from REF: findEssentialMat. In this
 scenario, points1 and points2 are the same input for #findEssentialMat :
 <code>
     // Example. Estimation of fundamental matrix using the RANSAC algorithm
     int point_count = 100;
     vector&lt;Point2f&gt; points1(point_count);
     vector&lt;Point2f&gt; points2(point_count);

     // initialize the points here ...
     for( int i = 0; i &lt; point_count; i++ )
     {
         points1[i] = ...;
         points2[i] = ...;
     }

     // cametra matrix with both focal lengths = 1, and principal point = (0, 0)
     Mat cameraMatrix = Mat::eye(3, 3, CV_64F);

     Mat E, R, t, mask;

     E = findEssentialMat(points1, points2, cameraMatrix, RANSAC, 0.999, 1.0, mask);
     recoverPose(E, points1, points2, cameraMatrix, R, t, mask);
 </code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="recoverPose-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>recoverPose</h4>
<pre>public static&nbsp;int&nbsp;recoverPose(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;E,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;t,
                              double&nbsp;distanceThresh)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>E</code> - The input essential matrix.</dd>
<dd><code>points1</code> - Array of N 2D points from the first image. The point coordinates should be
 floating-point (single or double precision).</dd>
<dd><code>points2</code> - Array of the second image points of the same size and format as points1.</dd>
<dd><code>cameraMatrix</code> - Camera intrinsic matrix \(\cameramatrix{A}\) .
 Note that this function assumes that points1 and points2 are feature points from cameras with the
 same camera intrinsic matrix.</dd>
<dd><code>R</code> - Output rotation matrix. Together with the translation vector, this matrix makes up a tuple
 that performs a change of basis from the first camera's coordinate system to the second camera's
 coordinate system. Note that, in general, t can not be used for this tuple, see the parameter
 description below.</dd>
<dd><code>t</code> - Output translation vector. This vector is obtained by REF: decomposeEssentialMat and
 therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit
 length.</dd>
<dd><code>distanceThresh</code> - threshold distance which is used to filter out far away points (i.e. infinite
 points).
 inliers in points1 and points2 for the given essential matrix E. Only these inliers will be used to
 recover pose. In the output mask only inliers which pass the chirality check.

 This function differs from the one above that it outputs the triangulated 3D point that are used for
 the chirality check.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="recoverPose-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>recoverPose</h4>
<pre>public static&nbsp;int&nbsp;recoverPose(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;E,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;t,
                              double&nbsp;distanceThresh,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>E</code> - The input essential matrix.</dd>
<dd><code>points1</code> - Array of N 2D points from the first image. The point coordinates should be
 floating-point (single or double precision).</dd>
<dd><code>points2</code> - Array of the second image points of the same size and format as points1.</dd>
<dd><code>cameraMatrix</code> - Camera intrinsic matrix \(\cameramatrix{A}\) .
 Note that this function assumes that points1 and points2 are feature points from cameras with the
 same camera intrinsic matrix.</dd>
<dd><code>R</code> - Output rotation matrix. Together with the translation vector, this matrix makes up a tuple
 that performs a change of basis from the first camera's coordinate system to the second camera's
 coordinate system. Note that, in general, t can not be used for this tuple, see the parameter
 description below.</dd>
<dd><code>t</code> - Output translation vector. This vector is obtained by REF: decomposeEssentialMat and
 therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit
 length.</dd>
<dd><code>distanceThresh</code> - threshold distance which is used to filter out far away points (i.e. infinite
 points).</dd>
<dd><code>mask</code> - Input/output mask for inliers in points1 and points2. If it is not empty, then it marks
 inliers in points1 and points2 for the given essential matrix E. Only these inliers will be used to
 recover pose. In the output mask only inliers which pass the chirality check.

 This function differs from the one above that it outputs the triangulated 3D point that are used for
 the chirality check.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="recoverPose-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>recoverPose</h4>
<pre>public static&nbsp;int&nbsp;recoverPose(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;E,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;t,
                              double&nbsp;distanceThresh,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;triangulatedPoints)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>E</code> - The input essential matrix.</dd>
<dd><code>points1</code> - Array of N 2D points from the first image. The point coordinates should be
 floating-point (single or double precision).</dd>
<dd><code>points2</code> - Array of the second image points of the same size and format as points1.</dd>
<dd><code>cameraMatrix</code> - Camera intrinsic matrix \(\cameramatrix{A}\) .
 Note that this function assumes that points1 and points2 are feature points from cameras with the
 same camera intrinsic matrix.</dd>
<dd><code>R</code> - Output rotation matrix. Together with the translation vector, this matrix makes up a tuple
 that performs a change of basis from the first camera's coordinate system to the second camera's
 coordinate system. Note that, in general, t can not be used for this tuple, see the parameter
 description below.</dd>
<dd><code>t</code> - Output translation vector. This vector is obtained by REF: decomposeEssentialMat and
 therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit
 length.</dd>
<dd><code>distanceThresh</code> - threshold distance which is used to filter out far away points (i.e. infinite
 points).</dd>
<dd><code>mask</code> - Input/output mask for inliers in points1 and points2. If it is not empty, then it marks
 inliers in points1 and points2 for the given essential matrix E. Only these inliers will be used to
 recover pose. In the output mask only inliers which pass the chirality check.</dd>
<dd><code>triangulatedPoints</code> - 3D points which were reconstructed by triangulation.

 This function differs from the one above that it outputs the triangulated 3D point that are used for
 the chirality check.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="recoverPose-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>recoverPose</h4>
<pre>public static&nbsp;int&nbsp;recoverPose(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;E,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;t,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
<div class="block">Recovers the relative camera rotation and the translation from an estimated essential
 matrix and the corresponding points in two images, using chirality check. Returns the number of
 inliers that pass the check.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>E</code> - The input essential matrix.</dd>
<dd><code>points1</code> - Array of N 2D points from the first image. The point coordinates should be
 floating-point (single or double precision).</dd>
<dd><code>points2</code> - Array of the second image points of the same size and format as points1 .</dd>
<dd><code>cameraMatrix</code> - Camera intrinsic matrix \(\cameramatrix{A}\) .
 Note that this function assumes that points1 and points2 are feature points from cameras with the
 same camera intrinsic matrix.</dd>
<dd><code>R</code> - Output rotation matrix. Together with the translation vector, this matrix makes up a tuple
 that performs a change of basis from the first camera's coordinate system to the second camera's
 coordinate system. Note that, in general, t can not be used for this tuple, see the parameter
 described below.</dd>
<dd><code>t</code> - Output translation vector. This vector is obtained by REF: decomposeEssentialMat and
 therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit
 length.</dd>
<dd><code>mask</code> - Input/output mask for inliers in points1 and points2. If it is not empty, then it marks
 inliers in points1 and points2 for the given essential matrix E. Only these inliers will be used to
 recover pose. In the output mask only inliers which pass the chirality check.

 This function decomposes an essential matrix using REF: decomposeEssentialMat and then verifies
 possible pose hypotheses by doing chirality check. The chirality check means that the
 triangulated 3D points should have positive depth. Some details can be found in CITE: Nister03.

 This function can be used to process the output E and mask from REF: findEssentialMat. In this
 scenario, points1 and points2 are the same input for #findEssentialMat :
 <code>
     // Example. Estimation of fundamental matrix using the RANSAC algorithm
     int point_count = 100;
     vector&lt;Point2f&gt; points1(point_count);
     vector&lt;Point2f&gt; points2(point_count);

     // initialize the points here ...
     for( int i = 0; i &lt; point_count; i++ )
     {
         points1[i] = ...;
         points2[i] = ...;
     }

     // cametra matrix with both focal lengths = 1, and principal point = (0, 0)
     Mat cameraMatrix = Mat::eye(3, 3, CV_64F);

     Mat E, R, t, mask;

     E = findEssentialMat(points1, points2, cameraMatrix, RANSAC, 0.999, 1.0, mask);
     recoverPose(E, points1, points2, cameraMatrix, R, t, mask);
 </code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="recoverPose-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>recoverPose</h4>
<pre>public static&nbsp;int&nbsp;recoverPose(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix1,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs1,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix2,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs2,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;E,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;t)</pre>
<div class="block">Recovers the relative camera rotation and the translation from corresponding points in two images from two different cameras, using chirality check. Returns the number of
 inliers that pass the check.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - Array of N 2D points from the first image. The point coordinates should be
 floating-point (single or double precision).</dd>
<dd><code>points2</code> - Array of the second image points of the same size and format as points1 .</dd>
<dd><code>cameraMatrix1</code> - Input/output camera matrix for the first camera, the same as in
 REF: calibrateCamera. Furthermore, for the stereo case, additional flags may be used, see below.</dd>
<dd><code>distCoeffs1</code> - Input/output vector of distortion coefficients, the same as in
 REF: calibrateCamera.</dd>
<dd><code>cameraMatrix2</code> - Input/output camera matrix for the first camera, the same as in
 REF: calibrateCamera. Furthermore, for the stereo case, additional flags may be used, see below.</dd>
<dd><code>distCoeffs2</code> - Input/output vector of distortion coefficients, the same as in
 REF: calibrateCamera.</dd>
<dd><code>E</code> - The output essential matrix.</dd>
<dd><code>R</code> - Output rotation matrix. Together with the translation vector, this matrix makes up a tuple
 that performs a change of basis from the first camera's coordinate system to the second camera's
 coordinate system. Note that, in general, t can not be used for this tuple, see the parameter
 described below.</dd>
<dd><code>t</code> - Output translation vector. This vector is obtained by REF: decomposeEssentialMat and
 therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit
 length.
 <ul>
   <li>
    REF: RANSAC for the RANSAC algorithm.
   </li>
   <li>
    REF: LMEDS for the LMedS algorithm.
   </li>
 </ul>
 confidence (probability) that the estimated matrix is correct.
 line in pixels, beyond which the point is considered an outlier and is not used for computing the
 final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the
 point localization, image resolution, and the image noise.
 inliers in points1 and points2 for the given essential matrix E. Only these inliers will be used to
 recover pose. In the output mask only inliers which pass the chirality check.

 This function decomposes an essential matrix using REF: decomposeEssentialMat and then verifies
 possible pose hypotheses by doing chirality check. The chirality check means that the
 triangulated 3D points should have positive depth. Some details can be found in CITE: Nister03.

 This function can be used to process the output E and mask from REF: findEssentialMat. In this
 scenario, points1 and points2 are the same input for findEssentialMat.:
 <code>
     // Example. Estimation of fundamental matrix using the RANSAC algorithm
     int point_count = 100;
     vector&lt;Point2f&gt; points1(point_count);
     vector&lt;Point2f&gt; points2(point_count);

     // initialize the points here ...
     for( int i = 0; i &lt; point_count; i++ )
     {
         points1[i] = ...;
         points2[i] = ...;
     }

     // Input: camera calibration of both cameras, for example using intrinsic chessboard calibration.
     Mat cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2;

     // Output: Essential matrix, relative rotation and relative translation.
     Mat E, R, t, mask;

     recoverPose(points1, points2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, E, R, t, mask);
 </code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="recoverPose-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>recoverPose</h4>
<pre>public static&nbsp;int&nbsp;recoverPose(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix1,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs1,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix2,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs2,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;E,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;t,
                              int&nbsp;method)</pre>
<div class="block">Recovers the relative camera rotation and the translation from corresponding points in two images from two different cameras, using chirality check. Returns the number of
 inliers that pass the check.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - Array of N 2D points from the first image. The point coordinates should be
 floating-point (single or double precision).</dd>
<dd><code>points2</code> - Array of the second image points of the same size and format as points1 .</dd>
<dd><code>cameraMatrix1</code> - Input/output camera matrix for the first camera, the same as in
 REF: calibrateCamera. Furthermore, for the stereo case, additional flags may be used, see below.</dd>
<dd><code>distCoeffs1</code> - Input/output vector of distortion coefficients, the same as in
 REF: calibrateCamera.</dd>
<dd><code>cameraMatrix2</code> - Input/output camera matrix for the first camera, the same as in
 REF: calibrateCamera. Furthermore, for the stereo case, additional flags may be used, see below.</dd>
<dd><code>distCoeffs2</code> - Input/output vector of distortion coefficients, the same as in
 REF: calibrateCamera.</dd>
<dd><code>E</code> - The output essential matrix.</dd>
<dd><code>R</code> - Output rotation matrix. Together with the translation vector, this matrix makes up a tuple
 that performs a change of basis from the first camera's coordinate system to the second camera's
 coordinate system. Note that, in general, t can not be used for this tuple, see the parameter
 described below.</dd>
<dd><code>t</code> - Output translation vector. This vector is obtained by REF: decomposeEssentialMat and
 therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit
 length.</dd>
<dd><code>method</code> - Method for computing an essential matrix.
 <ul>
   <li>
    REF: RANSAC for the RANSAC algorithm.
   </li>
   <li>
    REF: LMEDS for the LMedS algorithm.
   </li>
 </ul>
 confidence (probability) that the estimated matrix is correct.
 line in pixels, beyond which the point is considered an outlier and is not used for computing the
 final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the
 point localization, image resolution, and the image noise.
 inliers in points1 and points2 for the given essential matrix E. Only these inliers will be used to
 recover pose. In the output mask only inliers which pass the chirality check.

 This function decomposes an essential matrix using REF: decomposeEssentialMat and then verifies
 possible pose hypotheses by doing chirality check. The chirality check means that the
 triangulated 3D points should have positive depth. Some details can be found in CITE: Nister03.

 This function can be used to process the output E and mask from REF: findEssentialMat. In this
 scenario, points1 and points2 are the same input for findEssentialMat.:
 <code>
     // Example. Estimation of fundamental matrix using the RANSAC algorithm
     int point_count = 100;
     vector&lt;Point2f&gt; points1(point_count);
     vector&lt;Point2f&gt; points2(point_count);

     // initialize the points here ...
     for( int i = 0; i &lt; point_count; i++ )
     {
         points1[i] = ...;
         points2[i] = ...;
     }

     // Input: camera calibration of both cameras, for example using intrinsic chessboard calibration.
     Mat cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2;

     // Output: Essential matrix, relative rotation and relative translation.
     Mat E, R, t, mask;

     recoverPose(points1, points2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, E, R, t, mask);
 </code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="recoverPose-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>recoverPose</h4>
<pre>public static&nbsp;int&nbsp;recoverPose(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix1,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs1,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix2,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs2,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;E,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;t,
                              int&nbsp;method,
                              double&nbsp;prob)</pre>
<div class="block">Recovers the relative camera rotation and the translation from corresponding points in two images from two different cameras, using chirality check. Returns the number of
 inliers that pass the check.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - Array of N 2D points from the first image. The point coordinates should be
 floating-point (single or double precision).</dd>
<dd><code>points2</code> - Array of the second image points of the same size and format as points1 .</dd>
<dd><code>cameraMatrix1</code> - Input/output camera matrix for the first camera, the same as in
 REF: calibrateCamera. Furthermore, for the stereo case, additional flags may be used, see below.</dd>
<dd><code>distCoeffs1</code> - Input/output vector of distortion coefficients, the same as in
 REF: calibrateCamera.</dd>
<dd><code>cameraMatrix2</code> - Input/output camera matrix for the first camera, the same as in
 REF: calibrateCamera. Furthermore, for the stereo case, additional flags may be used, see below.</dd>
<dd><code>distCoeffs2</code> - Input/output vector of distortion coefficients, the same as in
 REF: calibrateCamera.</dd>
<dd><code>E</code> - The output essential matrix.</dd>
<dd><code>R</code> - Output rotation matrix. Together with the translation vector, this matrix makes up a tuple
 that performs a change of basis from the first camera's coordinate system to the second camera's
 coordinate system. Note that, in general, t can not be used for this tuple, see the parameter
 described below.</dd>
<dd><code>t</code> - Output translation vector. This vector is obtained by REF: decomposeEssentialMat and
 therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit
 length.</dd>
<dd><code>method</code> - Method for computing an essential matrix.
 <ul>
   <li>
    REF: RANSAC for the RANSAC algorithm.
   </li>
   <li>
    REF: LMEDS for the LMedS algorithm.
   </li>
 </ul></dd>
<dd><code>prob</code> - Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of
 confidence (probability) that the estimated matrix is correct.
 line in pixels, beyond which the point is considered an outlier and is not used for computing the
 final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the
 point localization, image resolution, and the image noise.
 inliers in points1 and points2 for the given essential matrix E. Only these inliers will be used to
 recover pose. In the output mask only inliers which pass the chirality check.

 This function decomposes an essential matrix using REF: decomposeEssentialMat and then verifies
 possible pose hypotheses by doing chirality check. The chirality check means that the
 triangulated 3D points should have positive depth. Some details can be found in CITE: Nister03.

 This function can be used to process the output E and mask from REF: findEssentialMat. In this
 scenario, points1 and points2 are the same input for findEssentialMat.:
 <code>
     // Example. Estimation of fundamental matrix using the RANSAC algorithm
     int point_count = 100;
     vector&lt;Point2f&gt; points1(point_count);
     vector&lt;Point2f&gt; points2(point_count);

     // initialize the points here ...
     for( int i = 0; i &lt; point_count; i++ )
     {
         points1[i] = ...;
         points2[i] = ...;
     }

     // Input: camera calibration of both cameras, for example using intrinsic chessboard calibration.
     Mat cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2;

     // Output: Essential matrix, relative rotation and relative translation.
     Mat E, R, t, mask;

     recoverPose(points1, points2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, E, R, t, mask);
 </code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="recoverPose-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>recoverPose</h4>
<pre>public static&nbsp;int&nbsp;recoverPose(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix1,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs1,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix2,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs2,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;E,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;t,
                              int&nbsp;method,
                              double&nbsp;prob,
                              double&nbsp;threshold)</pre>
<div class="block">Recovers the relative camera rotation and the translation from corresponding points in two images from two different cameras, using chirality check. Returns the number of
 inliers that pass the check.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - Array of N 2D points from the first image. The point coordinates should be
 floating-point (single or double precision).</dd>
<dd><code>points2</code> - Array of the second image points of the same size and format as points1 .</dd>
<dd><code>cameraMatrix1</code> - Input/output camera matrix for the first camera, the same as in
 REF: calibrateCamera. Furthermore, for the stereo case, additional flags may be used, see below.</dd>
<dd><code>distCoeffs1</code> - Input/output vector of distortion coefficients, the same as in
 REF: calibrateCamera.</dd>
<dd><code>cameraMatrix2</code> - Input/output camera matrix for the first camera, the same as in
 REF: calibrateCamera. Furthermore, for the stereo case, additional flags may be used, see below.</dd>
<dd><code>distCoeffs2</code> - Input/output vector of distortion coefficients, the same as in
 REF: calibrateCamera.</dd>
<dd><code>E</code> - The output essential matrix.</dd>
<dd><code>R</code> - Output rotation matrix. Together with the translation vector, this matrix makes up a tuple
 that performs a change of basis from the first camera's coordinate system to the second camera's
 coordinate system. Note that, in general, t can not be used for this tuple, see the parameter
 described below.</dd>
<dd><code>t</code> - Output translation vector. This vector is obtained by REF: decomposeEssentialMat and
 therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit
 length.</dd>
<dd><code>method</code> - Method for computing an essential matrix.
 <ul>
   <li>
    REF: RANSAC for the RANSAC algorithm.
   </li>
   <li>
    REF: LMEDS for the LMedS algorithm.
   </li>
 </ul></dd>
<dd><code>prob</code> - Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of
 confidence (probability) that the estimated matrix is correct.</dd>
<dd><code>threshold</code> - Parameter used for RANSAC. It is the maximum distance from a point to an epipolar
 line in pixels, beyond which the point is considered an outlier and is not used for computing the
 final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the
 point localization, image resolution, and the image noise.
 inliers in points1 and points2 for the given essential matrix E. Only these inliers will be used to
 recover pose. In the output mask only inliers which pass the chirality check.

 This function decomposes an essential matrix using REF: decomposeEssentialMat and then verifies
 possible pose hypotheses by doing chirality check. The chirality check means that the
 triangulated 3D points should have positive depth. Some details can be found in CITE: Nister03.

 This function can be used to process the output E and mask from REF: findEssentialMat. In this
 scenario, points1 and points2 are the same input for findEssentialMat.:
 <code>
     // Example. Estimation of fundamental matrix using the RANSAC algorithm
     int point_count = 100;
     vector&lt;Point2f&gt; points1(point_count);
     vector&lt;Point2f&gt; points2(point_count);

     // initialize the points here ...
     for( int i = 0; i &lt; point_count; i++ )
     {
         points1[i] = ...;
         points2[i] = ...;
     }

     // Input: camera calibration of both cameras, for example using intrinsic chessboard calibration.
     Mat cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2;

     // Output: Essential matrix, relative rotation and relative translation.
     Mat E, R, t, mask;

     recoverPose(points1, points2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, E, R, t, mask);
 </code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="recoverPose-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>recoverPose</h4>
<pre>public static&nbsp;int&nbsp;recoverPose(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix1,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs1,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix2,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs2,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;E,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;t,
                              int&nbsp;method,
                              double&nbsp;prob,
                              double&nbsp;threshold,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
<div class="block">Recovers the relative camera rotation and the translation from corresponding points in two images from two different cameras, using chirality check. Returns the number of
 inliers that pass the check.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - Array of N 2D points from the first image. The point coordinates should be
 floating-point (single or double precision).</dd>
<dd><code>points2</code> - Array of the second image points of the same size and format as points1 .</dd>
<dd><code>cameraMatrix1</code> - Input/output camera matrix for the first camera, the same as in
 REF: calibrateCamera. Furthermore, for the stereo case, additional flags may be used, see below.</dd>
<dd><code>distCoeffs1</code> - Input/output vector of distortion coefficients, the same as in
 REF: calibrateCamera.</dd>
<dd><code>cameraMatrix2</code> - Input/output camera matrix for the first camera, the same as in
 REF: calibrateCamera. Furthermore, for the stereo case, additional flags may be used, see below.</dd>
<dd><code>distCoeffs2</code> - Input/output vector of distortion coefficients, the same as in
 REF: calibrateCamera.</dd>
<dd><code>E</code> - The output essential matrix.</dd>
<dd><code>R</code> - Output rotation matrix. Together with the translation vector, this matrix makes up a tuple
 that performs a change of basis from the first camera's coordinate system to the second camera's
 coordinate system. Note that, in general, t can not be used for this tuple, see the parameter
 described below.</dd>
<dd><code>t</code> - Output translation vector. This vector is obtained by REF: decomposeEssentialMat and
 therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit
 length.</dd>
<dd><code>method</code> - Method for computing an essential matrix.
 <ul>
   <li>
    REF: RANSAC for the RANSAC algorithm.
   </li>
   <li>
    REF: LMEDS for the LMedS algorithm.
   </li>
 </ul></dd>
<dd><code>prob</code> - Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of
 confidence (probability) that the estimated matrix is correct.</dd>
<dd><code>threshold</code> - Parameter used for RANSAC. It is the maximum distance from a point to an epipolar
 line in pixels, beyond which the point is considered an outlier and is not used for computing the
 final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the
 point localization, image resolution, and the image noise.</dd>
<dd><code>mask</code> - Input/output mask for inliers in points1 and points2. If it is not empty, then it marks
 inliers in points1 and points2 for the given essential matrix E. Only these inliers will be used to
 recover pose. In the output mask only inliers which pass the chirality check.

 This function decomposes an essential matrix using REF: decomposeEssentialMat and then verifies
 possible pose hypotheses by doing chirality check. The chirality check means that the
 triangulated 3D points should have positive depth. Some details can be found in CITE: Nister03.

 This function can be used to process the output E and mask from REF: findEssentialMat. In this
 scenario, points1 and points2 are the same input for findEssentialMat.:
 <code>
     // Example. Estimation of fundamental matrix using the RANSAC algorithm
     int point_count = 100;
     vector&lt;Point2f&gt; points1(point_count);
     vector&lt;Point2f&gt; points2(point_count);

     // initialize the points here ...
     for( int i = 0; i &lt; point_count; i++ )
     {
         points1[i] = ...;
         points2[i] = ...;
     }

     // Input: camera calibration of both cameras, for example using intrinsic chessboard calibration.
     Mat cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2;

     // Output: Essential matrix, relative rotation and relative translation.
     Mat E, R, t, mask;

     recoverPose(points1, points2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, E, R, t, mask);
 </code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="registerDepth-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>registerDepth</h4>
<pre>public static&nbsp;void&nbsp;registerDepth(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;unregisteredCameraMatrix,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;registeredCameraMatrix,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;registeredDistCoeffs,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Rt,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;unregisteredDepth,
                                 <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;outputImagePlaneSize,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;registeredDepth)</pre>
<div class="block">Registers depth data to an external camera
 Registration is performed by creating a depth cloud, transforming the cloud by
 the rigid body transformation between the cameras, and then projecting the
 transformed points into the RGB camera.

 uv_rgb = K_rgb * [R | t] * z * inv(K_ir) * uv_ir

 Currently does not check for negative depth values.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>unregisteredCameraMatrix</code> - the camera matrix of the depth camera</dd>
<dd><code>registeredCameraMatrix</code> - the camera matrix of the external camera</dd>
<dd><code>registeredDistCoeffs</code> - the distortion coefficients of the external camera</dd>
<dd><code>Rt</code> - the rigid body transform between the cameras. Transforms points from depth camera frame to external camera frame.</dd>
<dd><code>unregisteredDepth</code> - the input depth data</dd>
<dd><code>outputImagePlaneSize</code> - the image plane dimensions of the external camera (width, height)</dd>
<dd><code>registeredDepth</code> - the result of transforming the depth into the external camera</dd>
</dl>
</li>
</ul>
<a name="registerDepth-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-org.opencv.core.Mat-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>registerDepth</h4>
<pre>public static&nbsp;void&nbsp;registerDepth(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;unregisteredCameraMatrix,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;registeredCameraMatrix,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;registeredDistCoeffs,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Rt,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;unregisteredDepth,
                                 <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;outputImagePlaneSize,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;registeredDepth,
                                 boolean&nbsp;depthDilation)</pre>
<div class="block">Registers depth data to an external camera
 Registration is performed by creating a depth cloud, transforming the cloud by
 the rigid body transformation between the cameras, and then projecting the
 transformed points into the RGB camera.

 uv_rgb = K_rgb * [R | t] * z * inv(K_ir) * uv_ir

 Currently does not check for negative depth values.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>unregisteredCameraMatrix</code> - the camera matrix of the depth camera</dd>
<dd><code>registeredCameraMatrix</code> - the camera matrix of the external camera</dd>
<dd><code>registeredDistCoeffs</code> - the distortion coefficients of the external camera</dd>
<dd><code>Rt</code> - the rigid body transform between the cameras. Transforms points from depth camera frame to external camera frame.</dd>
<dd><code>unregisteredDepth</code> - the input depth data</dd>
<dd><code>outputImagePlaneSize</code> - the image plane dimensions of the external camera (width, height)</dd>
<dd><code>registeredDepth</code> - the result of transforming the depth into the external camera</dd>
<dd><code>depthDilation</code> - whether or not the depth is dilated to avoid holes and occlusion errors (optional)</dd>
</dl>
</li>
</ul>
<a name="rescaleDepth-org.opencv.core.Mat-int-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rescaleDepth</h4>
<pre>public static&nbsp;void&nbsp;rescaleDepth(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;in,
                                int&nbsp;type,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;out)</pre>
<div class="block">If the input image is of type CV_16UC1 (like the Kinect one), the image is converted to floats, divided
 by depth_factor to get a depth in meters, and the values 0 are converted to std::numeric_limits&lt;float&gt;::quiet_NaN()
 Otherwise, the image is simply converted to floats</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>in</code> - the depth image (if given as short int CV_U, it is assumed to be the depth in millimeters
 (as done with the Microsoft Kinect), it is assumed in meters)</dd>
<dd><code>type</code> - the desired output depth (CV_32F or CV_64F)</dd>
<dd><code>out</code> - The rescaled float depth image</dd>
</dl>
</li>
</ul>
<a name="rescaleDepth-org.opencv.core.Mat-int-org.opencv.core.Mat-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rescaleDepth</h4>
<pre>public static&nbsp;void&nbsp;rescaleDepth(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;in,
                                int&nbsp;type,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;out,
                                double&nbsp;depth_factor)</pre>
<div class="block">If the input image is of type CV_16UC1 (like the Kinect one), the image is converted to floats, divided
 by depth_factor to get a depth in meters, and the values 0 are converted to std::numeric_limits&lt;float&gt;::quiet_NaN()
 Otherwise, the image is simply converted to floats</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>in</code> - the depth image (if given as short int CV_U, it is assumed to be the depth in millimeters
 (as done with the Microsoft Kinect), it is assumed in meters)</dd>
<dd><code>type</code> - the desired output depth (CV_32F or CV_64F)</dd>
<dd><code>out</code> - The rescaled float depth image</dd>
<dd><code>depth_factor</code> - (optional) factor by which depth is converted to distance (by default = 1000.0 for Kinect sensor)</dd>
</dl>
</li>
</ul>
<a name="Rodrigues-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Rodrigues</h4>
<pre>public static&nbsp;void&nbsp;Rodrigues(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Converts a rotation matrix to a rotation vector or vice versa.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Input rotation vector (3x1 or 1x3) or rotation matrix (3x3).</dd>
<dd><code>dst</code> - Output rotation matrix (3x3) or rotation vector (3x1 or 1x3), respectively.
 derivatives of the output array components with respect to the input array components.

 \(\begin{array}{l} \theta \leftarrow norm(r) \\ r  \leftarrow r/ \theta \\ R =  \cos(\theta) I + (1- \cos{\theta} ) r r^T +  \sin(\theta) \vecthreethree{0}{-r_z}{r_y}{r_z}{0}{-r_x}{-r_y}{r_x}{0} \end{array}\)

 Inverse transformation can be also done easily, since

 \(\sin ( \theta ) \vecthreethree{0}{-r_z}{r_y}{r_z}{0}{-r_x}{-r_y}{r_x}{0} = \frac{R - R^T}{2}\)

 A rotation vector is a convenient and most compact representation of a rotation matrix (since any
 rotation matrix has just 3 degrees of freedom). The representation is used in the global 3D geometry
 optimization procedures like REF: calibrateCamera, REF: stereoCalibrate, or REF: solvePnP .

 <b>Note:</b> More information about the computation of the derivative of a 3D rotation matrix with respect to its exponential coordinate
 can be found in:
 <ul>
   <li>
      A Compact Formula for the Derivative of a 3-D Rotation in Exponential Coordinates, Guillermo Gallego, Anthony J. Yezzi CITE: Gallego2014ACF
   </li>
 </ul>

 <b>Note:</b> Useful information on SE(3) and Lie Groups can be found in:
 <ul>
   <li>
      A tutorial on SE(3) transformation parameterizations and on-manifold optimization, Jose-Luis Blanco CITE: blanco2010tutorial
   </li>
   <li>
      Lie Groups for 2D and 3D Transformation, Ethan Eade CITE: Eade17
   </li>
   <li>
      A micro Lie theory for state estimation in robotics, Joan Sol, Jrmie Deray, Dinesh Atchuthan CITE: Sol2018AML
   </li>
 </ul></dd>
</dl>
</li>
</ul>
<a name="Rodrigues-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Rodrigues</h4>
<pre>public static&nbsp;void&nbsp;Rodrigues(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;jacobian)</pre>
<div class="block">Converts a rotation matrix to a rotation vector or vice versa.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Input rotation vector (3x1 or 1x3) or rotation matrix (3x3).</dd>
<dd><code>dst</code> - Output rotation matrix (3x3) or rotation vector (3x1 or 1x3), respectively.</dd>
<dd><code>jacobian</code> - Optional output Jacobian matrix, 3x9 or 9x3, which is a matrix of partial
 derivatives of the output array components with respect to the input array components.

 \(\begin{array}{l} \theta \leftarrow norm(r) \\ r  \leftarrow r/ \theta \\ R =  \cos(\theta) I + (1- \cos{\theta} ) r r^T +  \sin(\theta) \vecthreethree{0}{-r_z}{r_y}{r_z}{0}{-r_x}{-r_y}{r_x}{0} \end{array}\)

 Inverse transformation can be also done easily, since

 \(\sin ( \theta ) \vecthreethree{0}{-r_z}{r_y}{r_z}{0}{-r_x}{-r_y}{r_x}{0} = \frac{R - R^T}{2}\)

 A rotation vector is a convenient and most compact representation of a rotation matrix (since any
 rotation matrix has just 3 degrees of freedom). The representation is used in the global 3D geometry
 optimization procedures like REF: calibrateCamera, REF: stereoCalibrate, or REF: solvePnP .

 <b>Note:</b> More information about the computation of the derivative of a 3D rotation matrix with respect to its exponential coordinate
 can be found in:
 <ul>
   <li>
      A Compact Formula for the Derivative of a 3-D Rotation in Exponential Coordinates, Guillermo Gallego, Anthony J. Yezzi CITE: Gallego2014ACF
   </li>
 </ul>

 <b>Note:</b> Useful information on SE(3) and Lie Groups can be found in:
 <ul>
   <li>
      A tutorial on SE(3) transformation parameterizations and on-manifold optimization, Jose-Luis Blanco CITE: blanco2010tutorial
   </li>
   <li>
      Lie Groups for 2D and 3D Transformation, Ethan Eade CITE: Eade17
   </li>
   <li>
      A micro Lie theory for state estimation in robotics, Joan Sol, Jrmie Deray, Dinesh Atchuthan CITE: Sol2018AML
   </li>
 </ul></dd>
</dl>
</li>
</ul>
<a name="RQDecomp3x3-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RQDecomp3x3</h4>
<pre>public static&nbsp;double[]&nbsp;RQDecomp3x3(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mtxR,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mtxQ)</pre>
<div class="block">Computes an RQ decomposition of 3x3 matrices.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - 3x3 input matrix.</dd>
<dd><code>mtxR</code> - Output 3x3 upper-triangular matrix.</dd>
<dd><code>mtxQ</code> - Output 3x3 orthogonal matrix.

 The function computes a RQ decomposition using the given rotations. This function is used in
 #decomposeProjectionMatrix to decompose the left 3x3 submatrix of a projection matrix into a camera
 and a rotation matrix.

 It optionally returns three rotation matrices, one for each axis, and the three Euler angles in
 degrees (as the return value) that could be used in OpenGL. Note, there is always more than one
 sequence of rotations about the three principal axes that results in the same orientation of an
 object, e.g. see CITE: Slabaugh . Returned three rotation matrices and corresponding three Euler angles
 are only one of the possible solutions.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="RQDecomp3x3-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RQDecomp3x3</h4>
<pre>public static&nbsp;double[]&nbsp;RQDecomp3x3(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mtxR,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mtxQ,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Qx)</pre>
<div class="block">Computes an RQ decomposition of 3x3 matrices.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - 3x3 input matrix.</dd>
<dd><code>mtxR</code> - Output 3x3 upper-triangular matrix.</dd>
<dd><code>mtxQ</code> - Output 3x3 orthogonal matrix.</dd>
<dd><code>Qx</code> - Optional output 3x3 rotation matrix around x-axis.

 The function computes a RQ decomposition using the given rotations. This function is used in
 #decomposeProjectionMatrix to decompose the left 3x3 submatrix of a projection matrix into a camera
 and a rotation matrix.

 It optionally returns three rotation matrices, one for each axis, and the three Euler angles in
 degrees (as the return value) that could be used in OpenGL. Note, there is always more than one
 sequence of rotations about the three principal axes that results in the same orientation of an
 object, e.g. see CITE: Slabaugh . Returned three rotation matrices and corresponding three Euler angles
 are only one of the possible solutions.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="RQDecomp3x3-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RQDecomp3x3</h4>
<pre>public static&nbsp;double[]&nbsp;RQDecomp3x3(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mtxR,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mtxQ,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Qx,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Qy)</pre>
<div class="block">Computes an RQ decomposition of 3x3 matrices.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - 3x3 input matrix.</dd>
<dd><code>mtxR</code> - Output 3x3 upper-triangular matrix.</dd>
<dd><code>mtxQ</code> - Output 3x3 orthogonal matrix.</dd>
<dd><code>Qx</code> - Optional output 3x3 rotation matrix around x-axis.</dd>
<dd><code>Qy</code> - Optional output 3x3 rotation matrix around y-axis.

 The function computes a RQ decomposition using the given rotations. This function is used in
 #decomposeProjectionMatrix to decompose the left 3x3 submatrix of a projection matrix into a camera
 and a rotation matrix.

 It optionally returns three rotation matrices, one for each axis, and the three Euler angles in
 degrees (as the return value) that could be used in OpenGL. Note, there is always more than one
 sequence of rotations about the three principal axes that results in the same orientation of an
 object, e.g. see CITE: Slabaugh . Returned three rotation matrices and corresponding three Euler angles
 are only one of the possible solutions.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="RQDecomp3x3-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RQDecomp3x3</h4>
<pre>public static&nbsp;double[]&nbsp;RQDecomp3x3(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mtxR,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mtxQ,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Qx,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Qy,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Qz)</pre>
<div class="block">Computes an RQ decomposition of 3x3 matrices.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - 3x3 input matrix.</dd>
<dd><code>mtxR</code> - Output 3x3 upper-triangular matrix.</dd>
<dd><code>mtxQ</code> - Output 3x3 orthogonal matrix.</dd>
<dd><code>Qx</code> - Optional output 3x3 rotation matrix around x-axis.</dd>
<dd><code>Qy</code> - Optional output 3x3 rotation matrix around y-axis.</dd>
<dd><code>Qz</code> - Optional output 3x3 rotation matrix around z-axis.

 The function computes a RQ decomposition using the given rotations. This function is used in
 #decomposeProjectionMatrix to decompose the left 3x3 submatrix of a projection matrix into a camera
 and a rotation matrix.

 It optionally returns three rotation matrices, one for each axis, and the three Euler angles in
 degrees (as the return value) that could be used in OpenGL. Note, there is always more than one
 sequence of rotations about the three principal axes that results in the same orientation of an
 object, e.g. see CITE: Slabaugh . Returned three rotation matrices and corresponding three Euler angles
 are only one of the possible solutions.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="sampsonDistance-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sampsonDistance</h4>
<pre>public static&nbsp;double&nbsp;sampsonDistance(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;pt1,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;pt2,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;F)</pre>
<div class="block">Calculates the Sampson Distance between two points.

 The function cv::sampsonDistance calculates and returns the first order approximation of the geometric error as:
 \(
 sd( \texttt{pt1} , \texttt{pt2} )=
 \frac{(\texttt{pt2}^t \cdot \texttt{F} \cdot \texttt{pt1})^2}
 {((\texttt{F} \cdot \texttt{pt1})(0))^2 +
 ((\texttt{F} \cdot \texttt{pt1})(1))^2 +
 ((\texttt{F}^t \cdot \texttt{pt2})(0))^2 +
 ((\texttt{F}^t \cdot \texttt{pt2})(1))^2}
 \)
 The fundamental matrix may be calculated using the #findFundamentalMat function. See CITE: HartleyZ00 11.4.3 for details.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>pt1</code> - first homogeneous 2d point</dd>
<dd><code>pt2</code> - second homogeneous 2d point</dd>
<dd><code>F</code> - fundamental matrix</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The computed Sampson distance.</dd>
</dl>
</li>
</ul>
<a name="saveMesh-java.lang.String-org.opencv.core.Mat-java.util.List-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>saveMesh</h4>
<pre>public static&nbsp;void&nbsp;saveMesh(java.lang.String&nbsp;filename,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices,
                            java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;indices)</pre>
<div class="block">Saves a mesh to a specified file.

 The function saves mesh to the specified file.
 File format is chosen based on the filename extension.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>filename</code> - Name of the file.</dd>
<dd><code>vertices</code> - vertex coordinates, each value contains 3 floats</dd>
<dd><code>indices</code> - per-face list of vertices, each value is a vector of ints</dd>
</dl>
</li>
</ul>
<a name="saveMesh-java.lang.String-org.opencv.core.Mat-java.util.List-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>saveMesh</h4>
<pre>public static&nbsp;void&nbsp;saveMesh(java.lang.String&nbsp;filename,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices,
                            java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;indices,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;normals)</pre>
<div class="block">Saves a mesh to a specified file.

 The function saves mesh to the specified file.
 File format is chosen based on the filename extension.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>filename</code> - Name of the file.</dd>
<dd><code>vertices</code> - vertex coordinates, each value contains 3 floats</dd>
<dd><code>indices</code> - per-face list of vertices, each value is a vector of ints</dd>
<dd><code>normals</code> - per-vertex normals, each value contains 3 floats</dd>
</dl>
</li>
</ul>
<a name="saveMesh-java.lang.String-org.opencv.core.Mat-java.util.List-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>saveMesh</h4>
<pre>public static&nbsp;void&nbsp;saveMesh(java.lang.String&nbsp;filename,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices,
                            java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;indices,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;normals,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;colors)</pre>
<div class="block">Saves a mesh to a specified file.

 The function saves mesh to the specified file.
 File format is chosen based on the filename extension.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>filename</code> - Name of the file.</dd>
<dd><code>vertices</code> - vertex coordinates, each value contains 3 floats</dd>
<dd><code>indices</code> - per-face list of vertices, each value is a vector of ints</dd>
<dd><code>normals</code> - per-vertex normals, each value contains 3 floats</dd>
<dd><code>colors</code> - per-vertex colors, each value contains 3 floats</dd>
</dl>
</li>
</ul>
<a name="saveMesh-java.lang.String-org.opencv.core.Mat-java.util.List-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>saveMesh</h4>
<pre>public static&nbsp;void&nbsp;saveMesh(java.lang.String&nbsp;filename,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices,
                            java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;indices,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;normals,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;colors,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;texCoords)</pre>
<div class="block">Saves a mesh to a specified file.

 The function saves mesh to the specified file.
 File format is chosen based on the filename extension.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>filename</code> - Name of the file.</dd>
<dd><code>vertices</code> - vertex coordinates, each value contains 3 floats</dd>
<dd><code>indices</code> - per-face list of vertices, each value is a vector of ints</dd>
<dd><code>normals</code> - per-vertex normals, each value contains 3 floats</dd>
<dd><code>colors</code> - per-vertex colors, each value contains 3 floats</dd>
<dd><code>texCoords</code> - per-vertex texture coordinates, each value contains 2 or 3 floats</dd>
</dl>
</li>
</ul>
<a name="savePointCloud-java.lang.String-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>savePointCloud</h4>
<pre>public static&nbsp;void&nbsp;savePointCloud(java.lang.String&nbsp;filename,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices)</pre>
<div class="block">Saves a point cloud to a specified file.

 The function saves point cloud to the specified file.
 File format is chosen based on the filename extension.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>filename</code> - Name of the file</dd>
<dd><code>vertices</code> - vertex coordinates, each value contains 3 floats</dd>
</dl>
</li>
</ul>
<a name="savePointCloud-java.lang.String-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>savePointCloud</h4>
<pre>public static&nbsp;void&nbsp;savePointCloud(java.lang.String&nbsp;filename,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;normals)</pre>
<div class="block">Saves a point cloud to a specified file.

 The function saves point cloud to the specified file.
 File format is chosen based on the filename extension.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>filename</code> - Name of the file</dd>
<dd><code>vertices</code> - vertex coordinates, each value contains 3 floats</dd>
<dd><code>normals</code> - per-vertex normals, each value contains 3 floats</dd>
</dl>
</li>
</ul>
<a name="savePointCloud-java.lang.String-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>savePointCloud</h4>
<pre>public static&nbsp;void&nbsp;savePointCloud(java.lang.String&nbsp;filename,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;normals,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rgb)</pre>
<div class="block">Saves a point cloud to a specified file.

 The function saves point cloud to the specified file.
 File format is chosen based on the filename extension.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>filename</code> - Name of the file</dd>
<dd><code>vertices</code> - vertex coordinates, each value contains 3 floats</dd>
<dd><code>normals</code> - per-vertex normals, each value contains 3 floats</dd>
<dd><code>rgb</code> - per-vertex colors, each value contains 3 floats</dd>
</dl>
</li>
</ul>
<a name="solveP3P-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-java.util.List-java.util.List-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>solveP3P</h4>
<pre>public static&nbsp;int&nbsp;solveP3P(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                           java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;rvecs,
                           java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;tvecs,
                           int&nbsp;flags)</pre>
<div class="block">Finds an object pose from 3 3D-2D point correspondences.

 SEE: REF: calib3d_solvePnP</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>objectPoints</code> - Array of object points in the object coordinate space, 3x3 1-channel or
 1x3/3x1 3-channel. vector&lt;Point3f&gt; can be also passed here.</dd>
<dd><code>imagePoints</code> - Array of corresponding image points, 3x2 1-channel or 1x3/3x1 2-channel.
  vector&lt;Point2f&gt; can be also passed here.</dd>
<dd><code>cameraMatrix</code> - Input camera intrinsic matrix \(\cameramatrix{A}\) .</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are
 assumed.</dd>
<dd><code>rvecs</code> - Output rotation vectors (see REF: Rodrigues ) that, together with tvecs, brings points from
 the model coordinate system to the camera coordinate system. A P3P problem has up to 4 solutions.</dd>
<dd><code>tvecs</code> - Output translation vectors.</dd>
<dd><code>flags</code> - Method for solving a P3P problem:
 <ul>
   <li>
    REF: SOLVEPNP_P3P Method is based on the paper of X.S. Gao, X.-R. Hou, J. Tang, H.-F. Chang
 "Complete Solution Classification for the Perspective-Three-Point Problem" (CITE: gao2003complete).
   </li>
   <li>
    REF: SOLVEPNP_AP3P Method is based on the paper of T. Ke and S. Roumeliotis.
 "An Efficient Algebraic Solution to the Perspective-Three-Point Problem" (CITE: Ke17).
   </li>
 </ul>

 The function estimates the object pose given 3 object points, their corresponding image
 projections, as well as the camera intrinsic matrix and the distortion coefficients.

 <b>Note:</b>
 The solutions are sorted by reprojection errors (lowest to highest).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="solvePnP-org.opencv.core.MatOfPoint3f-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-org.opencv.core.MatOfDouble-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>solvePnP</h4>
<pre>public static&nbsp;boolean&nbsp;solvePnP(<a href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
                               <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                               <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec)</pre>
<div class="block">Finds an object pose from 3D-2D point correspondences.

 SEE: REF: calib3d_solvePnP

 This function returns the rotation and the translation vectors that transform a 3D point expressed in the object
 coordinate frame to the camera coordinate frame, using different methods:
 <ul>
   <li>
  P3P methods (REF: SOLVEPNP_P3P, REF: SOLVEPNP_AP3P): need 4 input points to return a unique solution.
   </li>
   <li>
  REF: SOLVEPNP_IPPE Input points must be &gt;= 4 and object points must be coplanar.
   </li>
   <li>
  REF: SOLVEPNP_IPPE_SQUARE Special case suitable for marker pose estimation.
 Number of input points must be 4. Object points must be defined in the following order:
   <ul>
     <li>
    point 0: [-squareLength / 2,  squareLength / 2, 0]
     </li>
     <li>
    point 1: [ squareLength / 2,  squareLength / 2, 0]
     </li>
     <li>
    point 2: [ squareLength / 2, -squareLength / 2, 0]
     </li>
     <li>
    point 3: [-squareLength / 2, -squareLength / 2, 0]
     </li>
   </ul>
   <li>
  for all the other flags, number of input points must be &gt;= 4 and object points can be in any configuration.
   </li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>objectPoints</code> - Array of object points in the object coordinate space, Nx3 1-channel or
 1xN/Nx1 3-channel, where N is the number of points. vector&lt;Point3d&gt; can be also passed here.</dd>
<dd><code>imagePoints</code> - Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,
 where N is the number of points. vector&lt;Point2d&gt; can be also passed here.</dd>
<dd><code>cameraMatrix</code> - Input camera intrinsic matrix \(\cameramatrix{A}\) .</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are
 assumed.</dd>
<dd><code>rvec</code> - Output rotation vector (see REF: Rodrigues ) that, together with tvec, brings points from
 the model coordinate system to the camera coordinate system.</dd>
<dd><code>tvec</code> - Output translation vector.
 the provided rvec and tvec values as initial approximations of the rotation and translation
 vectors, respectively, and further optimizes them.

 More information about Perspective-n-Points is described in REF: calib3d_solvePnP

 <b>Note:</b>
 <ul>
   <li>
       An example of how to use solvePnP for planar augmented reality can be found at
         opencv_source_code/samples/python/plane_ar.py
   </li>
   <li>
       If you are using Python:
   <ul>
     <li>
          Numpy array slices won't work as input because solvePnP requires contiguous
         arrays (enforced by the assertion using cv::Mat::checkVector() around line 55 of
         modules/3d/src/solvepnp.cpp version 2.4.9)
     </li>
     <li>
          The P3P algorithm requires image points to be in an array of shape (N,1,2) due
         to its calling of #undistortPoints (around line 75 of modules/3d/src/solvepnp.cpp version 2.4.9)
         which requires 2-channel information.
     </li>
     <li>
          Thus, given some data D = np.array(...) where D.shape = (N,M), in order to use a subset of
         it as, e.g., imagePoints, one must effectively copy it into a new array: imagePoints =
         np.ascontiguousarray(D[:,:2]).reshape((N,1,2))
     </li>
   </ul>
   <li>
       The methods REF: SOLVEPNP_DLS and REF: SOLVEPNP_UPNP cannot be used as the current implementations are
        unstable and sometimes give completely wrong results. If you pass one of these two
        flags, REF: SOLVEPNP_EPNP method will be used instead.
   </li>
   <li>
       The minimum number of points is 4 in the general case. In the case of REF: SOLVEPNP_P3P and REF: SOLVEPNP_AP3P
        methods, it is required to use exactly 4 points (the first 3 points are used to estimate all the solutions
        of the P3P problem, the last one is used to retain the best solution that minimizes the reprojection error).
   </li>
   <li>
       With REF: SOLVEPNP_ITERATIVE method and <code>useExtrinsicGuess=true</code>, the minimum number of points is 3 (3 points
        are sufficient to compute a pose but there are up to 4 solutions). The initial solution should be close to the
        global solution to converge.
   </li>
   <li>
       With REF: SOLVEPNP_IPPE input points must be &gt;= 4 and object points must be coplanar.
   </li>
   <li>
       With REF: SOLVEPNP_IPPE_SQUARE this is a special case suitable for marker pose estimation.
        Number of input points must be 4. Object points must be defined in the following order:
   <ul>
     <li>
           point 0: [-squareLength / 2,  squareLength / 2, 0]
     </li>
     <li>
           point 1: [ squareLength / 2,  squareLength / 2, 0]
     </li>
     <li>
           point 2: [ squareLength / 2, -squareLength / 2, 0]
     </li>
     <li>
           point 3: [-squareLength / 2, -squareLength / 2, 0]
     </li>
   </ul>
   <ul>
     <li>
       With REF: SOLVEPNP_SQPNP input points must be &gt;= 3
     </li>
   </ul>
   </li>
 </ul></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="solvePnP-org.opencv.core.MatOfPoint3f-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-org.opencv.core.MatOfDouble-org.opencv.core.Mat-org.opencv.core.Mat-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>solvePnP</h4>
<pre>public static&nbsp;boolean&nbsp;solvePnP(<a href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
                               <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                               <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                               boolean&nbsp;useExtrinsicGuess)</pre>
<div class="block">Finds an object pose from 3D-2D point correspondences.

 SEE: REF: calib3d_solvePnP

 This function returns the rotation and the translation vectors that transform a 3D point expressed in the object
 coordinate frame to the camera coordinate frame, using different methods:
 <ul>
   <li>
  P3P methods (REF: SOLVEPNP_P3P, REF: SOLVEPNP_AP3P): need 4 input points to return a unique solution.
   </li>
   <li>
  REF: SOLVEPNP_IPPE Input points must be &gt;= 4 and object points must be coplanar.
   </li>
   <li>
  REF: SOLVEPNP_IPPE_SQUARE Special case suitable for marker pose estimation.
 Number of input points must be 4. Object points must be defined in the following order:
   <ul>
     <li>
    point 0: [-squareLength / 2,  squareLength / 2, 0]
     </li>
     <li>
    point 1: [ squareLength / 2,  squareLength / 2, 0]
     </li>
     <li>
    point 2: [ squareLength / 2, -squareLength / 2, 0]
     </li>
     <li>
    point 3: [-squareLength / 2, -squareLength / 2, 0]
     </li>
   </ul>
   <li>
  for all the other flags, number of input points must be &gt;= 4 and object points can be in any configuration.
   </li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>objectPoints</code> - Array of object points in the object coordinate space, Nx3 1-channel or
 1xN/Nx1 3-channel, where N is the number of points. vector&lt;Point3d&gt; can be also passed here.</dd>
<dd><code>imagePoints</code> - Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,
 where N is the number of points. vector&lt;Point2d&gt; can be also passed here.</dd>
<dd><code>cameraMatrix</code> - Input camera intrinsic matrix \(\cameramatrix{A}\) .</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are
 assumed.</dd>
<dd><code>rvec</code> - Output rotation vector (see REF: Rodrigues ) that, together with tvec, brings points from
 the model coordinate system to the camera coordinate system.</dd>
<dd><code>tvec</code> - Output translation vector.</dd>
<dd><code>useExtrinsicGuess</code> - Parameter used for #SOLVEPNP_ITERATIVE. If true (1), the function uses
 the provided rvec and tvec values as initial approximations of the rotation and translation
 vectors, respectively, and further optimizes them.

 More information about Perspective-n-Points is described in REF: calib3d_solvePnP

 <b>Note:</b>
 <ul>
   <li>
       An example of how to use solvePnP for planar augmented reality can be found at
         opencv_source_code/samples/python/plane_ar.py
   </li>
   <li>
       If you are using Python:
   <ul>
     <li>
          Numpy array slices won't work as input because solvePnP requires contiguous
         arrays (enforced by the assertion using cv::Mat::checkVector() around line 55 of
         modules/3d/src/solvepnp.cpp version 2.4.9)
     </li>
     <li>
          The P3P algorithm requires image points to be in an array of shape (N,1,2) due
         to its calling of #undistortPoints (around line 75 of modules/3d/src/solvepnp.cpp version 2.4.9)
         which requires 2-channel information.
     </li>
     <li>
          Thus, given some data D = np.array(...) where D.shape = (N,M), in order to use a subset of
         it as, e.g., imagePoints, one must effectively copy it into a new array: imagePoints =
         np.ascontiguousarray(D[:,:2]).reshape((N,1,2))
     </li>
   </ul>
   <li>
       The methods REF: SOLVEPNP_DLS and REF: SOLVEPNP_UPNP cannot be used as the current implementations are
        unstable and sometimes give completely wrong results. If you pass one of these two
        flags, REF: SOLVEPNP_EPNP method will be used instead.
   </li>
   <li>
       The minimum number of points is 4 in the general case. In the case of REF: SOLVEPNP_P3P and REF: SOLVEPNP_AP3P
        methods, it is required to use exactly 4 points (the first 3 points are used to estimate all the solutions
        of the P3P problem, the last one is used to retain the best solution that minimizes the reprojection error).
   </li>
   <li>
       With REF: SOLVEPNP_ITERATIVE method and <code>useExtrinsicGuess=true</code>, the minimum number of points is 3 (3 points
        are sufficient to compute a pose but there are up to 4 solutions). The initial solution should be close to the
        global solution to converge.
   </li>
   <li>
       With REF: SOLVEPNP_IPPE input points must be &gt;= 4 and object points must be coplanar.
   </li>
   <li>
       With REF: SOLVEPNP_IPPE_SQUARE this is a special case suitable for marker pose estimation.
        Number of input points must be 4. Object points must be defined in the following order:
   <ul>
     <li>
           point 0: [-squareLength / 2,  squareLength / 2, 0]
     </li>
     <li>
           point 1: [ squareLength / 2,  squareLength / 2, 0]
     </li>
     <li>
           point 2: [ squareLength / 2, -squareLength / 2, 0]
     </li>
     <li>
           point 3: [-squareLength / 2, -squareLength / 2, 0]
     </li>
   </ul>
   <ul>
     <li>
       With REF: SOLVEPNP_SQPNP input points must be &gt;= 3
     </li>
   </ul>
   </li>
 </ul></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="solvePnP-org.opencv.core.MatOfPoint3f-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-org.opencv.core.MatOfDouble-org.opencv.core.Mat-org.opencv.core.Mat-boolean-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>solvePnP</h4>
<pre>public static&nbsp;boolean&nbsp;solvePnP(<a href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
                               <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                               <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                               boolean&nbsp;useExtrinsicGuess,
                               int&nbsp;flags)</pre>
<div class="block">Finds an object pose from 3D-2D point correspondences.

 SEE: REF: calib3d_solvePnP

 This function returns the rotation and the translation vectors that transform a 3D point expressed in the object
 coordinate frame to the camera coordinate frame, using different methods:
 <ul>
   <li>
  P3P methods (REF: SOLVEPNP_P3P, REF: SOLVEPNP_AP3P): need 4 input points to return a unique solution.
   </li>
   <li>
  REF: SOLVEPNP_IPPE Input points must be &gt;= 4 and object points must be coplanar.
   </li>
   <li>
  REF: SOLVEPNP_IPPE_SQUARE Special case suitable for marker pose estimation.
 Number of input points must be 4. Object points must be defined in the following order:
   <ul>
     <li>
    point 0: [-squareLength / 2,  squareLength / 2, 0]
     </li>
     <li>
    point 1: [ squareLength / 2,  squareLength / 2, 0]
     </li>
     <li>
    point 2: [ squareLength / 2, -squareLength / 2, 0]
     </li>
     <li>
    point 3: [-squareLength / 2, -squareLength / 2, 0]
     </li>
   </ul>
   <li>
  for all the other flags, number of input points must be &gt;= 4 and object points can be in any configuration.
   </li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>objectPoints</code> - Array of object points in the object coordinate space, Nx3 1-channel or
 1xN/Nx1 3-channel, where N is the number of points. vector&lt;Point3d&gt; can be also passed here.</dd>
<dd><code>imagePoints</code> - Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,
 where N is the number of points. vector&lt;Point2d&gt; can be also passed here.</dd>
<dd><code>cameraMatrix</code> - Input camera intrinsic matrix \(\cameramatrix{A}\) .</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are
 assumed.</dd>
<dd><code>rvec</code> - Output rotation vector (see REF: Rodrigues ) that, together with tvec, brings points from
 the model coordinate system to the camera coordinate system.</dd>
<dd><code>tvec</code> - Output translation vector.</dd>
<dd><code>useExtrinsicGuess</code> - Parameter used for #SOLVEPNP_ITERATIVE. If true (1), the function uses
 the provided rvec and tvec values as initial approximations of the rotation and translation
 vectors, respectively, and further optimizes them.</dd>
<dd><code>flags</code> - Method for solving a PnP problem: see REF: calib3d_solvePnP_flags

 More information about Perspective-n-Points is described in REF: calib3d_solvePnP

 <b>Note:</b>
 <ul>
   <li>
       An example of how to use solvePnP for planar augmented reality can be found at
         opencv_source_code/samples/python/plane_ar.py
   </li>
   <li>
       If you are using Python:
   <ul>
     <li>
          Numpy array slices won't work as input because solvePnP requires contiguous
         arrays (enforced by the assertion using cv::Mat::checkVector() around line 55 of
         modules/3d/src/solvepnp.cpp version 2.4.9)
     </li>
     <li>
          The P3P algorithm requires image points to be in an array of shape (N,1,2) due
         to its calling of #undistortPoints (around line 75 of modules/3d/src/solvepnp.cpp version 2.4.9)
         which requires 2-channel information.
     </li>
     <li>
          Thus, given some data D = np.array(...) where D.shape = (N,M), in order to use a subset of
         it as, e.g., imagePoints, one must effectively copy it into a new array: imagePoints =
         np.ascontiguousarray(D[:,:2]).reshape((N,1,2))
     </li>
   </ul>
   <li>
       The methods REF: SOLVEPNP_DLS and REF: SOLVEPNP_UPNP cannot be used as the current implementations are
        unstable and sometimes give completely wrong results. If you pass one of these two
        flags, REF: SOLVEPNP_EPNP method will be used instead.
   </li>
   <li>
       The minimum number of points is 4 in the general case. In the case of REF: SOLVEPNP_P3P and REF: SOLVEPNP_AP3P
        methods, it is required to use exactly 4 points (the first 3 points are used to estimate all the solutions
        of the P3P problem, the last one is used to retain the best solution that minimizes the reprojection error).
   </li>
   <li>
       With REF: SOLVEPNP_ITERATIVE method and <code>useExtrinsicGuess=true</code>, the minimum number of points is 3 (3 points
        are sufficient to compute a pose but there are up to 4 solutions). The initial solution should be close to the
        global solution to converge.
   </li>
   <li>
       With REF: SOLVEPNP_IPPE input points must be &gt;= 4 and object points must be coplanar.
   </li>
   <li>
       With REF: SOLVEPNP_IPPE_SQUARE this is a special case suitable for marker pose estimation.
        Number of input points must be 4. Object points must be defined in the following order:
   <ul>
     <li>
           point 0: [-squareLength / 2,  squareLength / 2, 0]
     </li>
     <li>
           point 1: [ squareLength / 2,  squareLength / 2, 0]
     </li>
     <li>
           point 2: [ squareLength / 2, -squareLength / 2, 0]
     </li>
     <li>
           point 3: [-squareLength / 2, -squareLength / 2, 0]
     </li>
   </ul>
   <ul>
     <li>
       With REF: SOLVEPNP_SQPNP input points must be &gt;= 3
     </li>
   </ul>
   </li>
 </ul></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="solvePnPGeneric-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-java.util.List-java.util.List-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>solvePnPGeneric</h4>
<pre>public static&nbsp;int&nbsp;solvePnPGeneric(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                                  java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;rvecs,
                                  java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;tvecs)</pre>
<div class="block">Finds an object pose from 3D-2D point correspondences.

 SEE: REF: calib3d_solvePnP

 This function returns a list of all the possible solutions (a solution is a &lt;rotation vector, translation vector&gt;
 couple), depending on the number of input points and the chosen method:
 <ul>
   <li>
  P3P methods (REF: SOLVEPNP_P3P, REF: SOLVEPNP_AP3P): 3 or 4 input points. Number of returned solutions can be between 0 and 4 with 3 input points.
   </li>
   <li>
  REF: SOLVEPNP_IPPE Input points must be &gt;= 4 and object points must be coplanar. Returns 2 solutions.
   </li>
   <li>
  REF: SOLVEPNP_IPPE_SQUARE Special case suitable for marker pose estimation.
 Number of input points must be 4 and 2 solutions are returned. Object points must be defined in the following order:
   <ul>
     <li>
    point 0: [-squareLength / 2,  squareLength / 2, 0]
     </li>
     <li>
    point 1: [ squareLength / 2,  squareLength / 2, 0]
     </li>
     <li>
    point 2: [ squareLength / 2, -squareLength / 2, 0]
     </li>
     <li>
    point 3: [-squareLength / 2, -squareLength / 2, 0]
     </li>
   </ul>
   <li>
  for all the other flags, number of input points must be &gt;= 4 and object points can be in any configuration.
 Only 1 solution is returned.
   </li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>objectPoints</code> - Array of object points in the object coordinate space, Nx3 1-channel or
 1xN/Nx1 3-channel, where N is the number of points. vector&lt;Point3d&gt; can be also passed here.</dd>
<dd><code>imagePoints</code> - Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,
 where N is the number of points. vector&lt;Point2d&gt; can be also passed here.</dd>
<dd><code>cameraMatrix</code> - Input camera intrinsic matrix \(\cameramatrix{A}\) .</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are
 assumed.</dd>
<dd><code>rvecs</code> - Vector of output rotation vectors (see REF: Rodrigues ) that, together with tvecs, brings points from
 the model coordinate system to the camera coordinate system.</dd>
<dd><code>tvecs</code> - Vector of output translation vectors.
 the provided rvec and tvec values as initial approximations of the rotation and translation
 vectors, respectively, and further optimizes them.
 and useExtrinsicGuess is set to true.
 and useExtrinsicGuess is set to true.
 (\( \text{RMSE} = \sqrt{\frac{\sum_{i}^{N} \left ( \hat{y_i} - y_i \right )^2}{N}} \)) between the input image points
 and the 3D object points projected with the estimated pose.

 More information is described in REF: calib3d_solvePnP

 <b>Note:</b>
 <ul>
   <li>
       An example of how to use solvePnP for planar augmented reality can be found at
         opencv_source_code/samples/python/plane_ar.py
   </li>
   <li>
       If you are using Python:
   <ul>
     <li>
          Numpy array slices won't work as input because solvePnP requires contiguous
         arrays (enforced by the assertion using cv::Mat::checkVector() around line 55 of
         modules/3d/src/solvepnp.cpp version 2.4.9)
     </li>
     <li>
          The P3P algorithm requires image points to be in an array of shape (N,1,2) due
         to its calling of #undistortPoints (around line 75 of modules/3d/src/solvepnp.cpp version 2.4.9)
         which requires 2-channel information.
     </li>
     <li>
          Thus, given some data D = np.array(...) where D.shape = (N,M), in order to use a subset of
         it as, e.g., imagePoints, one must effectively copy it into a new array: imagePoints =
         np.ascontiguousarray(D[:,:2]).reshape((N,1,2))
     </li>
   </ul>
   <li>
       The methods REF: SOLVEPNP_DLS and REF: SOLVEPNP_UPNP cannot be used as the current implementations are
        unstable and sometimes give completely wrong results. If you pass one of these two
        flags, REF: SOLVEPNP_EPNP method will be used instead.
   </li>
   <li>
       The minimum number of points is 4 in the general case. In the case of REF: SOLVEPNP_P3P and REF: SOLVEPNP_AP3P
        methods, it is required to use exactly 4 points (the first 3 points are used to estimate all the solutions
        of the P3P problem, the last one is used to retain the best solution that minimizes the reprojection error).
   </li>
   <li>
       With REF: SOLVEPNP_ITERATIVE method and <code>useExtrinsicGuess=true</code>, the minimum number of points is 3 (3 points
        are sufficient to compute a pose but there are up to 4 solutions). The initial solution should be close to the
        global solution to converge.
   </li>
   <li>
       With REF: SOLVEPNP_IPPE input points must be &gt;= 4 and object points must be coplanar.
   </li>
   <li>
       With REF: SOLVEPNP_IPPE_SQUARE this is a special case suitable for marker pose estimation.
        Number of input points must be 4. Object points must be defined in the following order:
   <ul>
     <li>
           point 0: [-squareLength / 2,  squareLength / 2, 0]
     </li>
     <li>
           point 1: [ squareLength / 2,  squareLength / 2, 0]
     </li>
     <li>
           point 2: [ squareLength / 2, -squareLength / 2, 0]
     </li>
     <li>
           point 3: [-squareLength / 2, -squareLength / 2, 0]
     </li>
   </ul>
   </li>
 </ul></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="solvePnPGeneric-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-java.util.List-java.util.List-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>solvePnPGeneric</h4>
<pre>public static&nbsp;int&nbsp;solvePnPGeneric(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                                  java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;rvecs,
                                  java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;tvecs,
                                  boolean&nbsp;useExtrinsicGuess)</pre>
<div class="block">Finds an object pose from 3D-2D point correspondences.

 SEE: REF: calib3d_solvePnP

 This function returns a list of all the possible solutions (a solution is a &lt;rotation vector, translation vector&gt;
 couple), depending on the number of input points and the chosen method:
 <ul>
   <li>
  P3P methods (REF: SOLVEPNP_P3P, REF: SOLVEPNP_AP3P): 3 or 4 input points. Number of returned solutions can be between 0 and 4 with 3 input points.
   </li>
   <li>
  REF: SOLVEPNP_IPPE Input points must be &gt;= 4 and object points must be coplanar. Returns 2 solutions.
   </li>
   <li>
  REF: SOLVEPNP_IPPE_SQUARE Special case suitable for marker pose estimation.
 Number of input points must be 4 and 2 solutions are returned. Object points must be defined in the following order:
   <ul>
     <li>
    point 0: [-squareLength / 2,  squareLength / 2, 0]
     </li>
     <li>
    point 1: [ squareLength / 2,  squareLength / 2, 0]
     </li>
     <li>
    point 2: [ squareLength / 2, -squareLength / 2, 0]
     </li>
     <li>
    point 3: [-squareLength / 2, -squareLength / 2, 0]
     </li>
   </ul>
   <li>
  for all the other flags, number of input points must be &gt;= 4 and object points can be in any configuration.
 Only 1 solution is returned.
   </li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>objectPoints</code> - Array of object points in the object coordinate space, Nx3 1-channel or
 1xN/Nx1 3-channel, where N is the number of points. vector&lt;Point3d&gt; can be also passed here.</dd>
<dd><code>imagePoints</code> - Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,
 where N is the number of points. vector&lt;Point2d&gt; can be also passed here.</dd>
<dd><code>cameraMatrix</code> - Input camera intrinsic matrix \(\cameramatrix{A}\) .</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are
 assumed.</dd>
<dd><code>rvecs</code> - Vector of output rotation vectors (see REF: Rodrigues ) that, together with tvecs, brings points from
 the model coordinate system to the camera coordinate system.</dd>
<dd><code>tvecs</code> - Vector of output translation vectors.</dd>
<dd><code>useExtrinsicGuess</code> - Parameter used for #SOLVEPNP_ITERATIVE. If true (1), the function uses
 the provided rvec and tvec values as initial approximations of the rotation and translation
 vectors, respectively, and further optimizes them.
 and useExtrinsicGuess is set to true.
 and useExtrinsicGuess is set to true.
 (\( \text{RMSE} = \sqrt{\frac{\sum_{i}^{N} \left ( \hat{y_i} - y_i \right )^2}{N}} \)) between the input image points
 and the 3D object points projected with the estimated pose.

 More information is described in REF: calib3d_solvePnP

 <b>Note:</b>
 <ul>
   <li>
       An example of how to use solvePnP for planar augmented reality can be found at
         opencv_source_code/samples/python/plane_ar.py
   </li>
   <li>
       If you are using Python:
   <ul>
     <li>
          Numpy array slices won't work as input because solvePnP requires contiguous
         arrays (enforced by the assertion using cv::Mat::checkVector() around line 55 of
         modules/3d/src/solvepnp.cpp version 2.4.9)
     </li>
     <li>
          The P3P algorithm requires image points to be in an array of shape (N,1,2) due
         to its calling of #undistortPoints (around line 75 of modules/3d/src/solvepnp.cpp version 2.4.9)
         which requires 2-channel information.
     </li>
     <li>
          Thus, given some data D = np.array(...) where D.shape = (N,M), in order to use a subset of
         it as, e.g., imagePoints, one must effectively copy it into a new array: imagePoints =
         np.ascontiguousarray(D[:,:2]).reshape((N,1,2))
     </li>
   </ul>
   <li>
       The methods REF: SOLVEPNP_DLS and REF: SOLVEPNP_UPNP cannot be used as the current implementations are
        unstable and sometimes give completely wrong results. If you pass one of these two
        flags, REF: SOLVEPNP_EPNP method will be used instead.
   </li>
   <li>
       The minimum number of points is 4 in the general case. In the case of REF: SOLVEPNP_P3P and REF: SOLVEPNP_AP3P
        methods, it is required to use exactly 4 points (the first 3 points are used to estimate all the solutions
        of the P3P problem, the last one is used to retain the best solution that minimizes the reprojection error).
   </li>
   <li>
       With REF: SOLVEPNP_ITERATIVE method and <code>useExtrinsicGuess=true</code>, the minimum number of points is 3 (3 points
        are sufficient to compute a pose but there are up to 4 solutions). The initial solution should be close to the
        global solution to converge.
   </li>
   <li>
       With REF: SOLVEPNP_IPPE input points must be &gt;= 4 and object points must be coplanar.
   </li>
   <li>
       With REF: SOLVEPNP_IPPE_SQUARE this is a special case suitable for marker pose estimation.
        Number of input points must be 4. Object points must be defined in the following order:
   <ul>
     <li>
           point 0: [-squareLength / 2,  squareLength / 2, 0]
     </li>
     <li>
           point 1: [ squareLength / 2,  squareLength / 2, 0]
     </li>
     <li>
           point 2: [ squareLength / 2, -squareLength / 2, 0]
     </li>
     <li>
           point 3: [-squareLength / 2, -squareLength / 2, 0]
     </li>
   </ul>
   </li>
 </ul></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="solvePnPGeneric-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-java.util.List-java.util.List-boolean-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>solvePnPGeneric</h4>
<pre>public static&nbsp;int&nbsp;solvePnPGeneric(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                                  java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;rvecs,
                                  java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;tvecs,
                                  boolean&nbsp;useExtrinsicGuess,
                                  int&nbsp;flags)</pre>
<div class="block">Finds an object pose from 3D-2D point correspondences.

 SEE: REF: calib3d_solvePnP

 This function returns a list of all the possible solutions (a solution is a &lt;rotation vector, translation vector&gt;
 couple), depending on the number of input points and the chosen method:
 <ul>
   <li>
  P3P methods (REF: SOLVEPNP_P3P, REF: SOLVEPNP_AP3P): 3 or 4 input points. Number of returned solutions can be between 0 and 4 with 3 input points.
   </li>
   <li>
  REF: SOLVEPNP_IPPE Input points must be &gt;= 4 and object points must be coplanar. Returns 2 solutions.
   </li>
   <li>
  REF: SOLVEPNP_IPPE_SQUARE Special case suitable for marker pose estimation.
 Number of input points must be 4 and 2 solutions are returned. Object points must be defined in the following order:
   <ul>
     <li>
    point 0: [-squareLength / 2,  squareLength / 2, 0]
     </li>
     <li>
    point 1: [ squareLength / 2,  squareLength / 2, 0]
     </li>
     <li>
    point 2: [ squareLength / 2, -squareLength / 2, 0]
     </li>
     <li>
    point 3: [-squareLength / 2, -squareLength / 2, 0]
     </li>
   </ul>
   <li>
  for all the other flags, number of input points must be &gt;= 4 and object points can be in any configuration.
 Only 1 solution is returned.
   </li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>objectPoints</code> - Array of object points in the object coordinate space, Nx3 1-channel or
 1xN/Nx1 3-channel, where N is the number of points. vector&lt;Point3d&gt; can be also passed here.</dd>
<dd><code>imagePoints</code> - Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,
 where N is the number of points. vector&lt;Point2d&gt; can be also passed here.</dd>
<dd><code>cameraMatrix</code> - Input camera intrinsic matrix \(\cameramatrix{A}\) .</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are
 assumed.</dd>
<dd><code>rvecs</code> - Vector of output rotation vectors (see REF: Rodrigues ) that, together with tvecs, brings points from
 the model coordinate system to the camera coordinate system.</dd>
<dd><code>tvecs</code> - Vector of output translation vectors.</dd>
<dd><code>useExtrinsicGuess</code> - Parameter used for #SOLVEPNP_ITERATIVE. If true (1), the function uses
 the provided rvec and tvec values as initial approximations of the rotation and translation
 vectors, respectively, and further optimizes them.</dd>
<dd><code>flags</code> - Method for solving a PnP problem: see REF: calib3d_solvePnP_flags
 and useExtrinsicGuess is set to true.
 and useExtrinsicGuess is set to true.
 (\( \text{RMSE} = \sqrt{\frac{\sum_{i}^{N} \left ( \hat{y_i} - y_i \right )^2}{N}} \)) between the input image points
 and the 3D object points projected with the estimated pose.

 More information is described in REF: calib3d_solvePnP

 <b>Note:</b>
 <ul>
   <li>
       An example of how to use solvePnP for planar augmented reality can be found at
         opencv_source_code/samples/python/plane_ar.py
   </li>
   <li>
       If you are using Python:
   <ul>
     <li>
          Numpy array slices won't work as input because solvePnP requires contiguous
         arrays (enforced by the assertion using cv::Mat::checkVector() around line 55 of
         modules/3d/src/solvepnp.cpp version 2.4.9)
     </li>
     <li>
          The P3P algorithm requires image points to be in an array of shape (N,1,2) due
         to its calling of #undistortPoints (around line 75 of modules/3d/src/solvepnp.cpp version 2.4.9)
         which requires 2-channel information.
     </li>
     <li>
          Thus, given some data D = np.array(...) where D.shape = (N,M), in order to use a subset of
         it as, e.g., imagePoints, one must effectively copy it into a new array: imagePoints =
         np.ascontiguousarray(D[:,:2]).reshape((N,1,2))
     </li>
   </ul>
   <li>
       The methods REF: SOLVEPNP_DLS and REF: SOLVEPNP_UPNP cannot be used as the current implementations are
        unstable and sometimes give completely wrong results. If you pass one of these two
        flags, REF: SOLVEPNP_EPNP method will be used instead.
   </li>
   <li>
       The minimum number of points is 4 in the general case. In the case of REF: SOLVEPNP_P3P and REF: SOLVEPNP_AP3P
        methods, it is required to use exactly 4 points (the first 3 points are used to estimate all the solutions
        of the P3P problem, the last one is used to retain the best solution that minimizes the reprojection error).
   </li>
   <li>
       With REF: SOLVEPNP_ITERATIVE method and <code>useExtrinsicGuess=true</code>, the minimum number of points is 3 (3 points
        are sufficient to compute a pose but there are up to 4 solutions). The initial solution should be close to the
        global solution to converge.
   </li>
   <li>
       With REF: SOLVEPNP_IPPE input points must be &gt;= 4 and object points must be coplanar.
   </li>
   <li>
       With REF: SOLVEPNP_IPPE_SQUARE this is a special case suitable for marker pose estimation.
        Number of input points must be 4. Object points must be defined in the following order:
   <ul>
     <li>
           point 0: [-squareLength / 2,  squareLength / 2, 0]
     </li>
     <li>
           point 1: [ squareLength / 2,  squareLength / 2, 0]
     </li>
     <li>
           point 2: [ squareLength / 2, -squareLength / 2, 0]
     </li>
     <li>
           point 3: [-squareLength / 2, -squareLength / 2, 0]
     </li>
   </ul>
   </li>
 </ul></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="solvePnPGeneric-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-java.util.List-java.util.List-boolean-int-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>solvePnPGeneric</h4>
<pre>public static&nbsp;int&nbsp;solvePnPGeneric(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                                  java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;rvecs,
                                  java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;tvecs,
                                  boolean&nbsp;useExtrinsicGuess,
                                  int&nbsp;flags,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec)</pre>
<div class="block">Finds an object pose from 3D-2D point correspondences.

 SEE: REF: calib3d_solvePnP

 This function returns a list of all the possible solutions (a solution is a &lt;rotation vector, translation vector&gt;
 couple), depending on the number of input points and the chosen method:
 <ul>
   <li>
  P3P methods (REF: SOLVEPNP_P3P, REF: SOLVEPNP_AP3P): 3 or 4 input points. Number of returned solutions can be between 0 and 4 with 3 input points.
   </li>
   <li>
  REF: SOLVEPNP_IPPE Input points must be &gt;= 4 and object points must be coplanar. Returns 2 solutions.
   </li>
   <li>
  REF: SOLVEPNP_IPPE_SQUARE Special case suitable for marker pose estimation.
 Number of input points must be 4 and 2 solutions are returned. Object points must be defined in the following order:
   <ul>
     <li>
    point 0: [-squareLength / 2,  squareLength / 2, 0]
     </li>
     <li>
    point 1: [ squareLength / 2,  squareLength / 2, 0]
     </li>
     <li>
    point 2: [ squareLength / 2, -squareLength / 2, 0]
     </li>
     <li>
    point 3: [-squareLength / 2, -squareLength / 2, 0]
     </li>
   </ul>
   <li>
  for all the other flags, number of input points must be &gt;= 4 and object points can be in any configuration.
 Only 1 solution is returned.
   </li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>objectPoints</code> - Array of object points in the object coordinate space, Nx3 1-channel or
 1xN/Nx1 3-channel, where N is the number of points. vector&lt;Point3d&gt; can be also passed here.</dd>
<dd><code>imagePoints</code> - Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,
 where N is the number of points. vector&lt;Point2d&gt; can be also passed here.</dd>
<dd><code>cameraMatrix</code> - Input camera intrinsic matrix \(\cameramatrix{A}\) .</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are
 assumed.</dd>
<dd><code>rvecs</code> - Vector of output rotation vectors (see REF: Rodrigues ) that, together with tvecs, brings points from
 the model coordinate system to the camera coordinate system.</dd>
<dd><code>tvecs</code> - Vector of output translation vectors.</dd>
<dd><code>useExtrinsicGuess</code> - Parameter used for #SOLVEPNP_ITERATIVE. If true (1), the function uses
 the provided rvec and tvec values as initial approximations of the rotation and translation
 vectors, respectively, and further optimizes them.</dd>
<dd><code>flags</code> - Method for solving a PnP problem: see REF: calib3d_solvePnP_flags</dd>
<dd><code>rvec</code> - Rotation vector used to initialize an iterative PnP refinement algorithm, when flag is REF: SOLVEPNP_ITERATIVE
 and useExtrinsicGuess is set to true.
 and useExtrinsicGuess is set to true.
 (\( \text{RMSE} = \sqrt{\frac{\sum_{i}^{N} \left ( \hat{y_i} - y_i \right )^2}{N}} \)) between the input image points
 and the 3D object points projected with the estimated pose.

 More information is described in REF: calib3d_solvePnP

 <b>Note:</b>
 <ul>
   <li>
       An example of how to use solvePnP for planar augmented reality can be found at
         opencv_source_code/samples/python/plane_ar.py
   </li>
   <li>
       If you are using Python:
   <ul>
     <li>
          Numpy array slices won't work as input because solvePnP requires contiguous
         arrays (enforced by the assertion using cv::Mat::checkVector() around line 55 of
         modules/3d/src/solvepnp.cpp version 2.4.9)
     </li>
     <li>
          The P3P algorithm requires image points to be in an array of shape (N,1,2) due
         to its calling of #undistortPoints (around line 75 of modules/3d/src/solvepnp.cpp version 2.4.9)
         which requires 2-channel information.
     </li>
     <li>
          Thus, given some data D = np.array(...) where D.shape = (N,M), in order to use a subset of
         it as, e.g., imagePoints, one must effectively copy it into a new array: imagePoints =
         np.ascontiguousarray(D[:,:2]).reshape((N,1,2))
     </li>
   </ul>
   <li>
       The methods REF: SOLVEPNP_DLS and REF: SOLVEPNP_UPNP cannot be used as the current implementations are
        unstable and sometimes give completely wrong results. If you pass one of these two
        flags, REF: SOLVEPNP_EPNP method will be used instead.
   </li>
   <li>
       The minimum number of points is 4 in the general case. In the case of REF: SOLVEPNP_P3P and REF: SOLVEPNP_AP3P
        methods, it is required to use exactly 4 points (the first 3 points are used to estimate all the solutions
        of the P3P problem, the last one is used to retain the best solution that minimizes the reprojection error).
   </li>
   <li>
       With REF: SOLVEPNP_ITERATIVE method and <code>useExtrinsicGuess=true</code>, the minimum number of points is 3 (3 points
        are sufficient to compute a pose but there are up to 4 solutions). The initial solution should be close to the
        global solution to converge.
   </li>
   <li>
       With REF: SOLVEPNP_IPPE input points must be &gt;= 4 and object points must be coplanar.
   </li>
   <li>
       With REF: SOLVEPNP_IPPE_SQUARE this is a special case suitable for marker pose estimation.
        Number of input points must be 4. Object points must be defined in the following order:
   <ul>
     <li>
           point 0: [-squareLength / 2,  squareLength / 2, 0]
     </li>
     <li>
           point 1: [ squareLength / 2,  squareLength / 2, 0]
     </li>
     <li>
           point 2: [ squareLength / 2, -squareLength / 2, 0]
     </li>
     <li>
           point 3: [-squareLength / 2, -squareLength / 2, 0]
     </li>
   </ul>
   </li>
 </ul></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="solvePnPGeneric-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-java.util.List-java.util.List-boolean-int-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>solvePnPGeneric</h4>
<pre>public static&nbsp;int&nbsp;solvePnPGeneric(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                                  java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;rvecs,
                                  java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;tvecs,
                                  boolean&nbsp;useExtrinsicGuess,
                                  int&nbsp;flags,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec)</pre>
<div class="block">Finds an object pose from 3D-2D point correspondences.

 SEE: REF: calib3d_solvePnP

 This function returns a list of all the possible solutions (a solution is a &lt;rotation vector, translation vector&gt;
 couple), depending on the number of input points and the chosen method:
 <ul>
   <li>
  P3P methods (REF: SOLVEPNP_P3P, REF: SOLVEPNP_AP3P): 3 or 4 input points. Number of returned solutions can be between 0 and 4 with 3 input points.
   </li>
   <li>
  REF: SOLVEPNP_IPPE Input points must be &gt;= 4 and object points must be coplanar. Returns 2 solutions.
   </li>
   <li>
  REF: SOLVEPNP_IPPE_SQUARE Special case suitable for marker pose estimation.
 Number of input points must be 4 and 2 solutions are returned. Object points must be defined in the following order:
   <ul>
     <li>
    point 0: [-squareLength / 2,  squareLength / 2, 0]
     </li>
     <li>
    point 1: [ squareLength / 2,  squareLength / 2, 0]
     </li>
     <li>
    point 2: [ squareLength / 2, -squareLength / 2, 0]
     </li>
     <li>
    point 3: [-squareLength / 2, -squareLength / 2, 0]
     </li>
   </ul>
   <li>
  for all the other flags, number of input points must be &gt;= 4 and object points can be in any configuration.
 Only 1 solution is returned.
   </li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>objectPoints</code> - Array of object points in the object coordinate space, Nx3 1-channel or
 1xN/Nx1 3-channel, where N is the number of points. vector&lt;Point3d&gt; can be also passed here.</dd>
<dd><code>imagePoints</code> - Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,
 where N is the number of points. vector&lt;Point2d&gt; can be also passed here.</dd>
<dd><code>cameraMatrix</code> - Input camera intrinsic matrix \(\cameramatrix{A}\) .</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are
 assumed.</dd>
<dd><code>rvecs</code> - Vector of output rotation vectors (see REF: Rodrigues ) that, together with tvecs, brings points from
 the model coordinate system to the camera coordinate system.</dd>
<dd><code>tvecs</code> - Vector of output translation vectors.</dd>
<dd><code>useExtrinsicGuess</code> - Parameter used for #SOLVEPNP_ITERATIVE. If true (1), the function uses
 the provided rvec and tvec values as initial approximations of the rotation and translation
 vectors, respectively, and further optimizes them.</dd>
<dd><code>flags</code> - Method for solving a PnP problem: see REF: calib3d_solvePnP_flags</dd>
<dd><code>rvec</code> - Rotation vector used to initialize an iterative PnP refinement algorithm, when flag is REF: SOLVEPNP_ITERATIVE
 and useExtrinsicGuess is set to true.</dd>
<dd><code>tvec</code> - Translation vector used to initialize an iterative PnP refinement algorithm, when flag is REF: SOLVEPNP_ITERATIVE
 and useExtrinsicGuess is set to true.
 (\( \text{RMSE} = \sqrt{\frac{\sum_{i}^{N} \left ( \hat{y_i} - y_i \right )^2}{N}} \)) between the input image points
 and the 3D object points projected with the estimated pose.

 More information is described in REF: calib3d_solvePnP

 <b>Note:</b>
 <ul>
   <li>
       An example of how to use solvePnP for planar augmented reality can be found at
         opencv_source_code/samples/python/plane_ar.py
   </li>
   <li>
       If you are using Python:
   <ul>
     <li>
          Numpy array slices won't work as input because solvePnP requires contiguous
         arrays (enforced by the assertion using cv::Mat::checkVector() around line 55 of
         modules/3d/src/solvepnp.cpp version 2.4.9)
     </li>
     <li>
          The P3P algorithm requires image points to be in an array of shape (N,1,2) due
         to its calling of #undistortPoints (around line 75 of modules/3d/src/solvepnp.cpp version 2.4.9)
         which requires 2-channel information.
     </li>
     <li>
          Thus, given some data D = np.array(...) where D.shape = (N,M), in order to use a subset of
         it as, e.g., imagePoints, one must effectively copy it into a new array: imagePoints =
         np.ascontiguousarray(D[:,:2]).reshape((N,1,2))
     </li>
   </ul>
   <li>
       The methods REF: SOLVEPNP_DLS and REF: SOLVEPNP_UPNP cannot be used as the current implementations are
        unstable and sometimes give completely wrong results. If you pass one of these two
        flags, REF: SOLVEPNP_EPNP method will be used instead.
   </li>
   <li>
       The minimum number of points is 4 in the general case. In the case of REF: SOLVEPNP_P3P and REF: SOLVEPNP_AP3P
        methods, it is required to use exactly 4 points (the first 3 points are used to estimate all the solutions
        of the P3P problem, the last one is used to retain the best solution that minimizes the reprojection error).
   </li>
   <li>
       With REF: SOLVEPNP_ITERATIVE method and <code>useExtrinsicGuess=true</code>, the minimum number of points is 3 (3 points
        are sufficient to compute a pose but there are up to 4 solutions). The initial solution should be close to the
        global solution to converge.
   </li>
   <li>
       With REF: SOLVEPNP_IPPE input points must be &gt;= 4 and object points must be coplanar.
   </li>
   <li>
       With REF: SOLVEPNP_IPPE_SQUARE this is a special case suitable for marker pose estimation.
        Number of input points must be 4. Object points must be defined in the following order:
   <ul>
     <li>
           point 0: [-squareLength / 2,  squareLength / 2, 0]
     </li>
     <li>
           point 1: [ squareLength / 2,  squareLength / 2, 0]
     </li>
     <li>
           point 2: [ squareLength / 2, -squareLength / 2, 0]
     </li>
     <li>
           point 3: [-squareLength / 2, -squareLength / 2, 0]
     </li>
   </ul>
   </li>
 </ul></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="solvePnPGeneric-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-java.util.List-java.util.List-boolean-int-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>solvePnPGeneric</h4>
<pre>public static&nbsp;int&nbsp;solvePnPGeneric(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                                  java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;rvecs,
                                  java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;tvecs,
                                  boolean&nbsp;useExtrinsicGuess,
                                  int&nbsp;flags,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;reprojectionError)</pre>
<div class="block">Finds an object pose from 3D-2D point correspondences.

 SEE: REF: calib3d_solvePnP

 This function returns a list of all the possible solutions (a solution is a &lt;rotation vector, translation vector&gt;
 couple), depending on the number of input points and the chosen method:
 <ul>
   <li>
  P3P methods (REF: SOLVEPNP_P3P, REF: SOLVEPNP_AP3P): 3 or 4 input points. Number of returned solutions can be between 0 and 4 with 3 input points.
   </li>
   <li>
  REF: SOLVEPNP_IPPE Input points must be &gt;= 4 and object points must be coplanar. Returns 2 solutions.
   </li>
   <li>
  REF: SOLVEPNP_IPPE_SQUARE Special case suitable for marker pose estimation.
 Number of input points must be 4 and 2 solutions are returned. Object points must be defined in the following order:
   <ul>
     <li>
    point 0: [-squareLength / 2,  squareLength / 2, 0]
     </li>
     <li>
    point 1: [ squareLength / 2,  squareLength / 2, 0]
     </li>
     <li>
    point 2: [ squareLength / 2, -squareLength / 2, 0]
     </li>
     <li>
    point 3: [-squareLength / 2, -squareLength / 2, 0]
     </li>
   </ul>
   <li>
  for all the other flags, number of input points must be &gt;= 4 and object points can be in any configuration.
 Only 1 solution is returned.
   </li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>objectPoints</code> - Array of object points in the object coordinate space, Nx3 1-channel or
 1xN/Nx1 3-channel, where N is the number of points. vector&lt;Point3d&gt; can be also passed here.</dd>
<dd><code>imagePoints</code> - Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,
 where N is the number of points. vector&lt;Point2d&gt; can be also passed here.</dd>
<dd><code>cameraMatrix</code> - Input camera intrinsic matrix \(\cameramatrix{A}\) .</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are
 assumed.</dd>
<dd><code>rvecs</code> - Vector of output rotation vectors (see REF: Rodrigues ) that, together with tvecs, brings points from
 the model coordinate system to the camera coordinate system.</dd>
<dd><code>tvecs</code> - Vector of output translation vectors.</dd>
<dd><code>useExtrinsicGuess</code> - Parameter used for #SOLVEPNP_ITERATIVE. If true (1), the function uses
 the provided rvec and tvec values as initial approximations of the rotation and translation
 vectors, respectively, and further optimizes them.</dd>
<dd><code>flags</code> - Method for solving a PnP problem: see REF: calib3d_solvePnP_flags</dd>
<dd><code>rvec</code> - Rotation vector used to initialize an iterative PnP refinement algorithm, when flag is REF: SOLVEPNP_ITERATIVE
 and useExtrinsicGuess is set to true.</dd>
<dd><code>tvec</code> - Translation vector used to initialize an iterative PnP refinement algorithm, when flag is REF: SOLVEPNP_ITERATIVE
 and useExtrinsicGuess is set to true.</dd>
<dd><code>reprojectionError</code> - Optional vector of reprojection error, that is the RMS error
 (\( \text{RMSE} = \sqrt{\frac{\sum_{i}^{N} \left ( \hat{y_i} - y_i \right )^2}{N}} \)) between the input image points
 and the 3D object points projected with the estimated pose.

 More information is described in REF: calib3d_solvePnP

 <b>Note:</b>
 <ul>
   <li>
       An example of how to use solvePnP for planar augmented reality can be found at
         opencv_source_code/samples/python/plane_ar.py
   </li>
   <li>
       If you are using Python:
   <ul>
     <li>
          Numpy array slices won't work as input because solvePnP requires contiguous
         arrays (enforced by the assertion using cv::Mat::checkVector() around line 55 of
         modules/3d/src/solvepnp.cpp version 2.4.9)
     </li>
     <li>
          The P3P algorithm requires image points to be in an array of shape (N,1,2) due
         to its calling of #undistortPoints (around line 75 of modules/3d/src/solvepnp.cpp version 2.4.9)
         which requires 2-channel information.
     </li>
     <li>
          Thus, given some data D = np.array(...) where D.shape = (N,M), in order to use a subset of
         it as, e.g., imagePoints, one must effectively copy it into a new array: imagePoints =
         np.ascontiguousarray(D[:,:2]).reshape((N,1,2))
     </li>
   </ul>
   <li>
       The methods REF: SOLVEPNP_DLS and REF: SOLVEPNP_UPNP cannot be used as the current implementations are
        unstable and sometimes give completely wrong results. If you pass one of these two
        flags, REF: SOLVEPNP_EPNP method will be used instead.
   </li>
   <li>
       The minimum number of points is 4 in the general case. In the case of REF: SOLVEPNP_P3P and REF: SOLVEPNP_AP3P
        methods, it is required to use exactly 4 points (the first 3 points are used to estimate all the solutions
        of the P3P problem, the last one is used to retain the best solution that minimizes the reprojection error).
   </li>
   <li>
       With REF: SOLVEPNP_ITERATIVE method and <code>useExtrinsicGuess=true</code>, the minimum number of points is 3 (3 points
        are sufficient to compute a pose but there are up to 4 solutions). The initial solution should be close to the
        global solution to converge.
   </li>
   <li>
       With REF: SOLVEPNP_IPPE input points must be &gt;= 4 and object points must be coplanar.
   </li>
   <li>
       With REF: SOLVEPNP_IPPE_SQUARE this is a special case suitable for marker pose estimation.
        Number of input points must be 4. Object points must be defined in the following order:
   <ul>
     <li>
           point 0: [-squareLength / 2,  squareLength / 2, 0]
     </li>
     <li>
           point 1: [ squareLength / 2,  squareLength / 2, 0]
     </li>
     <li>
           point 2: [ squareLength / 2, -squareLength / 2, 0]
     </li>
     <li>
           point 3: [-squareLength / 2, -squareLength / 2, 0]
     </li>
   </ul>
   </li>
 </ul></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="solvePnPRansac-org.opencv.core.MatOfPoint3f-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-org.opencv.core.MatOfDouble-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>solvePnPRansac</h4>
<pre>public static&nbsp;boolean&nbsp;solvePnPRansac(<a href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
                                     <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                     <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec)</pre>
<div class="block">Finds an object pose from 3D-2D point correspondences using the RANSAC scheme.

 SEE: REF: calib3d_solvePnP</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>objectPoints</code> - Array of object points in the object coordinate space, Nx3 1-channel or
 1xN/Nx1 3-channel, where N is the number of points. vector&lt;Point3d&gt; can be also passed here.</dd>
<dd><code>imagePoints</code> - Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,
 where N is the number of points. vector&lt;Point2d&gt; can be also passed here.</dd>
<dd><code>cameraMatrix</code> - Input camera intrinsic matrix \(\cameramatrix{A}\) .</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are
 assumed.</dd>
<dd><code>rvec</code> - Output rotation vector (see REF: Rodrigues ) that, together with tvec, brings points from
 the model coordinate system to the camera coordinate system.</dd>
<dd><code>tvec</code> - Output translation vector.
 the provided rvec and tvec values as initial approximations of the rotation and translation
 vectors, respectively, and further optimizes them.
 is the maximum allowed distance between the observed and computed point projections to consider it
 an inlier.

 The function estimates an object pose given a set of object points, their corresponding image
 projections, as well as the camera intrinsic matrix and the distortion coefficients. This function finds such
 a pose that minimizes reprojection error, that is, the sum of squared distances between the observed
 projections imagePoints and the projected (using REF: projectPoints ) objectPoints. The use of RANSAC
 makes the function resistant to outliers.

 <b>Note:</b>
 <ul>
   <li>
       An example of how to use solvePNPRansac for object detection can be found at
         opencv_source_code/samples/cpp/tutorial_code/3d/real_time_pose_estimation/
   </li>
   <li>
       The default method used to estimate the camera pose for the Minimal Sample Sets step
        is #SOLVEPNP_EPNP. Exceptions are:
   <ul>
     <li>
           if you choose #SOLVEPNP_P3P or #SOLVEPNP_AP3P, these methods will be used.
     </li>
     <li>
           if the number of input points is equal to 4, #SOLVEPNP_P3P is used.
     </li>
   </ul>
   <li>
       The method used to estimate the camera pose using all the inliers is defined by the
        flags parameters unless it is equal to #SOLVEPNP_P3P or #SOLVEPNP_AP3P. In this case,
        the method #SOLVEPNP_EPNP will be used instead.
   </li>
 </ul></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="solvePnPRansac-org.opencv.core.MatOfPoint3f-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-org.opencv.core.MatOfDouble-org.opencv.core.Mat-org.opencv.core.Mat-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>solvePnPRansac</h4>
<pre>public static&nbsp;boolean&nbsp;solvePnPRansac(<a href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
                                     <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                     <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                                     boolean&nbsp;useExtrinsicGuess)</pre>
<div class="block">Finds an object pose from 3D-2D point correspondences using the RANSAC scheme.

 SEE: REF: calib3d_solvePnP</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>objectPoints</code> - Array of object points in the object coordinate space, Nx3 1-channel or
 1xN/Nx1 3-channel, where N is the number of points. vector&lt;Point3d&gt; can be also passed here.</dd>
<dd><code>imagePoints</code> - Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,
 where N is the number of points. vector&lt;Point2d&gt; can be also passed here.</dd>
<dd><code>cameraMatrix</code> - Input camera intrinsic matrix \(\cameramatrix{A}\) .</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are
 assumed.</dd>
<dd><code>rvec</code> - Output rotation vector (see REF: Rodrigues ) that, together with tvec, brings points from
 the model coordinate system to the camera coordinate system.</dd>
<dd><code>tvec</code> - Output translation vector.</dd>
<dd><code>useExtrinsicGuess</code> - Parameter used for REF: SOLVEPNP_ITERATIVE. If true (1), the function uses
 the provided rvec and tvec values as initial approximations of the rotation and translation
 vectors, respectively, and further optimizes them.
 is the maximum allowed distance between the observed and computed point projections to consider it
 an inlier.

 The function estimates an object pose given a set of object points, their corresponding image
 projections, as well as the camera intrinsic matrix and the distortion coefficients. This function finds such
 a pose that minimizes reprojection error, that is, the sum of squared distances between the observed
 projections imagePoints and the projected (using REF: projectPoints ) objectPoints. The use of RANSAC
 makes the function resistant to outliers.

 <b>Note:</b>
 <ul>
   <li>
       An example of how to use solvePNPRansac for object detection can be found at
         opencv_source_code/samples/cpp/tutorial_code/3d/real_time_pose_estimation/
   </li>
   <li>
       The default method used to estimate the camera pose for the Minimal Sample Sets step
        is #SOLVEPNP_EPNP. Exceptions are:
   <ul>
     <li>
           if you choose #SOLVEPNP_P3P or #SOLVEPNP_AP3P, these methods will be used.
     </li>
     <li>
           if the number of input points is equal to 4, #SOLVEPNP_P3P is used.
     </li>
   </ul>
   <li>
       The method used to estimate the camera pose using all the inliers is defined by the
        flags parameters unless it is equal to #SOLVEPNP_P3P or #SOLVEPNP_AP3P. In this case,
        the method #SOLVEPNP_EPNP will be used instead.
   </li>
 </ul></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="solvePnPRansac-org.opencv.core.MatOfPoint3f-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-org.opencv.core.MatOfDouble-org.opencv.core.Mat-org.opencv.core.Mat-boolean-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>solvePnPRansac</h4>
<pre>public static&nbsp;boolean&nbsp;solvePnPRansac(<a href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
                                     <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                     <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                                     boolean&nbsp;useExtrinsicGuess,
                                     int&nbsp;iterationsCount)</pre>
<div class="block">Finds an object pose from 3D-2D point correspondences using the RANSAC scheme.

 SEE: REF: calib3d_solvePnP</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>objectPoints</code> - Array of object points in the object coordinate space, Nx3 1-channel or
 1xN/Nx1 3-channel, where N is the number of points. vector&lt;Point3d&gt; can be also passed here.</dd>
<dd><code>imagePoints</code> - Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,
 where N is the number of points. vector&lt;Point2d&gt; can be also passed here.</dd>
<dd><code>cameraMatrix</code> - Input camera intrinsic matrix \(\cameramatrix{A}\) .</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are
 assumed.</dd>
<dd><code>rvec</code> - Output rotation vector (see REF: Rodrigues ) that, together with tvec, brings points from
 the model coordinate system to the camera coordinate system.</dd>
<dd><code>tvec</code> - Output translation vector.</dd>
<dd><code>useExtrinsicGuess</code> - Parameter used for REF: SOLVEPNP_ITERATIVE. If true (1), the function uses
 the provided rvec and tvec values as initial approximations of the rotation and translation
 vectors, respectively, and further optimizes them.</dd>
<dd><code>iterationsCount</code> - Number of iterations.
 is the maximum allowed distance between the observed and computed point projections to consider it
 an inlier.

 The function estimates an object pose given a set of object points, their corresponding image
 projections, as well as the camera intrinsic matrix and the distortion coefficients. This function finds such
 a pose that minimizes reprojection error, that is, the sum of squared distances between the observed
 projections imagePoints and the projected (using REF: projectPoints ) objectPoints. The use of RANSAC
 makes the function resistant to outliers.

 <b>Note:</b>
 <ul>
   <li>
       An example of how to use solvePNPRansac for object detection can be found at
         opencv_source_code/samples/cpp/tutorial_code/3d/real_time_pose_estimation/
   </li>
   <li>
       The default method used to estimate the camera pose for the Minimal Sample Sets step
        is #SOLVEPNP_EPNP. Exceptions are:
   <ul>
     <li>
           if you choose #SOLVEPNP_P3P or #SOLVEPNP_AP3P, these methods will be used.
     </li>
     <li>
           if the number of input points is equal to 4, #SOLVEPNP_P3P is used.
     </li>
   </ul>
   <li>
       The method used to estimate the camera pose using all the inliers is defined by the
        flags parameters unless it is equal to #SOLVEPNP_P3P or #SOLVEPNP_AP3P. In this case,
        the method #SOLVEPNP_EPNP will be used instead.
   </li>
 </ul></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="solvePnPRansac-org.opencv.core.MatOfPoint3f-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-org.opencv.core.MatOfDouble-org.opencv.core.Mat-org.opencv.core.Mat-boolean-int-float-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>solvePnPRansac</h4>
<pre>public static&nbsp;boolean&nbsp;solvePnPRansac(<a href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
                                     <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                     <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                                     boolean&nbsp;useExtrinsicGuess,
                                     int&nbsp;iterationsCount,
                                     float&nbsp;reprojectionError)</pre>
<div class="block">Finds an object pose from 3D-2D point correspondences using the RANSAC scheme.

 SEE: REF: calib3d_solvePnP</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>objectPoints</code> - Array of object points in the object coordinate space, Nx3 1-channel or
 1xN/Nx1 3-channel, where N is the number of points. vector&lt;Point3d&gt; can be also passed here.</dd>
<dd><code>imagePoints</code> - Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,
 where N is the number of points. vector&lt;Point2d&gt; can be also passed here.</dd>
<dd><code>cameraMatrix</code> - Input camera intrinsic matrix \(\cameramatrix{A}\) .</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are
 assumed.</dd>
<dd><code>rvec</code> - Output rotation vector (see REF: Rodrigues ) that, together with tvec, brings points from
 the model coordinate system to the camera coordinate system.</dd>
<dd><code>tvec</code> - Output translation vector.</dd>
<dd><code>useExtrinsicGuess</code> - Parameter used for REF: SOLVEPNP_ITERATIVE. If true (1), the function uses
 the provided rvec and tvec values as initial approximations of the rotation and translation
 vectors, respectively, and further optimizes them.</dd>
<dd><code>iterationsCount</code> - Number of iterations.</dd>
<dd><code>reprojectionError</code> - Inlier threshold value used by the RANSAC procedure. The parameter value
 is the maximum allowed distance between the observed and computed point projections to consider it
 an inlier.

 The function estimates an object pose given a set of object points, their corresponding image
 projections, as well as the camera intrinsic matrix and the distortion coefficients. This function finds such
 a pose that minimizes reprojection error, that is, the sum of squared distances between the observed
 projections imagePoints and the projected (using REF: projectPoints ) objectPoints. The use of RANSAC
 makes the function resistant to outliers.

 <b>Note:</b>
 <ul>
   <li>
       An example of how to use solvePNPRansac for object detection can be found at
         opencv_source_code/samples/cpp/tutorial_code/3d/real_time_pose_estimation/
   </li>
   <li>
       The default method used to estimate the camera pose for the Minimal Sample Sets step
        is #SOLVEPNP_EPNP. Exceptions are:
   <ul>
     <li>
           if you choose #SOLVEPNP_P3P or #SOLVEPNP_AP3P, these methods will be used.
     </li>
     <li>
           if the number of input points is equal to 4, #SOLVEPNP_P3P is used.
     </li>
   </ul>
   <li>
       The method used to estimate the camera pose using all the inliers is defined by the
        flags parameters unless it is equal to #SOLVEPNP_P3P or #SOLVEPNP_AP3P. In this case,
        the method #SOLVEPNP_EPNP will be used instead.
   </li>
 </ul></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="solvePnPRansac-org.opencv.core.MatOfPoint3f-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-org.opencv.core.MatOfDouble-org.opencv.core.Mat-org.opencv.core.Mat-boolean-int-float-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>solvePnPRansac</h4>
<pre>public static&nbsp;boolean&nbsp;solvePnPRansac(<a href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
                                     <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                     <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                                     boolean&nbsp;useExtrinsicGuess,
                                     int&nbsp;iterationsCount,
                                     float&nbsp;reprojectionError,
                                     double&nbsp;confidence)</pre>
<div class="block">Finds an object pose from 3D-2D point correspondences using the RANSAC scheme.

 SEE: REF: calib3d_solvePnP</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>objectPoints</code> - Array of object points in the object coordinate space, Nx3 1-channel or
 1xN/Nx1 3-channel, where N is the number of points. vector&lt;Point3d&gt; can be also passed here.</dd>
<dd><code>imagePoints</code> - Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,
 where N is the number of points. vector&lt;Point2d&gt; can be also passed here.</dd>
<dd><code>cameraMatrix</code> - Input camera intrinsic matrix \(\cameramatrix{A}\) .</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are
 assumed.</dd>
<dd><code>rvec</code> - Output rotation vector (see REF: Rodrigues ) that, together with tvec, brings points from
 the model coordinate system to the camera coordinate system.</dd>
<dd><code>tvec</code> - Output translation vector.</dd>
<dd><code>useExtrinsicGuess</code> - Parameter used for REF: SOLVEPNP_ITERATIVE. If true (1), the function uses
 the provided rvec and tvec values as initial approximations of the rotation and translation
 vectors, respectively, and further optimizes them.</dd>
<dd><code>iterationsCount</code> - Number of iterations.</dd>
<dd><code>reprojectionError</code> - Inlier threshold value used by the RANSAC procedure. The parameter value
 is the maximum allowed distance between the observed and computed point projections to consider it
 an inlier.</dd>
<dd><code>confidence</code> - The probability that the algorithm produces a useful result.

 The function estimates an object pose given a set of object points, their corresponding image
 projections, as well as the camera intrinsic matrix and the distortion coefficients. This function finds such
 a pose that minimizes reprojection error, that is, the sum of squared distances between the observed
 projections imagePoints and the projected (using REF: projectPoints ) objectPoints. The use of RANSAC
 makes the function resistant to outliers.

 <b>Note:</b>
 <ul>
   <li>
       An example of how to use solvePNPRansac for object detection can be found at
         opencv_source_code/samples/cpp/tutorial_code/3d/real_time_pose_estimation/
   </li>
   <li>
       The default method used to estimate the camera pose for the Minimal Sample Sets step
        is #SOLVEPNP_EPNP. Exceptions are:
   <ul>
     <li>
           if you choose #SOLVEPNP_P3P or #SOLVEPNP_AP3P, these methods will be used.
     </li>
     <li>
           if the number of input points is equal to 4, #SOLVEPNP_P3P is used.
     </li>
   </ul>
   <li>
       The method used to estimate the camera pose using all the inliers is defined by the
        flags parameters unless it is equal to #SOLVEPNP_P3P or #SOLVEPNP_AP3P. In this case,
        the method #SOLVEPNP_EPNP will be used instead.
   </li>
 </ul></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="solvePnPRansac-org.opencv.core.MatOfPoint3f-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-org.opencv.core.MatOfDouble-org.opencv.core.Mat-org.opencv.core.Mat-boolean-int-float-double-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>solvePnPRansac</h4>
<pre>public static&nbsp;boolean&nbsp;solvePnPRansac(<a href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
                                     <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                     <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                                     boolean&nbsp;useExtrinsicGuess,
                                     int&nbsp;iterationsCount,
                                     float&nbsp;reprojectionError,
                                     double&nbsp;confidence,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers)</pre>
<div class="block">Finds an object pose from 3D-2D point correspondences using the RANSAC scheme.

 SEE: REF: calib3d_solvePnP</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>objectPoints</code> - Array of object points in the object coordinate space, Nx3 1-channel or
 1xN/Nx1 3-channel, where N is the number of points. vector&lt;Point3d&gt; can be also passed here.</dd>
<dd><code>imagePoints</code> - Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,
 where N is the number of points. vector&lt;Point2d&gt; can be also passed here.</dd>
<dd><code>cameraMatrix</code> - Input camera intrinsic matrix \(\cameramatrix{A}\) .</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are
 assumed.</dd>
<dd><code>rvec</code> - Output rotation vector (see REF: Rodrigues ) that, together with tvec, brings points from
 the model coordinate system to the camera coordinate system.</dd>
<dd><code>tvec</code> - Output translation vector.</dd>
<dd><code>useExtrinsicGuess</code> - Parameter used for REF: SOLVEPNP_ITERATIVE. If true (1), the function uses
 the provided rvec and tvec values as initial approximations of the rotation and translation
 vectors, respectively, and further optimizes them.</dd>
<dd><code>iterationsCount</code> - Number of iterations.</dd>
<dd><code>reprojectionError</code> - Inlier threshold value used by the RANSAC procedure. The parameter value
 is the maximum allowed distance between the observed and computed point projections to consider it
 an inlier.</dd>
<dd><code>confidence</code> - The probability that the algorithm produces a useful result.</dd>
<dd><code>inliers</code> - Output vector that contains indices of inliers in objectPoints and imagePoints .

 The function estimates an object pose given a set of object points, their corresponding image
 projections, as well as the camera intrinsic matrix and the distortion coefficients. This function finds such
 a pose that minimizes reprojection error, that is, the sum of squared distances between the observed
 projections imagePoints and the projected (using REF: projectPoints ) objectPoints. The use of RANSAC
 makes the function resistant to outliers.

 <b>Note:</b>
 <ul>
   <li>
       An example of how to use solvePNPRansac for object detection can be found at
         opencv_source_code/samples/cpp/tutorial_code/3d/real_time_pose_estimation/
   </li>
   <li>
       The default method used to estimate the camera pose for the Minimal Sample Sets step
        is #SOLVEPNP_EPNP. Exceptions are:
   <ul>
     <li>
           if you choose #SOLVEPNP_P3P or #SOLVEPNP_AP3P, these methods will be used.
     </li>
     <li>
           if the number of input points is equal to 4, #SOLVEPNP_P3P is used.
     </li>
   </ul>
   <li>
       The method used to estimate the camera pose using all the inliers is defined by the
        flags parameters unless it is equal to #SOLVEPNP_P3P or #SOLVEPNP_AP3P. In this case,
        the method #SOLVEPNP_EPNP will be used instead.
   </li>
 </ul></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="solvePnPRansac-org.opencv.core.MatOfPoint3f-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-org.opencv.core.MatOfDouble-org.opencv.core.Mat-org.opencv.core.Mat-boolean-int-float-double-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>solvePnPRansac</h4>
<pre>public static&nbsp;boolean&nbsp;solvePnPRansac(<a href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
                                     <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                     <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                                     boolean&nbsp;useExtrinsicGuess,
                                     int&nbsp;iterationsCount,
                                     float&nbsp;reprojectionError,
                                     double&nbsp;confidence,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers,
                                     int&nbsp;flags)</pre>
<div class="block">Finds an object pose from 3D-2D point correspondences using the RANSAC scheme.

 SEE: REF: calib3d_solvePnP</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>objectPoints</code> - Array of object points in the object coordinate space, Nx3 1-channel or
 1xN/Nx1 3-channel, where N is the number of points. vector&lt;Point3d&gt; can be also passed here.</dd>
<dd><code>imagePoints</code> - Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,
 where N is the number of points. vector&lt;Point2d&gt; can be also passed here.</dd>
<dd><code>cameraMatrix</code> - Input camera intrinsic matrix \(\cameramatrix{A}\) .</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are
 assumed.</dd>
<dd><code>rvec</code> - Output rotation vector (see REF: Rodrigues ) that, together with tvec, brings points from
 the model coordinate system to the camera coordinate system.</dd>
<dd><code>tvec</code> - Output translation vector.</dd>
<dd><code>useExtrinsicGuess</code> - Parameter used for REF: SOLVEPNP_ITERATIVE. If true (1), the function uses
 the provided rvec and tvec values as initial approximations of the rotation and translation
 vectors, respectively, and further optimizes them.</dd>
<dd><code>iterationsCount</code> - Number of iterations.</dd>
<dd><code>reprojectionError</code> - Inlier threshold value used by the RANSAC procedure. The parameter value
 is the maximum allowed distance between the observed and computed point projections to consider it
 an inlier.</dd>
<dd><code>confidence</code> - The probability that the algorithm produces a useful result.</dd>
<dd><code>inliers</code> - Output vector that contains indices of inliers in objectPoints and imagePoints .</dd>
<dd><code>flags</code> - Method for solving a PnP problem (see REF: solvePnP ).

 The function estimates an object pose given a set of object points, their corresponding image
 projections, as well as the camera intrinsic matrix and the distortion coefficients. This function finds such
 a pose that minimizes reprojection error, that is, the sum of squared distances between the observed
 projections imagePoints and the projected (using REF: projectPoints ) objectPoints. The use of RANSAC
 makes the function resistant to outliers.

 <b>Note:</b>
 <ul>
   <li>
       An example of how to use solvePNPRansac for object detection can be found at
         opencv_source_code/samples/cpp/tutorial_code/3d/real_time_pose_estimation/
   </li>
   <li>
       The default method used to estimate the camera pose for the Minimal Sample Sets step
        is #SOLVEPNP_EPNP. Exceptions are:
   <ul>
     <li>
           if you choose #SOLVEPNP_P3P or #SOLVEPNP_AP3P, these methods will be used.
     </li>
     <li>
           if the number of input points is equal to 4, #SOLVEPNP_P3P is used.
     </li>
   </ul>
   <li>
       The method used to estimate the camera pose using all the inliers is defined by the
        flags parameters unless it is equal to #SOLVEPNP_P3P or #SOLVEPNP_AP3P. In this case,
        the method #SOLVEPNP_EPNP will be used instead.
   </li>
 </ul></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="solvePnPRansac-org.opencv.core.MatOfPoint3f-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-org.opencv.core.MatOfDouble-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>solvePnPRansac</h4>
<pre>public static&nbsp;boolean&nbsp;solvePnPRansac(<a href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
                                     <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                     <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers)</pre>
</li>
</ul>
<a name="solvePnPRansac-org.opencv.core.MatOfPoint3f-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-org.opencv.core.MatOfDouble-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.cv3d.UsacParams-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>solvePnPRansac</h4>
<pre>public static&nbsp;boolean&nbsp;solvePnPRansac(<a href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
                                     <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                     <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers,
                                     <a href="../../../org/opencv/cv3d/UsacParams.html" title="class in org.opencv.cv3d">UsacParams</a>&nbsp;params)</pre>
</li>
</ul>
<a name="solvePnPRefineLM-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>solvePnPRefineLM</h4>
<pre>public static&nbsp;void&nbsp;solvePnPRefineLM(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                                    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                                    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                                    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                                    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec)</pre>
<div class="block">Refine a pose (the translation and the rotation that transform a 3D point expressed in the object coordinate frame
 to the camera coordinate frame) from a 3D-2D point correspondences and starting from an initial solution.

 SEE: REF: calib3d_solvePnP</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>objectPoints</code> - Array of object points in the object coordinate space, Nx3 1-channel or 1xN/Nx1 3-channel,
 where N is the number of points. vector&lt;Point3d&gt; can also be passed here.</dd>
<dd><code>imagePoints</code> - Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,
 where N is the number of points. vector&lt;Point2d&gt; can also be passed here.</dd>
<dd><code>cameraMatrix</code> - Input camera intrinsic matrix \(\cameramatrix{A}\) .</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are
 assumed.</dd>
<dd><code>rvec</code> - Input/Output rotation vector (see REF: Rodrigues ) that, together with tvec, brings points from
 the model coordinate system to the camera coordinate system. Input values are used as an initial solution.</dd>
<dd><code>tvec</code> - Input/Output translation vector. Input values are used as an initial solution.

 The function refines the object pose given at least 3 object points, their corresponding image
 projections, an initial solution for the rotation and translation vector,
 as well as the camera intrinsic matrix and the distortion coefficients.
 The function minimizes the projection error with respect to the rotation and the translation vectors, according
 to a Levenberg-Marquardt iterative minimization CITE: Madsen04 CITE: Eade13 process.</dd>
</dl>
</li>
</ul>
<a name="solvePnPRefineLM-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.TermCriteria-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>solvePnPRefineLM</h4>
<pre>public static&nbsp;void&nbsp;solvePnPRefineLM(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                                    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                                    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                                    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                                    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                                    <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria)</pre>
<div class="block">Refine a pose (the translation and the rotation that transform a 3D point expressed in the object coordinate frame
 to the camera coordinate frame) from a 3D-2D point correspondences and starting from an initial solution.

 SEE: REF: calib3d_solvePnP</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>objectPoints</code> - Array of object points in the object coordinate space, Nx3 1-channel or 1xN/Nx1 3-channel,
 where N is the number of points. vector&lt;Point3d&gt; can also be passed here.</dd>
<dd><code>imagePoints</code> - Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,
 where N is the number of points. vector&lt;Point2d&gt; can also be passed here.</dd>
<dd><code>cameraMatrix</code> - Input camera intrinsic matrix \(\cameramatrix{A}\) .</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are
 assumed.</dd>
<dd><code>rvec</code> - Input/Output rotation vector (see REF: Rodrigues ) that, together with tvec, brings points from
 the model coordinate system to the camera coordinate system. Input values are used as an initial solution.</dd>
<dd><code>tvec</code> - Input/Output translation vector. Input values are used as an initial solution.</dd>
<dd><code>criteria</code> - Criteria when to stop the Levenberg-Marquard iterative algorithm.

 The function refines the object pose given at least 3 object points, their corresponding image
 projections, an initial solution for the rotation and translation vector,
 as well as the camera intrinsic matrix and the distortion coefficients.
 The function minimizes the projection error with respect to the rotation and the translation vectors, according
 to a Levenberg-Marquardt iterative minimization CITE: Madsen04 CITE: Eade13 process.</dd>
</dl>
</li>
</ul>
<a name="solvePnPRefineVVS-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>solvePnPRefineVVS</h4>
<pre>public static&nbsp;void&nbsp;solvePnPRefineVVS(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec)</pre>
<div class="block">Refine a pose (the translation and the rotation that transform a 3D point expressed in the object coordinate frame
 to the camera coordinate frame) from a 3D-2D point correspondences and starting from an initial solution.

 SEE: REF: calib3d_solvePnP</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>objectPoints</code> - Array of object points in the object coordinate space, Nx3 1-channel or 1xN/Nx1 3-channel,
 where N is the number of points. vector&lt;Point3d&gt; can also be passed here.</dd>
<dd><code>imagePoints</code> - Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,
 where N is the number of points. vector&lt;Point2d&gt; can also be passed here.</dd>
<dd><code>cameraMatrix</code> - Input camera intrinsic matrix \(\cameramatrix{A}\) .</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are
 assumed.</dd>
<dd><code>rvec</code> - Input/Output rotation vector (see REF: Rodrigues ) that, together with tvec, brings points from
 the model coordinate system to the camera coordinate system. Input values are used as an initial solution.</dd>
<dd><code>tvec</code> - Input/Output translation vector. Input values are used as an initial solution.
 gain in the Damped Gauss-Newton formulation.

 The function refines the object pose given at least 3 object points, their corresponding image
 projections, an initial solution for the rotation and translation vector,
 as well as the camera intrinsic matrix and the distortion coefficients.
 The function minimizes the projection error with respect to the rotation and the translation vectors, using a
 virtual visual servoing (VVS) CITE: Chaumette06 CITE: Marchand16 scheme.</dd>
</dl>
</li>
</ul>
<a name="solvePnPRefineVVS-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.TermCriteria-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>solvePnPRefineVVS</h4>
<pre>public static&nbsp;void&nbsp;solvePnPRefineVVS(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                                     <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria)</pre>
<div class="block">Refine a pose (the translation and the rotation that transform a 3D point expressed in the object coordinate frame
 to the camera coordinate frame) from a 3D-2D point correspondences and starting from an initial solution.

 SEE: REF: calib3d_solvePnP</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>objectPoints</code> - Array of object points in the object coordinate space, Nx3 1-channel or 1xN/Nx1 3-channel,
 where N is the number of points. vector&lt;Point3d&gt; can also be passed here.</dd>
<dd><code>imagePoints</code> - Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,
 where N is the number of points. vector&lt;Point2d&gt; can also be passed here.</dd>
<dd><code>cameraMatrix</code> - Input camera intrinsic matrix \(\cameramatrix{A}\) .</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are
 assumed.</dd>
<dd><code>rvec</code> - Input/Output rotation vector (see REF: Rodrigues ) that, together with tvec, brings points from
 the model coordinate system to the camera coordinate system. Input values are used as an initial solution.</dd>
<dd><code>tvec</code> - Input/Output translation vector. Input values are used as an initial solution.</dd>
<dd><code>criteria</code> - Criteria when to stop the Levenberg-Marquard iterative algorithm.
 gain in the Damped Gauss-Newton formulation.

 The function refines the object pose given at least 3 object points, their corresponding image
 projections, an initial solution for the rotation and translation vector,
 as well as the camera intrinsic matrix and the distortion coefficients.
 The function minimizes the projection error with respect to the rotation and the translation vectors, using a
 virtual visual servoing (VVS) CITE: Chaumette06 CITE: Marchand16 scheme.</dd>
</dl>
</li>
</ul>
<a name="solvePnPRefineVVS-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.TermCriteria-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>solvePnPRefineVVS</h4>
<pre>public static&nbsp;void&nbsp;solvePnPRefineVVS(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;objectPoints,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;imagePoints,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                                     <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria,
                                     double&nbsp;VVSlambda)</pre>
<div class="block">Refine a pose (the translation and the rotation that transform a 3D point expressed in the object coordinate frame
 to the camera coordinate frame) from a 3D-2D point correspondences and starting from an initial solution.

 SEE: REF: calib3d_solvePnP</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>objectPoints</code> - Array of object points in the object coordinate space, Nx3 1-channel or 1xN/Nx1 3-channel,
 where N is the number of points. vector&lt;Point3d&gt; can also be passed here.</dd>
<dd><code>imagePoints</code> - Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,
 where N is the number of points. vector&lt;Point2d&gt; can also be passed here.</dd>
<dd><code>cameraMatrix</code> - Input camera intrinsic matrix \(\cameramatrix{A}\) .</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are
 assumed.</dd>
<dd><code>rvec</code> - Input/Output rotation vector (see REF: Rodrigues ) that, together with tvec, brings points from
 the model coordinate system to the camera coordinate system. Input values are used as an initial solution.</dd>
<dd><code>tvec</code> - Input/Output translation vector. Input values are used as an initial solution.</dd>
<dd><code>criteria</code> - Criteria when to stop the Levenberg-Marquard iterative algorithm.</dd>
<dd><code>VVSlambda</code> - Gain for the virtual visual servoing control law, equivalent to the \(\alpha\)
 gain in the Damped Gauss-Newton formulation.

 The function refines the object pose given at least 3 object points, their corresponding image
 projections, an initial solution for the rotation and translation vector,
 as well as the camera intrinsic matrix and the distortion coefficients.
 The function minimizes the projection error with respect to the rotation and the translation vectors, using a
 virtual visual servoing (VVS) CITE: Chaumette06 CITE: Marchand16 scheme.</dd>
</dl>
</li>
</ul>
<a name="triangleRasterize-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>triangleRasterize</h4>
<pre>public static&nbsp;void&nbsp;triangleRasterize(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;indices,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;colors,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;colorBuf,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;depthBuf,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;world2cam,
                                     double&nbsp;fovY,
                                     double&nbsp;zNear,
                                     double&nbsp;zFar)</pre>
<div class="block">Renders a set of triangles on a depth and color image

 Triangles can be drawn white (1.0, 1.0, 1.0), flat-shaded or with a color interpolation between vertices.
 In flat-shaded mode the 1st vertex color of each triangle is used to fill the whole triangle.

 The world2cam is an inverted camera pose matrix in fact. It transforms vertices from world to
 camera coordinate system.

 The camera coordinate system emulates the OpenGL's coordinate system having coordinate origin in a screen center,
 X axis pointing right, Y axis pointing up and Z axis pointing towards the viewer
 except that image is vertically flipped after the render.
 This means that all visible objects are placed in z-negative area, or exactly in -zNear &gt; z &gt; -zFar since
 zNear and zFar are positive.
 For example, at fovY = PI/2 the point (0, 1, -1) will be projected to (width/2, 0) screen point,
 (1, 0, -1) to (width/2 + height/2, height/2). Increasing fovY makes projection smaller and vice versa.

 The function does not create or clear output images before the rendering. This means that it can be used
 for drawing over an existing image or for rendering a model into a 3D scene using pre-filled Z-buffer.

 Empty scene results in a depth buffer filled by the maximum value since every pixel is infinitely far from the camera.
 Therefore, before rendering anything from scratch the depthBuf should be filled by zFar values (or by ones in INVDEPTH mode).

 There are special versions of this function named triangleRasterizeDepth and triangleRasterizeColor
 for cases if a user needs a color image or a depth image alone; they may run slightly faster.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>vertices</code> - vertices coordinates array. Should contain values of CV_32FC3 type or a compatible one (e.g. cv::Vec3f, etc.)</dd>
<dd><code>indices</code> - triangle vertices index array, 3 per triangle. Each index indicates a vertex in a vertices array.
 Should contain CV_32SC3 values or compatible</dd>
<dd><code>colors</code> - per-vertex colors of CV_32FC3 type or compatible. Can be empty or the same size as vertices array.
 If the values are out of [0; 1] range, the result correctness is not guaranteed</dd>
<dd><code>colorBuf</code> - an array representing the final rendered image. Should containt CV_32FC3 values and be the same size as depthBuf.
 Not cleared before rendering, i.e. the content is reused as there is some pre-rendered scene.</dd>
<dd><code>depthBuf</code> - an array of floats containing resulting Z buffer. Should contain float values and be the same size as colorBuf.
 Not cleared before rendering, i.e. the content is reused as there is some pre-rendered scene.
 Empty scene corresponds to all values set to zFar (or to 1.0 in INVDEPTH mode)</dd>
<dd><code>world2cam</code> - a 4x3 or 4x4 float or double matrix containing inverted (sic!) camera pose</dd>
<dd><code>fovY</code> - field of view in vertical direction, given in radians</dd>
<dd><code>zNear</code> - minimum Z value to render, everything closer is clipped</dd>
<dd><code>zFar</code> - maximum Z value to render, everything farther is clipped
 with CW culling and with disabled GL compatibility</dd>
</dl>
</li>
</ul>
<a name="triangleRasterize-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-double-double-org.opencv.cv3d.TriangleRasterizeSettings-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>triangleRasterize</h4>
<pre>public static&nbsp;void&nbsp;triangleRasterize(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;indices,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;colors,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;colorBuf,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;depthBuf,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;world2cam,
                                     double&nbsp;fovY,
                                     double&nbsp;zNear,
                                     double&nbsp;zFar,
                                     <a href="../../../org/opencv/cv3d/TriangleRasterizeSettings.html" title="class in org.opencv.cv3d">TriangleRasterizeSettings</a>&nbsp;settings)</pre>
<div class="block">Renders a set of triangles on a depth and color image

 Triangles can be drawn white (1.0, 1.0, 1.0), flat-shaded or with a color interpolation between vertices.
 In flat-shaded mode the 1st vertex color of each triangle is used to fill the whole triangle.

 The world2cam is an inverted camera pose matrix in fact. It transforms vertices from world to
 camera coordinate system.

 The camera coordinate system emulates the OpenGL's coordinate system having coordinate origin in a screen center,
 X axis pointing right, Y axis pointing up and Z axis pointing towards the viewer
 except that image is vertically flipped after the render.
 This means that all visible objects are placed in z-negative area, or exactly in -zNear &gt; z &gt; -zFar since
 zNear and zFar are positive.
 For example, at fovY = PI/2 the point (0, 1, -1) will be projected to (width/2, 0) screen point,
 (1, 0, -1) to (width/2 + height/2, height/2). Increasing fovY makes projection smaller and vice versa.

 The function does not create or clear output images before the rendering. This means that it can be used
 for drawing over an existing image or for rendering a model into a 3D scene using pre-filled Z-buffer.

 Empty scene results in a depth buffer filled by the maximum value since every pixel is infinitely far from the camera.
 Therefore, before rendering anything from scratch the depthBuf should be filled by zFar values (or by ones in INVDEPTH mode).

 There are special versions of this function named triangleRasterizeDepth and triangleRasterizeColor
 for cases if a user needs a color image or a depth image alone; they may run slightly faster.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>vertices</code> - vertices coordinates array. Should contain values of CV_32FC3 type or a compatible one (e.g. cv::Vec3f, etc.)</dd>
<dd><code>indices</code> - triangle vertices index array, 3 per triangle. Each index indicates a vertex in a vertices array.
 Should contain CV_32SC3 values or compatible</dd>
<dd><code>colors</code> - per-vertex colors of CV_32FC3 type or compatible. Can be empty or the same size as vertices array.
 If the values are out of [0; 1] range, the result correctness is not guaranteed</dd>
<dd><code>colorBuf</code> - an array representing the final rendered image. Should containt CV_32FC3 values and be the same size as depthBuf.
 Not cleared before rendering, i.e. the content is reused as there is some pre-rendered scene.</dd>
<dd><code>depthBuf</code> - an array of floats containing resulting Z buffer. Should contain float values and be the same size as colorBuf.
 Not cleared before rendering, i.e. the content is reused as there is some pre-rendered scene.
 Empty scene corresponds to all values set to zFar (or to 1.0 in INVDEPTH mode)</dd>
<dd><code>world2cam</code> - a 4x3 or 4x4 float or double matrix containing inverted (sic!) camera pose</dd>
<dd><code>fovY</code> - field of view in vertical direction, given in radians</dd>
<dd><code>zNear</code> - minimum Z value to render, everything closer is clipped</dd>
<dd><code>zFar</code> - maximum Z value to render, everything farther is clipped</dd>
<dd><code>settings</code> - see TriangleRasterizeSettings. By default the smooth shading is on,
 with CW culling and with disabled GL compatibility</dd>
</dl>
</li>
</ul>
<a name="triangleRasterizeColor-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>triangleRasterizeColor</h4>
<pre>public static&nbsp;void&nbsp;triangleRasterizeColor(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;indices,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;colors,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;colorBuf,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;world2cam,
                                          double&nbsp;fovY,
                                          double&nbsp;zNear,
                                          double&nbsp;zFar)</pre>
<div class="block">Overloaded version of triangleRasterize() with color-only rendering</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>vertices</code> - vertices coordinates array. Should contain values of CV_32FC3 type or a compatible one (e.g. cv::Vec3f, etc.)</dd>
<dd><code>indices</code> - triangle vertices index array, 3 per triangle. Each index indicates a vertex in a vertices array.
 Should contain CV_32SC3 values or compatible</dd>
<dd><code>colors</code> - per-vertex colors of CV_32FC3 type or compatible. Can be empty or the same size as vertices array.
 If the values are out of [0; 1] range, the result correctness is not guaranteed</dd>
<dd><code>colorBuf</code> - an array representing the final rendered image. Should containt CV_32FC3 values and be the same size as depthBuf.
 Not cleared before rendering, i.e. the content is reused as there is some pre-rendered scene.</dd>
<dd><code>world2cam</code> - a 4x3 or 4x4 float or double matrix containing inverted (sic!) camera pose</dd>
<dd><code>fovY</code> - field of view in vertical direction, given in radians</dd>
<dd><code>zNear</code> - minimum Z value to render, everything closer is clipped</dd>
<dd><code>zFar</code> - maximum Z value to render, everything farther is clipped
 with CW culling and with disabled GL compatibility</dd>
</dl>
</li>
</ul>
<a name="triangleRasterizeColor-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-double-double-org.opencv.cv3d.TriangleRasterizeSettings-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>triangleRasterizeColor</h4>
<pre>public static&nbsp;void&nbsp;triangleRasterizeColor(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;indices,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;colors,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;colorBuf,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;world2cam,
                                          double&nbsp;fovY,
                                          double&nbsp;zNear,
                                          double&nbsp;zFar,
                                          <a href="../../../org/opencv/cv3d/TriangleRasterizeSettings.html" title="class in org.opencv.cv3d">TriangleRasterizeSettings</a>&nbsp;settings)</pre>
<div class="block">Overloaded version of triangleRasterize() with color-only rendering</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>vertices</code> - vertices coordinates array. Should contain values of CV_32FC3 type or a compatible one (e.g. cv::Vec3f, etc.)</dd>
<dd><code>indices</code> - triangle vertices index array, 3 per triangle. Each index indicates a vertex in a vertices array.
 Should contain CV_32SC3 values or compatible</dd>
<dd><code>colors</code> - per-vertex colors of CV_32FC3 type or compatible. Can be empty or the same size as vertices array.
 If the values are out of [0; 1] range, the result correctness is not guaranteed</dd>
<dd><code>colorBuf</code> - an array representing the final rendered image. Should containt CV_32FC3 values and be the same size as depthBuf.
 Not cleared before rendering, i.e. the content is reused as there is some pre-rendered scene.</dd>
<dd><code>world2cam</code> - a 4x3 or 4x4 float or double matrix containing inverted (sic!) camera pose</dd>
<dd><code>fovY</code> - field of view in vertical direction, given in radians</dd>
<dd><code>zNear</code> - minimum Z value to render, everything closer is clipped</dd>
<dd><code>zFar</code> - maximum Z value to render, everything farther is clipped</dd>
<dd><code>settings</code> - see TriangleRasterizeSettings. By default the smooth shading is on,
 with CW culling and with disabled GL compatibility</dd>
</dl>
</li>
</ul>
<a name="triangleRasterizeDepth-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>triangleRasterizeDepth</h4>
<pre>public static&nbsp;void&nbsp;triangleRasterizeDepth(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;indices,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;depthBuf,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;world2cam,
                                          double&nbsp;fovY,
                                          double&nbsp;zNear,
                                          double&nbsp;zFar)</pre>
<div class="block">Overloaded version of triangleRasterize() with depth-only rendering</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>vertices</code> - vertices coordinates array. Should contain values of CV_32FC3 type or a compatible one (e.g. cv::Vec3f, etc.)</dd>
<dd><code>indices</code> - triangle vertices index array, 3 per triangle. Each index indicates a vertex in a vertices array.
 Should contain CV_32SC3 values or compatible</dd>
<dd><code>depthBuf</code> - an array of floats containing resulting Z buffer. Should contain float values and be the same size as colorBuf.
 Not cleared before rendering, i.e. the content is reused as there is some pre-rendered scene.
 Empty scene corresponds to all values set to zFar (or to 1.0 in INVDEPTH mode)</dd>
<dd><code>world2cam</code> - a 4x3 or 4x4 float or double matrix containing inverted (sic!) camera pose</dd>
<dd><code>fovY</code> - field of view in vertical direction, given in radians</dd>
<dd><code>zNear</code> - minimum Z value to render, everything closer is clipped</dd>
<dd><code>zFar</code> - maximum Z value to render, everything farther is clipped
 with CW culling and with disabled GL compatibility</dd>
</dl>
</li>
</ul>
<a name="triangleRasterizeDepth-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-double-double-org.opencv.cv3d.TriangleRasterizeSettings-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>triangleRasterizeDepth</h4>
<pre>public static&nbsp;void&nbsp;triangleRasterizeDepth(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vertices,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;indices,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;depthBuf,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;world2cam,
                                          double&nbsp;fovY,
                                          double&nbsp;zNear,
                                          double&nbsp;zFar,
                                          <a href="../../../org/opencv/cv3d/TriangleRasterizeSettings.html" title="class in org.opencv.cv3d">TriangleRasterizeSettings</a>&nbsp;settings)</pre>
<div class="block">Overloaded version of triangleRasterize() with depth-only rendering</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>vertices</code> - vertices coordinates array. Should contain values of CV_32FC3 type or a compatible one (e.g. cv::Vec3f, etc.)</dd>
<dd><code>indices</code> - triangle vertices index array, 3 per triangle. Each index indicates a vertex in a vertices array.
 Should contain CV_32SC3 values or compatible</dd>
<dd><code>depthBuf</code> - an array of floats containing resulting Z buffer. Should contain float values and be the same size as colorBuf.
 Not cleared before rendering, i.e. the content is reused as there is some pre-rendered scene.
 Empty scene corresponds to all values set to zFar (or to 1.0 in INVDEPTH mode)</dd>
<dd><code>world2cam</code> - a 4x3 or 4x4 float or double matrix containing inverted (sic!) camera pose</dd>
<dd><code>fovY</code> - field of view in vertical direction, given in radians</dd>
<dd><code>zNear</code> - minimum Z value to render, everything closer is clipped</dd>
<dd><code>zFar</code> - maximum Z value to render, everything farther is clipped</dd>
<dd><code>settings</code> - see TriangleRasterizeSettings. By default the smooth shading is on,
 with CW culling and with disabled GL compatibility</dd>
</dl>
</li>
</ul>
<a name="triangulatePoints-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>triangulatePoints</h4>
<pre>public static&nbsp;void&nbsp;triangulatePoints(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;projMatr1,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;projMatr2,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;projPoints1,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;projPoints2,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points4D)</pre>
<div class="block">This function reconstructs 3-dimensional points (in homogeneous coordinates) by using
 their observations with a stereo camera.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>projMatr1</code> - 3x4 projection matrix of the first camera, i.e. this matrix projects 3D points
 given in the world's coordinate system into the first image.</dd>
<dd><code>projMatr2</code> - 3x4 projection matrix of the second camera, i.e. this matrix projects 3D points
 given in the world's coordinate system into the second image.</dd>
<dd><code>projPoints1</code> - 2xN array of feature points in the first image. In the case of the c++ version,
 it can be also a vector of feature points or two-channel matrix of size 1xN or Nx1.</dd>
<dd><code>projPoints2</code> - 2xN array of corresponding points in the second image. In the case of the c++
 version, it can be also a vector of feature points or two-channel matrix of size 1xN or Nx1.</dd>
<dd><code>points4D</code> - 4xN array of reconstructed points in homogeneous coordinates. These points are
 returned in the world's coordinate system.

 <b>Note:</b>
    Keep in mind that all input data should be of float type in order for this function to work.

 <b>Note:</b>
    If the projection matrices from REF: stereoRectify are used, then the returned points are
    represented in the first camera's rectified coordinate system.

 SEE:
    reprojectImageTo3D</dd>
</dl>
</li>
</ul>
<a name="undistort-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>undistort</h4>
<pre>public static&nbsp;void&nbsp;undistort(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs)</pre>
<div class="block">Transforms an image to compensate for lens distortion.

 The function transforms an image to compensate radial and tangential lens distortion.

 The function is simply a combination of #initUndistortRectifyMap (with unity R ) and #remap
 (with bilinear interpolation). See the former function for details of the transformation being
 performed.

 Those pixels in the destination image, for which there is no correspondent pixels in the source
 image, are filled with zeros (black color).

 A particular subset of the source image that will be visible in the corrected image can be regulated
 by newCameraMatrix. You can use #getOptimalNewCameraMatrix to compute the appropriate
 newCameraMatrix depending on your requirements.

 The camera matrix and the distortion parameters can be determined using #calibrateCamera. If
 the resolution of images is different from the resolution used at the calibration stage, \(f_x,
 f_y, c_x\) and \(c_y\) need to be scaled accordingly, while the distortion coefficients remain
 the same.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Input (distorted) image.</dd>
<dd><code>dst</code> - Output (corrected) image that has the same size and type as src .</dd>
<dd><code>cameraMatrix</code> - Input camera matrix \(A = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\) .</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\)
 of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.
 cameraMatrix but you may additionally scale and shift the result by using a different matrix.</dd>
</dl>
</li>
</ul>
<a name="undistort-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>undistort</h4>
<pre>public static&nbsp;void&nbsp;undistort(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;newCameraMatrix)</pre>
<div class="block">Transforms an image to compensate for lens distortion.

 The function transforms an image to compensate radial and tangential lens distortion.

 The function is simply a combination of #initUndistortRectifyMap (with unity R ) and #remap
 (with bilinear interpolation). See the former function for details of the transformation being
 performed.

 Those pixels in the destination image, for which there is no correspondent pixels in the source
 image, are filled with zeros (black color).

 A particular subset of the source image that will be visible in the corrected image can be regulated
 by newCameraMatrix. You can use #getOptimalNewCameraMatrix to compute the appropriate
 newCameraMatrix depending on your requirements.

 The camera matrix and the distortion parameters can be determined using #calibrateCamera. If
 the resolution of images is different from the resolution used at the calibration stage, \(f_x,
 f_y, c_x\) and \(c_y\) need to be scaled accordingly, while the distortion coefficients remain
 the same.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Input (distorted) image.</dd>
<dd><code>dst</code> - Output (corrected) image that has the same size and type as src .</dd>
<dd><code>cameraMatrix</code> - Input camera matrix \(A = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\) .</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\)
 of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</dd>
<dd><code>newCameraMatrix</code> - Camera matrix of the distorted image. By default, it is the same as
 cameraMatrix but you may additionally scale and shift the result by using a different matrix.</dd>
</dl>
</li>
</ul>
<a name="undistortImagePoints-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>undistortImagePoints</h4>
<pre>public static&nbsp;void&nbsp;undistortImagePoints(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs)</pre>
<div class="block">Compute undistorted image points position</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Observed points position, 2xN/Nx2 1-channel or 1xN/Nx1 2-channel (CV_32FC2 or CV_64FC2) (or vector&lt;Point2f&gt; ).</dd>
<dd><code>dst</code> - Output undistorted points position (1xN/Nx1 2-channel or vector&lt;Point2f&gt; ).</dd>
<dd><code>cameraMatrix</code> - Camera matrix \(\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\) .</dd>
<dd><code>distCoeffs</code> - Distortion coefficients</dd>
</dl>
</li>
</ul>
<a name="undistortImagePoints-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.TermCriteria-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>undistortImagePoints</h4>
<pre>public static&nbsp;void&nbsp;undistortImagePoints(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                                        <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;arg1)</pre>
<div class="block">Compute undistorted image points position</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Observed points position, 2xN/Nx2 1-channel or 1xN/Nx1 2-channel (CV_32FC2 or CV_64FC2) (or vector&lt;Point2f&gt; ).</dd>
<dd><code>dst</code> - Output undistorted points position (1xN/Nx1 2-channel or vector&lt;Point2f&gt; ).</dd>
<dd><code>cameraMatrix</code> - Camera matrix \(\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\) .</dd>
<dd><code>distCoeffs</code> - Distortion coefficients</dd>
<dd><code>arg1</code> - automatically generated</dd>
</dl>
</li>
</ul>
<a name="undistortPoints-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>undistortPoints</h4>
<pre>public static&nbsp;void&nbsp;undistortPoints(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;src,
                                   <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;dst,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs)</pre>
<div class="block">Computes the ideal point coordinates from the observed point coordinates.

 The function is similar to #undistort and #initUndistortRectifyMap but it operates on a
 sparse set of points instead of a raster image. Also the function performs a reverse transformation
 to  #projectPoints. In case of a 3D object, it does not reconstruct its 3D coordinates, but for a
 planar object, it does, up to a translation vector, if the proper R is specified.

 For each observed point coordinate \((u, v)\) the function computes:
 \(
 \begin{array}{l}
 x^{"}  \leftarrow (u - c_x)/f_x  \\
 y^{"}  \leftarrow (v - c_y)/f_y  \\
 (x',y') = undistort(x^{"},y^{"}, \texttt{distCoeffs}) \\
 {[X\,Y\,W]} ^T  \leftarrow R*[x' \, y' \, 1]^T  \\
 x  \leftarrow X/W  \\
 y  \leftarrow Y/W  \\
 \text{only performed if P is specified:} \\
 u'  \leftarrow x {f'}_x + {c'}_x  \\
 v'  \leftarrow y {f'}_y + {c'}_y
 \end{array}
 \)

 where *undistort* is an approximate iterative algorithm that estimates the normalized original
 point coordinates out of the normalized distorted point coordinates ("normalized" means that the
 coordinates do not depend on the camera matrix).

 The function can be used for both a stereo camera head or a monocular camera (when R is empty).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Observed point coordinates, 2xN/Nx2 1-channel or 1xN/Nx1 2-channel (CV_32FC2 or CV_64FC2) (or
 vector&lt;Point2f&gt; ).</dd>
<dd><code>dst</code> - Output ideal point coordinates (1xN/Nx1 2-channel or vector&lt;Point2f&gt; ) after undistortion and reverse perspective
 transformation. If matrix P is identity or omitted, dst will contain normalized point coordinates.</dd>
<dd><code>cameraMatrix</code> - Camera matrix \(\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\) .</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\)
 of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.
 #stereoRectify can be passed here. If the matrix is empty, the identity transformation is used.
 #stereoRectify can be passed here. If the matrix is empty, the identity new camera matrix is used.</dd>
</dl>
</li>
</ul>
<a name="undistortPoints-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>undistortPoints</h4>
<pre>public static&nbsp;void&nbsp;undistortPoints(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;src,
                                   <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;dst,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R)</pre>
<div class="block">Computes the ideal point coordinates from the observed point coordinates.

 The function is similar to #undistort and #initUndistortRectifyMap but it operates on a
 sparse set of points instead of a raster image. Also the function performs a reverse transformation
 to  #projectPoints. In case of a 3D object, it does not reconstruct its 3D coordinates, but for a
 planar object, it does, up to a translation vector, if the proper R is specified.

 For each observed point coordinate \((u, v)\) the function computes:
 \(
 \begin{array}{l}
 x^{"}  \leftarrow (u - c_x)/f_x  \\
 y^{"}  \leftarrow (v - c_y)/f_y  \\
 (x',y') = undistort(x^{"},y^{"}, \texttt{distCoeffs}) \\
 {[X\,Y\,W]} ^T  \leftarrow R*[x' \, y' \, 1]^T  \\
 x  \leftarrow X/W  \\
 y  \leftarrow Y/W  \\
 \text{only performed if P is specified:} \\
 u'  \leftarrow x {f'}_x + {c'}_x  \\
 v'  \leftarrow y {f'}_y + {c'}_y
 \end{array}
 \)

 where *undistort* is an approximate iterative algorithm that estimates the normalized original
 point coordinates out of the normalized distorted point coordinates ("normalized" means that the
 coordinates do not depend on the camera matrix).

 The function can be used for both a stereo camera head or a monocular camera (when R is empty).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Observed point coordinates, 2xN/Nx2 1-channel or 1xN/Nx1 2-channel (CV_32FC2 or CV_64FC2) (or
 vector&lt;Point2f&gt; ).</dd>
<dd><code>dst</code> - Output ideal point coordinates (1xN/Nx1 2-channel or vector&lt;Point2f&gt; ) after undistortion and reverse perspective
 transformation. If matrix P is identity or omitted, dst will contain normalized point coordinates.</dd>
<dd><code>cameraMatrix</code> - Camera matrix \(\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\) .</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\)
 of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</dd>
<dd><code>R</code> - Rectification transformation in the object space (3x3 matrix). R1 or R2 computed by
 #stereoRectify can be passed here. If the matrix is empty, the identity transformation is used.
 #stereoRectify can be passed here. If the matrix is empty, the identity new camera matrix is used.</dd>
</dl>
</li>
</ul>
<a name="undistortPoints-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>undistortPoints</h4>
<pre>public static&nbsp;void&nbsp;undistortPoints(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;src,
                                   <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;dst,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;P)</pre>
<div class="block">Computes the ideal point coordinates from the observed point coordinates.

 The function is similar to #undistort and #initUndistortRectifyMap but it operates on a
 sparse set of points instead of a raster image. Also the function performs a reverse transformation
 to  #projectPoints. In case of a 3D object, it does not reconstruct its 3D coordinates, but for a
 planar object, it does, up to a translation vector, if the proper R is specified.

 For each observed point coordinate \((u, v)\) the function computes:
 \(
 \begin{array}{l}
 x^{"}  \leftarrow (u - c_x)/f_x  \\
 y^{"}  \leftarrow (v - c_y)/f_y  \\
 (x',y') = undistort(x^{"},y^{"}, \texttt{distCoeffs}) \\
 {[X\,Y\,W]} ^T  \leftarrow R*[x' \, y' \, 1]^T  \\
 x  \leftarrow X/W  \\
 y  \leftarrow Y/W  \\
 \text{only performed if P is specified:} \\
 u'  \leftarrow x {f'}_x + {c'}_x  \\
 v'  \leftarrow y {f'}_y + {c'}_y
 \end{array}
 \)

 where *undistort* is an approximate iterative algorithm that estimates the normalized original
 point coordinates out of the normalized distorted point coordinates ("normalized" means that the
 coordinates do not depend on the camera matrix).

 The function can be used for both a stereo camera head or a monocular camera (when R is empty).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Observed point coordinates, 2xN/Nx2 1-channel or 1xN/Nx1 2-channel (CV_32FC2 or CV_64FC2) (or
 vector&lt;Point2f&gt; ).</dd>
<dd><code>dst</code> - Output ideal point coordinates (1xN/Nx1 2-channel or vector&lt;Point2f&gt; ) after undistortion and reverse perspective
 transformation. If matrix P is identity or omitted, dst will contain normalized point coordinates.</dd>
<dd><code>cameraMatrix</code> - Camera matrix \(\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\) .</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\)
 of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</dd>
<dd><code>R</code> - Rectification transformation in the object space (3x3 matrix). R1 or R2 computed by
 #stereoRectify can be passed here. If the matrix is empty, the identity transformation is used.</dd>
<dd><code>P</code> - New camera matrix (3x3) or new projection matrix (3x4) \(\begin{bmatrix} {f'}_x &amp; 0 &amp; {c'}_x &amp; t_x \\ 0 &amp; {f'}_y &amp; {c'}_y &amp; t_y \\ 0 &amp; 0 &amp; 1 &amp; t_z \end{bmatrix}\). P1 or P2 computed by
 #stereoRectify can be passed here. If the matrix is empty, the identity new camera matrix is used.</dd>
</dl>
</li>
</ul>
<a name="undistortPoints-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.TermCriteria-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>undistortPoints</h4>
<pre>public static&nbsp;void&nbsp;undistortPoints(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;src,
                                   <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;dst,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;P,
                                   <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria)</pre>
<div class="block">Computes the ideal point coordinates from the observed point coordinates.

 The function is similar to #undistort and #initUndistortRectifyMap but it operates on a
 sparse set of points instead of a raster image. Also the function performs a reverse transformation
 to  #projectPoints. In case of a 3D object, it does not reconstruct its 3D coordinates, but for a
 planar object, it does, up to a translation vector, if the proper R is specified.

 For each observed point coordinate \((u, v)\) the function computes:
 \(
 \begin{array}{l}
 x^{"}  \leftarrow (u - c_x)/f_x  \\
 y^{"}  \leftarrow (v - c_y)/f_y  \\
 (x',y') = undistort(x^{"},y^{"}, \texttt{distCoeffs}) \\
 {[X\,Y\,W]} ^T  \leftarrow R*[x' \, y' \, 1]^T  \\
 x  \leftarrow X/W  \\
 y  \leftarrow Y/W  \\
 \text{only performed if P is specified:} \\
 u'  \leftarrow x {f'}_x + {c'}_x  \\
 v'  \leftarrow y {f'}_y + {c'}_y
 \end{array}
 \)

 where *undistort* is an approximate iterative algorithm that estimates the normalized original
 point coordinates out of the normalized distorted point coordinates ("normalized" means that the
 coordinates do not depend on the camera matrix).

 The function can be used for both a stereo camera head or a monocular camera (when R is empty).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Observed point coordinates, 2xN/Nx2 1-channel or 1xN/Nx1 2-channel (CV_32FC2 or CV_64FC2) (or
 vector&lt;Point2f&gt; ).</dd>
<dd><code>dst</code> - Output ideal point coordinates (1xN/Nx1 2-channel or vector&lt;Point2f&gt; ) after undistortion and reverse perspective
 transformation. If matrix P is identity or omitted, dst will contain normalized point coordinates.</dd>
<dd><code>cameraMatrix</code> - Camera matrix \(\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\) .</dd>
<dd><code>distCoeffs</code> - Input vector of distortion coefficients
 \((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\)
 of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</dd>
<dd><code>R</code> - Rectification transformation in the object space (3x3 matrix). R1 or R2 computed by
 #stereoRectify can be passed here. If the matrix is empty, the identity transformation is used.</dd>
<dd><code>P</code> - New camera matrix (3x3) or new projection matrix (3x4) \(\begin{bmatrix} {f'}_x &amp; 0 &amp; {c'}_x &amp; t_x \\ 0 &amp; {f'}_y &amp; {c'}_y &amp; t_y \\ 0 &amp; 0 &amp; 1 &amp; t_z \end{bmatrix}\). P1 or P2 computed by
 #stereoRectify can be passed here. If the matrix is empty, the identity new camera matrix is used.</dd>
<dd><code>criteria</code> - termination criteria for the iterative point undistortion algorithm</dd>
</dl>
</li>
</ul>
<a name="warpFrame-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>warpFrame</h4>
<pre>public static&nbsp;void&nbsp;warpFrame(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;depth,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Rt,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix)</pre>
<div class="block">Warps depth or RGB-D image by reprojecting it in 3d, applying Rt transformation
 and then projecting it back onto the image plane.
 This function can be used to visualize the results of the Odometry algorithm.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>depth</code> - Depth data, should be 1-channel CV_16U, CV_16S, CV_32F or CV_64F</dd>
<dd><code>image</code> - RGB image (optional), should be 1-, 3- or 4-channel CV_8U</dd>
<dd><code>mask</code> - Mask of used pixels (optional), should be CV_8UC1</dd>
<dd><code>Rt</code> - Rotation+translation matrix (3x4 or 4x4) to be applied to depth points</dd>
<dd><code>cameraMatrix</code> - Camera intrinsics matrix (3x3)</dd>
</dl>
</li>
</ul>
<a name="warpFrame-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>warpFrame</h4>
<pre>public static&nbsp;void&nbsp;warpFrame(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;depth,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Rt,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;warpedDepth)</pre>
<div class="block">Warps depth or RGB-D image by reprojecting it in 3d, applying Rt transformation
 and then projecting it back onto the image plane.
 This function can be used to visualize the results of the Odometry algorithm.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>depth</code> - Depth data, should be 1-channel CV_16U, CV_16S, CV_32F or CV_64F</dd>
<dd><code>image</code> - RGB image (optional), should be 1-, 3- or 4-channel CV_8U</dd>
<dd><code>mask</code> - Mask of used pixels (optional), should be CV_8UC1</dd>
<dd><code>Rt</code> - Rotation+translation matrix (3x4 or 4x4) to be applied to depth points</dd>
<dd><code>cameraMatrix</code> - Camera intrinsics matrix (3x3)</dd>
<dd><code>warpedDepth</code> - The warped depth data (optional)</dd>
</dl>
</li>
</ul>
<a name="warpFrame-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>warpFrame</h4>
<pre>public static&nbsp;void&nbsp;warpFrame(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;depth,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Rt,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;warpedDepth,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;warpedImage)</pre>
<div class="block">Warps depth or RGB-D image by reprojecting it in 3d, applying Rt transformation
 and then projecting it back onto the image plane.
 This function can be used to visualize the results of the Odometry algorithm.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>depth</code> - Depth data, should be 1-channel CV_16U, CV_16S, CV_32F or CV_64F</dd>
<dd><code>image</code> - RGB image (optional), should be 1-, 3- or 4-channel CV_8U</dd>
<dd><code>mask</code> - Mask of used pixels (optional), should be CV_8UC1</dd>
<dd><code>Rt</code> - Rotation+translation matrix (3x4 or 4x4) to be applied to depth points</dd>
<dd><code>cameraMatrix</code> - Camera intrinsics matrix (3x3)</dd>
<dd><code>warpedDepth</code> - The warped depth data (optional)</dd>
<dd><code>warpedImage</code> - The warped RGB image (optional)</dd>
</dl>
</li>
</ul>
<a name="warpFrame-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>warpFrame</h4>
<pre>public static&nbsp;void&nbsp;warpFrame(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;depth,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Rt,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;warpedDepth,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;warpedImage,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;warpedMask)</pre>
<div class="block">Warps depth or RGB-D image by reprojecting it in 3d, applying Rt transformation
 and then projecting it back onto the image plane.
 This function can be used to visualize the results of the Odometry algorithm.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>depth</code> - Depth data, should be 1-channel CV_16U, CV_16S, CV_32F or CV_64F</dd>
<dd><code>image</code> - RGB image (optional), should be 1-, 3- or 4-channel CV_8U</dd>
<dd><code>mask</code> - Mask of used pixels (optional), should be CV_8UC1</dd>
<dd><code>Rt</code> - Rotation+translation matrix (3x4 or 4x4) to be applied to depth points</dd>
<dd><code>cameraMatrix</code> - Camera intrinsics matrix (3x3)</dd>
<dd><code>warpedDepth</code> - The warped depth data (optional)</dd>
<dd><code>warpedImage</code> - The warped RGB image (optional)</dd>
<dd><code>warpedMask</code> - The mask of valid pixels in warped image (optional)</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage">
            <script>
              var url = window.location.href;
              var pos = url.lastIndexOf('/javadoc/');
              url = pos >= 0 ? (url.substring(0, pos) + '/javadoc/mymath.js') : (window.location.origin + '/mymath.js');
              var script = document.createElement('script');
              script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML,' + url;
              document.getElementsByTagName('head')[0].appendChild(script);
            </script>
</div>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev&nbsp;Class</li>
<li><a href="../../../org/opencv/cv3d/Octree.html" title="class in org.opencv.cv3d"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?org/opencv/cv3d/Cv3d.html" target="_top">Frames</a></li>
<li><a href="Cv3d.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small>Generated on 2024-12-05 14:16:19 / OpenCV 5.0.0alpha</small></p>
</body>
</html>
